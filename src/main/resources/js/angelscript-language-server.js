"use strict";
var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/utils/is.js
var require_is = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports2.thenable = thenable;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
    var ResponseError = class _ResponseError extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, _ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports2.ResponseError = ResponseError;
    var ParameterStructures = class _ParameterStructures {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === _ParameterStructures.auto || value === _ParameterStructures.byName || value === _ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message = exports2.Message || (exports2.Message = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch = exports2.Touch || (exports2.Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        var _a2;
        return (_a2 = this._head) == null ? void 0 : _a2.value;
      }
      get last() {
        var _a2;
        return (_a2 = this._tail) == null ? void 0 : _a2.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable = exports2.Disposable || (exports2.Disposable = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event = exports2.Event || (exports2.Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class _Emitter {
      constructor(_options) {
        this._options = _options;
      }
      /**
       * For the public to allow to subscribe
       * to events from this Emitter
       */
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = _Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      /**
       * To be kept private to fire an event to
       * subscribers
       */
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken = exports2.CancellationToken || (exports2.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports2.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports2.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var semaphore_1 = require_semaphore();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader = exports2.MessageReader || (exports2.MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            const headers = this.buffer.tryReadHeaders(true);
            if (!headers) {
              return;
            }
            const contentLength = headers.get("content-length");
            if (!contentLength) {
              this.fireError(new Error("Header must provide a Content-Length property."));
              return;
            }
            const length = parseInt(contentLength);
            if (isNaN(length)) {
              this.fireError(new Error("Content-Length value must be a number."));
              return;
            }
            this.nextMessageLength = length;
          }
          const body = this.buffer.tryReadBody(this.nextMessageLength);
          if (body === void 0) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          this.readSemaphore.lock(async () => {
            const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
            const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
            this.callback(message);
          }).catch((error) => {
            this.fireError(error);
          });
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter = exports2.MessageWriter || (exports2.MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row:
          while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column:
              while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                  case CR:
                    switch (state) {
                      case 0:
                        state = 1;
                        break;
                      case 2:
                        state = 3;
                        break;
                      default:
                        state = 0;
                    }
                    break;
                  case LF:
                    switch (state) {
                      case 1:
                        state = 2;
                        break;
                      case 3:
                        state = 4;
                        offset++;
                        break row;
                      default:
                        state = 0;
                    }
                    break;
                  default:
                    state = 0;
                }
                offset++;
              }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error("Message header must separate key and value using :");
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.RequestCancellationReceiverStrategy = exports2.IdCancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken = exports2.ProgressToken || (exports2.ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace = exports2.Trace || (exports2.Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues = exports2.TraceValues || (exports2.TraceValues = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace = exports2.Trace || (exports2.Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
    var ConnectionError = class _ConnectionError extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, _ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy = exports2.IdCancellationReceiverStrategy || (exports2.IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy = exports2.RequestCancellationReceiverStrategy || (exports2.RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy = exports2.CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy = exports2.CancellationSenderStrategy || (exports2.CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy = exports2.CancellationStrategy || (exports2.CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy = exports2.MessageStrategy || (exports2.MessageStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions = exports2.ConnectionOptions || (exports2.ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options == null ? void 0 : options.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options == null ? void 0 : options.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection2 = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch((error) => {
            logger.error(`Sending notification failed.`);
            throw error;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection2.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection2, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve, reject) => {
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable == null ? void 0 : disposable.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable == null ? void 0 : disposable.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              await messageWriter.write(requestMessage);
              responsePromises.set(id, responsePromise);
            } catch (error) {
              logger.error(`Sending request failed.`);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
              throw error;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection2.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection2.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection2.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection2;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.AbstractMessageBuffer = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.SharedArrayReceiverStrategy = exports2.SharedArraySenderStrategy = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
    exports2.MessageStrategy = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.TraceValues = exports2.Trace = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports2, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports2, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports2, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports2, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/node/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require("util");
    var api_1 = require_api();
    var MessageBuffer = class _MessageBuffer extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return _MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return api_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.PortMessageWriter = exports2.PortMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var path = require("path");
    var os = require("os");
    var crypto_1 = require("crypto");
    var net_12 = require("net");
    var api_1 = require_api();
    __exportStar(require_api(), exports2);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports2.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter;
    var PortMessageReader = class extends api_1.AbstractMessageReader {
      constructor(port2) {
        super();
        this.onData = new api_1.Emitter();
        port2.on("close", () => this.fireClose);
        port2.on("error", (error) => this.fireError(error));
        port2.on("message", (message) => {
          this.onData.fire(message);
        });
      }
      listen(callback) {
        return this.onData.event(callback);
      }
    };
    exports2.PortMessageReader = PortMessageReader;
    var PortMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(port2) {
        super();
        this.port = port2;
        this.errorCount = 0;
        port2.on("close", () => this.fireClose());
        port2.on("error", (error) => this.fireError(error));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.PortMessageWriter = PortMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports2.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server = (0, net_12.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_12.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port2, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server = (0, net_12.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port2, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port2, encoding = "utf-8") {
      const socket = (0, net_12.createConnection)(port2, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-jsonrpc/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-types/lib/umd/main.js"(exports2, module2) {
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0)
          module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.TextDocument = exports3.EOL = exports3.WorkspaceFolder = exports3.InlayHint = exports3.InlayHintLabelPart = exports3.InlayHintKind = exports3.InlineValueContext = exports3.InlineValueEvaluatableExpression = exports3.InlineValueVariableLookup = exports3.InlineValueText = exports3.SemanticTokens = exports3.SemanticTokenModifiers = exports3.SemanticTokenTypes = exports3.SelectionRange = exports3.DocumentLink = exports3.FormattingOptions = exports3.CodeLens = exports3.CodeAction = exports3.CodeActionContext = exports3.CodeActionTriggerKind = exports3.CodeActionKind = exports3.DocumentSymbol = exports3.WorkspaceSymbol = exports3.SymbolInformation = exports3.SymbolTag = exports3.SymbolKind = exports3.DocumentHighlight = exports3.DocumentHighlightKind = exports3.SignatureInformation = exports3.ParameterInformation = exports3.Hover = exports3.MarkedString = exports3.CompletionList = exports3.CompletionItem = exports3.CompletionItemLabelDetails = exports3.InsertTextMode = exports3.InsertReplaceEdit = exports3.CompletionItemTag = exports3.InsertTextFormat = exports3.CompletionItemKind = exports3.MarkupContent = exports3.MarkupKind = exports3.TextDocumentItem = exports3.OptionalVersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier = exports3.TextDocumentIdentifier = exports3.WorkspaceChange = exports3.WorkspaceEdit = exports3.DeleteFile = exports3.RenameFile = exports3.CreateFile = exports3.TextDocumentEdit = exports3.AnnotatedTextEdit = exports3.ChangeAnnotationIdentifier = exports3.ChangeAnnotation = exports3.TextEdit = exports3.Command = exports3.Diagnostic = exports3.CodeDescription = exports3.DiagnosticTag = exports3.DiagnosticSeverity = exports3.DiagnosticRelatedInformation = exports3.FoldingRange = exports3.FoldingRangeKind = exports3.ColorPresentation = exports3.ColorInformation = exports3.Color = exports3.LocationLink = exports3.Location = exports3.Range = exports3.Position = exports3.uinteger = exports3.integer = exports3.URI = exports3.DocumentUri = void 0;
      var DocumentUri;
      (function(DocumentUri2) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri2.is = is;
      })(DocumentUri = exports3.DocumentUri || (exports3.DocumentUri = {}));
      var URI;
      (function(URI2) {
        function is(value) {
          return typeof value === "string";
        }
        URI2.is = is;
      })(URI = exports3.URI || (exports3.URI = {}));
      var integer;
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
        }
        integer2.is = is;
      })(integer = exports3.integer || (exports3.integer = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
        }
        uinteger2.is = is;
      })(uinteger = exports3.uinteger || (exports3.uinteger = {}));
      var Position;
      (function(Position2) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position2.is = is;
      })(Position = exports3.Position || (exports3.Position = {}));
      var Range;
      (function(Range2) {
        function create(one, two, three, four) {
          if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
          } else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
          }
        }
        Range2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range2.is = is;
      })(Range = exports3.Range || (exports3.Range = {}));
      var Location;
      (function(Location2) {
        function create(uri, range) {
          return { uri, range };
        }
        Location2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location = exports3.Location || (exports3.Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink = exports3.LocationLink || (exports3.LocationLink = {}));
      var Color;
      (function(Color2) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color = exports3.Color || (exports3.Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation = exports3.ColorInformation || (exports3.ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation = exports3.ColorPresentation || (exports3.ColorPresentation = {}));
      var FoldingRangeKind;
      (function(FoldingRangeKind2) {
        FoldingRangeKind2.Comment = "comment";
        FoldingRangeKind2.Imports = "imports";
        FoldingRangeKind2.Region = "region";
      })(FoldingRangeKind = exports3.FoldingRangeKind || (exports3.FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          var result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange = exports3.FoldingRange || (exports3.FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation = exports3.DiagnosticRelatedInformation || (exports3.DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity;
      (function(DiagnosticSeverity2) {
        DiagnosticSeverity2.Error = 1;
        DiagnosticSeverity2.Warning = 2;
        DiagnosticSeverity2.Information = 3;
        DiagnosticSeverity2.Hint = 4;
      })(DiagnosticSeverity = exports3.DiagnosticSeverity || (exports3.DiagnosticSeverity = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag = exports3.DiagnosticTag || (exports3.DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription = exports3.CodeDescription || (exports3.CodeDescription = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create(range, message, severity, code, source, relatedInformation) {
          var result = { range, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create;
        function is(value) {
          var _a;
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic = exports3.Diagnostic || (exports3.Diagnostic = {}));
      var Command;
      (function(Command2) {
        function create(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command2.is = is;
      })(Command = exports3.Command || (exports3.Command = {}));
      var TextEdit;
      (function(TextEdit2) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit2.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit2.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
        }
        TextEdit2.is = is;
      })(TextEdit = exports3.TextEdit || (exports3.TextEdit = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation = exports3.ChangeAnnotation || (exports3.ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          var candidate = value;
          return Is.string(candidate);
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier = exports3.ChangeAnnotationIdentifier || (exports3.ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit = exports3.AnnotatedTextEdit || (exports3.AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit = exports3.TextDocumentEdit || (exports3.TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile = exports3.CreateFile || (exports3.CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile = exports3.RenameFile || (exports3.RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile = exports3.DeleteFile || (exports3.DeleteFile = {}));
      var WorkspaceEdit;
      (function(WorkspaceEdit2) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit = exports3.WorkspaceEdit || (exports3.WorkspaceEdit = {}));
      var TextEditChangeImpl = (
        /** @class */
        function() {
          function TextEditChangeImpl2(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
          }
          TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.insert(position, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.insert(position, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.replace(range, newText);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.replace(range, newText, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.replace(range, newText, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.delete = function(range, annotation) {
            var edit;
            var id;
            if (annotation === void 0) {
              edit = TextEdit.del(range);
            } else if (ChangeAnnotationIdentifier.is(annotation)) {
              id = annotation;
              edit = AnnotatedTextEdit.del(range, annotation);
            } else {
              this.assertChangeAnnotations(this.changeAnnotations);
              id = this.changeAnnotations.manage(annotation);
              edit = AnnotatedTextEdit.del(range, id);
            }
            this.edits.push(edit);
            if (id !== void 0) {
              return id;
            }
          };
          TextEditChangeImpl2.prototype.add = function(edit) {
            this.edits.push(edit);
          };
          TextEditChangeImpl2.prototype.all = function() {
            return this.edits;
          };
          TextEditChangeImpl2.prototype.clear = function() {
            this.edits.splice(0, this.edits.length);
          };
          TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
            if (value === void 0) {
              throw new Error("Text edit change is not configured to manage change annotations.");
            }
          };
          return TextEditChangeImpl2;
        }()
      );
      var ChangeAnnotations = (
        /** @class */
        function() {
          function ChangeAnnotations2(annotations) {
            this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
          }
          ChangeAnnotations2.prototype.all = function() {
            return this._annotations;
          };
          Object.defineProperty(ChangeAnnotations2.prototype, "size", {
            get: function() {
              return this._size;
            },
            enumerable: false,
            configurable: true
          });
          ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
              id = idOrAnnotation;
            } else {
              id = this.nextId();
              annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== void 0) {
              throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === void 0) {
              throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
          };
          ChangeAnnotations2.prototype.nextId = function() {
            this._counter++;
            return this._counter.toString();
          };
          return ChangeAnnotations2;
        }()
      );
      var WorkspaceChange = (
        /** @class */
        function() {
          function WorkspaceChange2(workspaceEdit) {
            var _this = this;
            this._textEditChanges = /* @__PURE__ */ Object.create(null);
            if (workspaceEdit !== void 0) {
              this._workspaceEdit = workspaceEdit;
              if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function(change) {
                  if (TextDocumentEdit.is(change)) {
                    var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                    _this._textEditChanges[change.textDocument.uri] = textEditChange;
                  }
                });
              } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function(key) {
                  var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                  _this._textEditChanges[key] = textEditChange;
                });
              }
            } else {
              this._workspaceEdit = {};
            }
          }
          Object.defineProperty(WorkspaceChange2.prototype, "edit", {
            /**
             * Returns the underlying {@link WorkspaceEdit} literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function() {
              this.initDocumentChanges();
              if (this._changeAnnotations !== void 0) {
                if (this._changeAnnotations.size === 0) {
                  this._workspaceEdit.changeAnnotations = void 0;
                } else {
                  this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
              }
              return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
          });
          WorkspaceChange2.prototype.getTextEditChange = function(key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
              this.initDocumentChanges();
              if (this._workspaceEdit.documentChanges === void 0) {
                throw new Error("Workspace edit is not configured for document changes.");
              }
              var textDocument = { uri: key.uri, version: key.version };
              var result = this._textEditChanges[textDocument.uri];
              if (!result) {
                var edits = [];
                var textDocumentEdit = {
                  textDocument,
                  edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
              }
              return result;
            } else {
              this.initChanges();
              if (this._workspaceEdit.changes === void 0) {
                throw new Error("Workspace edit is not configured for normal text edit changes.");
              }
              var result = this._textEditChanges[key];
              if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
              }
              return result;
            }
          };
          WorkspaceChange2.prototype.initDocumentChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._changeAnnotations = new ChangeAnnotations();
              this._workspaceEdit.documentChanges = [];
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          };
          WorkspaceChange2.prototype.initChanges = function() {
            if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
              this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
            }
          };
          WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = CreateFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = RenameFile.create(oldUri, newUri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
              annotation = optionsOrAnnotation;
            } else {
              options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === void 0) {
              operation = DeleteFile.create(uri, options);
            } else {
              id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
              operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== void 0) {
              return id;
            }
          };
          return WorkspaceChange2;
        }()
      );
      exports3.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier = exports3.TextDocumentIdentifier || (exports3.TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier || (exports3.VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier = exports3.OptionalVersionedTextDocumentIdentifier || (exports3.OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create(uri, languageId, version, text) {
          return { uri, languageId, version, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem = exports3.TextDocumentItem || (exports3.TextDocumentItem = {}));
      var MarkupKind;
      (function(MarkupKind2) {
        MarkupKind2.PlainText = "plaintext";
        MarkupKind2.Markdown = "markdown";
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
        }
        MarkupKind2.is = is;
      })(MarkupKind = exports3.MarkupKind || (exports3.MarkupKind = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent = exports3.MarkupContent || (exports3.MarkupContent = {}));
      var CompletionItemKind;
      (function(CompletionItemKind2) {
        CompletionItemKind2.Text = 1;
        CompletionItemKind2.Method = 2;
        CompletionItemKind2.Function = 3;
        CompletionItemKind2.Constructor = 4;
        CompletionItemKind2.Field = 5;
        CompletionItemKind2.Variable = 6;
        CompletionItemKind2.Class = 7;
        CompletionItemKind2.Interface = 8;
        CompletionItemKind2.Module = 9;
        CompletionItemKind2.Property = 10;
        CompletionItemKind2.Unit = 11;
        CompletionItemKind2.Value = 12;
        CompletionItemKind2.Enum = 13;
        CompletionItemKind2.Keyword = 14;
        CompletionItemKind2.Snippet = 15;
        CompletionItemKind2.Color = 16;
        CompletionItemKind2.File = 17;
        CompletionItemKind2.Reference = 18;
        CompletionItemKind2.Folder = 19;
        CompletionItemKind2.EnumMember = 20;
        CompletionItemKind2.Constant = 21;
        CompletionItemKind2.Struct = 22;
        CompletionItemKind2.Event = 23;
        CompletionItemKind2.Operator = 24;
        CompletionItemKind2.TypeParameter = 25;
      })(CompletionItemKind = exports3.CompletionItemKind || (exports3.CompletionItemKind = {}));
      var InsertTextFormat;
      (function(InsertTextFormat2) {
        InsertTextFormat2.PlainText = 1;
        InsertTextFormat2.Snippet = 2;
      })(InsertTextFormat = exports3.InsertTextFormat || (exports3.InsertTextFormat = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag = exports3.CompletionItemTag || (exports3.CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit = exports3.InsertReplaceEdit || (exports3.InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode = exports3.InsertTextMode || (exports3.InsertTextMode = {}));
      var CompletionItemLabelDetails;
      (function(CompletionItemLabelDetails2) {
        function is(value) {
          var candidate = value;
          return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails2.is = is;
      })(CompletionItemLabelDetails = exports3.CompletionItemLabelDetails || (exports3.CompletionItemLabelDetails = {}));
      var CompletionItem;
      (function(CompletionItem2) {
        function create(label) {
          return { label };
        }
        CompletionItem2.create = create;
      })(CompletionItem = exports3.CompletionItem || (exports3.CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList = exports3.CompletionList || (exports3.CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString = exports3.MarkedString || (exports3.MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
        }
        Hover2.is = is;
      })(Hover = exports3.Hover || (exports3.Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
      })(ParameterInformation = exports3.ParameterInformation || (exports3.ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation = exports3.SignatureInformation || (exports3.SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind = exports3.DocumentHighlightKind || (exports3.DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create(range, kind) {
          var result = { range };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight = exports3.DocumentHighlight || (exports3.DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind = exports3.SymbolKind || (exports3.SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag = exports3.SymbolTag || (exports3.SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create(name, kind, range, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation = exports3.SymbolInformation || (exports3.SymbolInformation = {}));
      var WorkspaceSymbol;
      (function(WorkspaceSymbol2) {
        function create(name, kind, uri, range) {
          return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
        }
        WorkspaceSymbol2.create = create;
      })(WorkspaceSymbol = exports3.WorkspaceSymbol || (exports3.WorkspaceSymbol = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create(name, detail, kind, range, selectionRange, children) {
          var result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol = exports3.DocumentSymbol || (exports3.DocumentSymbol = {}));
      var CodeActionKind;
      (function(CodeActionKind2) {
        CodeActionKind2.Empty = "";
        CodeActionKind2.QuickFix = "quickfix";
        CodeActionKind2.Refactor = "refactor";
        CodeActionKind2.RefactorExtract = "refactor.extract";
        CodeActionKind2.RefactorInline = "refactor.inline";
        CodeActionKind2.RefactorRewrite = "refactor.rewrite";
        CodeActionKind2.Source = "source";
        CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind2.SourceFixAll = "source.fixAll";
      })(CodeActionKind = exports3.CodeActionKind || (exports3.CodeActionKind = {}));
      var CodeActionTriggerKind;
      (function(CodeActionTriggerKind2) {
        CodeActionTriggerKind2.Invoked = 1;
        CodeActionTriggerKind2.Automatic = 2;
      })(CodeActionTriggerKind = exports3.CodeActionTriggerKind || (exports3.CodeActionTriggerKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create(diagnostics, only, triggerKind) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext2.is = is;
      })(CodeActionContext = exports3.CodeActionContext || (exports3.CodeActionContext = {}));
      var CodeAction;
      (function(CodeAction2) {
        function create(title, kindOrCommandOrEdit, kind) {
          var result = { title };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction2.is = is;
      })(CodeAction = exports3.CodeAction || (exports3.CodeAction = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create(range, data) {
          var result = { range };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens = exports3.CodeLens || (exports3.CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions = exports3.FormattingOptions || (exports3.FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink = exports3.DocumentLink || (exports3.DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange = exports3.SelectionRange || (exports3.SelectionRange = {}));
      var SemanticTokenTypes;
      (function(SemanticTokenTypes2) {
        SemanticTokenTypes2["namespace"] = "namespace";
        SemanticTokenTypes2["type"] = "type";
        SemanticTokenTypes2["class"] = "class";
        SemanticTokenTypes2["enum"] = "enum";
        SemanticTokenTypes2["interface"] = "interface";
        SemanticTokenTypes2["struct"] = "struct";
        SemanticTokenTypes2["typeParameter"] = "typeParameter";
        SemanticTokenTypes2["parameter"] = "parameter";
        SemanticTokenTypes2["variable"] = "variable";
        SemanticTokenTypes2["property"] = "property";
        SemanticTokenTypes2["enumMember"] = "enumMember";
        SemanticTokenTypes2["event"] = "event";
        SemanticTokenTypes2["function"] = "function";
        SemanticTokenTypes2["method"] = "method";
        SemanticTokenTypes2["macro"] = "macro";
        SemanticTokenTypes2["keyword"] = "keyword";
        SemanticTokenTypes2["modifier"] = "modifier";
        SemanticTokenTypes2["comment"] = "comment";
        SemanticTokenTypes2["string"] = "string";
        SemanticTokenTypes2["number"] = "number";
        SemanticTokenTypes2["regexp"] = "regexp";
        SemanticTokenTypes2["operator"] = "operator";
        SemanticTokenTypes2["decorator"] = "decorator";
      })(SemanticTokenTypes = exports3.SemanticTokenTypes || (exports3.SemanticTokenTypes = {}));
      var SemanticTokenModifiers;
      (function(SemanticTokenModifiers2) {
        SemanticTokenModifiers2["declaration"] = "declaration";
        SemanticTokenModifiers2["definition"] = "definition";
        SemanticTokenModifiers2["readonly"] = "readonly";
        SemanticTokenModifiers2["static"] = "static";
        SemanticTokenModifiers2["deprecated"] = "deprecated";
        SemanticTokenModifiers2["abstract"] = "abstract";
        SemanticTokenModifiers2["async"] = "async";
        SemanticTokenModifiers2["modification"] = "modification";
        SemanticTokenModifiers2["documentation"] = "documentation";
        SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers = exports3.SemanticTokenModifiers || (exports3.SemanticTokenModifiers = {}));
      var SemanticTokens;
      (function(SemanticTokens2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens2.is = is;
      })(SemanticTokens = exports3.SemanticTokens || (exports3.SemanticTokens = {}));
      var InlineValueText;
      (function(InlineValueText2) {
        function create(range, text) {
          return { range, text };
        }
        InlineValueText2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText2.is = is;
      })(InlineValueText = exports3.InlineValueText || (exports3.InlineValueText = {}));
      var InlineValueVariableLookup;
      (function(InlineValueVariableLookup2) {
        function create(range, variableName, caseSensitiveLookup) {
          return { range, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup2.is = is;
      })(InlineValueVariableLookup = exports3.InlineValueVariableLookup || (exports3.InlineValueVariableLookup = {}));
      var InlineValueEvaluatableExpression;
      (function(InlineValueEvaluatableExpression2) {
        function create(range, expression) {
          return { range, expression };
        }
        InlineValueEvaluatableExpression2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression2.is = is;
      })(InlineValueEvaluatableExpression = exports3.InlineValueEvaluatableExpression || (exports3.InlineValueEvaluatableExpression = {}));
      var InlineValueContext;
      (function(InlineValueContext2) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(value.stoppedLocation);
        }
        InlineValueContext2.is = is;
      })(InlineValueContext = exports3.InlineValueContext || (exports3.InlineValueContext = {}));
      var InlayHintKind;
      (function(InlayHintKind2) {
        InlayHintKind2.Type = 1;
        InlayHintKind2.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind2.is = is;
      })(InlayHintKind = exports3.InlayHintKind || (exports3.InlayHintKind = {}));
      var InlayHintLabelPart;
      (function(InlayHintLabelPart2) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
        }
        InlayHintLabelPart2.is = is;
      })(InlayHintLabelPart = exports3.InlayHintLabelPart || (exports3.InlayHintLabelPart = {}));
      var InlayHint;
      (function(InlayHint2) {
        function create(position, label, kind) {
          var result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
        }
        InlayHint2.is = is;
      })(InlayHint = exports3.InlayHint || (exports3.InlayHint = {}));
      var WorkspaceFolder;
      (function(WorkspaceFolder2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder2.is = is;
      })(WorkspaceFolder = exports3.WorkspaceFolder || (exports3.WorkspaceFolder = {}));
      exports3.EOL = ["\n", "\r\n", "\r"];
      var TextDocument;
      (function(TextDocument2) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument2.is = is;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument2.applyEdits = applyEdits;
        function mergeSort(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort(left, compare);
          mergeSort(right, compare);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument = exports3.TextDocument || (exports3.TextDocument = {}));
      var FullTextDocument = (
        /** @class */
        function() {
          function FullTextDocument2(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument2.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument2.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument2.prototype.update = function(event, version) {
            this._content = event.text;
            this._version = version;
            this._lineOffsets = void 0;
          };
          FullTextDocument2.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              var lineOffsets = [];
              var text = this._content;
              var isLineStart = true;
              for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                  lineOffsets.push(i);
                  isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = ch === "\r" || ch === "\n";
                if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                  i++;
                }
              }
              if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
              }
              this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
          };
          FullTextDocument2.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return Position.create(0, offset);
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return Position.create(line, offset - lineOffsets[line]);
          };
          FullTextDocument2.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          return FullTextDocument2;
        }()
      );
      var Is;
      (function(Is2) {
        var toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is2.boolean = boolean;
        function string(value) {
          return toString.call(value) === "[object String]";
        }
        Is2.string = string;
        function number(value) {
          return toString.call(value) === "[object Number]";
        }
        Is2.number = number;
        function numberRange(value, min, max) {
          return toString.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is2.numberRange = numberRange;
        function integer2(value) {
          return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is2.integer = integer2;
        function uinteger2(value) {
          return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is2.uinteger = uinteger2;
        function func(value) {
          return toString.call(value) === "[object Function]";
        }
        Is2.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is2.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    });
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = exports2.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection = exports2.MessageDirection || (exports2.MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest = exports2.ImplementationRequest || (exports2.ImplementationRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest = exports2.TypeDefinitionRequest || (exports2.TypeDefinitionRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
    })(WorkspaceFoldersRequest = exports2.WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
    })(DidChangeWorkspaceFoldersNotification = exports2.DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.method = "workspace/configuration";
      ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
    })(ConfigurationRequest = exports2.ConfigurationRequest || (exports2.ConfigurationRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest = exports2.DocumentColorRequest || (exports2.DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.method = "textDocument/colorPresentation";
      ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
    })(ColorPresentationRequest = exports2.ColorPresentationRequest || (exports2.ColorPresentationRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest = exports2.FoldingRangeRequest || (exports2.FoldingRangeRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest = exports2.DeclarationRequest || (exports2.DeclarationRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest = exports2.SelectionRangeRequest || (exports2.SelectionRangeRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress = exports2.WorkDoneProgress || (exports2.WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest = exports2.WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest = exports2.CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest = exports2.CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat = exports2.TokenFormat || (exports2.TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType = exports2.SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRequest = exports2.SemanticTokensRequest || (exports2.SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensDeltaRequest = exports2.SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRangeRequest = exports2.SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest = exports2.SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest = exports2.ShowDocumentRequest || (exports2.ShowDocumentRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest = exports2.LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind = exports2.FileOperationPatternKind || (exports2.FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest = exports2.WillCreateFilesRequest || (exports2.WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification = exports2.DidCreateFilesNotification || (exports2.DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest = exports2.WillRenameFilesRequest || (exports2.WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification = exports2.DidRenameFilesNotification || (exports2.DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification = exports2.DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest = exports2.WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel = exports2.UniquenessLevel || (exports2.UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind = exports2.MonikerKind || (exports2.MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest = exports2.MonikerRequest || (exports2.MonikerRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest = exports2.TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest = exports2.TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest = exports2.TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest;
    (function(InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest = exports2.InlineValueRequest || (exports2.InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function(InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest = exports2.InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest;
    (function(InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest = exports2.InlayHintRequest || (exports2.InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function(InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest = exports2.InlayHintResolveRequest || (exports2.InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function(InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest = exports2.InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData = exports2.DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind;
    (function(DocumentDiagnosticReportKind2) {
      DocumentDiagnosticReportKind2.Full = "full";
      DocumentDiagnosticReportKind2.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind = exports2.DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest = exports2.DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest = exports2.WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest = exports2.DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind = exports2.NotebookCellKind || (exports2.NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary = exports2.ExecutionSummary || (exports2.ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document) {
        return { kind, document };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell = exports2.NotebookCell || (exports2.NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument = exports2.NotebookDocument || (exports2.NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType = exports2.NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification = exports2.DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange = exports2.NotebookCellArrayChange || (exports2.NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification = exports2.DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter = exports2.TextDocumentFilter || (exports2.TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter = exports2.NotebookDocumentFilter || (exports2.NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter = exports2.NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector = exports2.DocumentSelector || (exports2.DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.method = "client/registerCapability";
      RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
    })(RegistrationRequest = exports2.RegistrationRequest || (exports2.RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.method = "client/unregisterCapability";
      UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
    })(UnregistrationRequest = exports2.UnregistrationRequest || (exports2.UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind = exports2.ResourceOperationKind || (exports2.ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind = exports2.FailureHandlingKind || (exports2.FailureHandlingKind = {}));
    var PositionEncodingKind;
    (function(PositionEncodingKind2) {
      PositionEncodingKind2.UTF8 = "utf-8";
      PositionEncodingKind2.UTF16 = "utf-16";
      PositionEncodingKind2.UTF32 = "utf-32";
    })(PositionEncodingKind = exports2.PositionEncodingKind || (exports2.PositionEncodingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions = exports2.StaticRegistrationOptions || (exports2.StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions = exports2.TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions = exports2.WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.method = "initialize";
      InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
    })(InitializeRequest = exports2.InitializeRequest || (exports2.InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes = exports2.InitializeErrorCodes || (exports2.InitializeErrorCodes = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.method = "initialized";
      InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
    })(InitializedNotification = exports2.InitializedNotification || (exports2.InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.method = "shutdown";
      ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
    })(ShutdownRequest = exports2.ShutdownRequest || (exports2.ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.method = "exit";
      ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
    })(ExitNotification = exports2.ExitNotification || (exports2.ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
    })(DidChangeConfigurationNotification = exports2.DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
    })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.method = "window/showMessage";
      ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
    })(ShowMessageNotification = exports2.ShowMessageNotification || (exports2.ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.method = "window/showMessageRequest";
      ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
    })(ShowMessageRequest = exports2.ShowMessageRequest || (exports2.ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.method = "window/logMessage";
      LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
    })(LogMessageNotification = exports2.LogMessageNotification || (exports2.LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification = exports2.TelemetryEventNotification || (exports2.TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind = exports2.TextDocumentSyncKind || (exports2.TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification = exports2.DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent = exports2.TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification = exports2.DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification = exports2.DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification = exports2.DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason = exports2.TextDocumentSaveReason || (exports2.TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification = exports2.WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
    })(DidChangeWatchedFilesNotification = exports2.DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType = exports2.FileChangeType || (exports2.FileChangeType = {}));
    var RelativePattern;
    (function(RelativePattern2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
      }
      RelativePattern2.is = is;
    })(RelativePattern = exports2.RelativePattern || (exports2.RelativePattern = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind = exports2.WatchKind || (exports2.WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
    })(PublishDiagnosticsNotification = exports2.PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind = exports2.CompletionTriggerKind || (exports2.CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest = exports2.CompletionRequest || (exports2.CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest = exports2.CompletionResolveRequest || (exports2.CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest = exports2.HoverRequest || (exports2.HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind = exports2.SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest = exports2.SignatureHelpRequest || (exports2.SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest = exports2.DefinitionRequest || (exports2.DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest = exports2.ReferencesRequest || (exports2.ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest = exports2.DocumentHighlightRequest || (exports2.DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest = exports2.DocumentSymbolRequest || (exports2.DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest = exports2.CodeActionRequest || (exports2.CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest = exports2.CodeActionResolveRequest || (exports2.CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest = exports2.WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function(WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest = exports2.WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest = exports2.CodeLensRequest || (exports2.CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest = exports2.CodeLensResolveRequest || (exports2.CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest = exports2.CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest = exports2.DocumentLinkRequest || (exports2.DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest = exports2.DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest = exports2.DocumentFormattingRequest || (exports2.DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest = exports2.DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest = exports2.DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior = exports2.PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest = exports2.RenameRequest || (exports2.RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest = exports2.PrepareRenameRequest || (exports2.PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.method = "workspace/executeCommand";
      ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
    })(ExecuteCommandRequest = exports2.ExecuteCommandRequest || (exports2.ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest = exports2.ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar(require_main(), exports2);
    __exportStar(require_main2(), exports2);
    __exportStar(require_messages2(), exports2);
    __exportStar(require_protocol(), exports2);
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes = exports2.LSPErrorCodes || (exports2.LSPErrorCodes = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var node_12 = require_node();
    __exportStar(require_node(), exports2);
    __exportStar(require_api2(), exports2);
    function createProtocolConnection(input, output, logger, options) {
      return (0, node_12.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class _V4UUID extends ValueUUID {
      constructor() {
        super([
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          "4",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._oneOf(_V4UUID._timeHighBits),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          "-",
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex(),
          _V4UUID._randomHex()
        ].join(""));
      }
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return _V4UUID._oneOf(_V4UUID._chars);
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports2.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports2.isUUID = isUUID;
    function parse(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports2.parse = parse;
    function generateUuid() {
      return v4().asHex();
    }
    exports2.generateUuid = generateUuid;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/progress.js
var require_progress = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attachPartialResult = exports2.ProgressFeature = exports2.attachWorkDone = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var uuid_1 = require_uuid();
    var WorkDoneProgressReporterImpl = class _WorkDoneProgressReporterImpl {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        _WorkDoneProgressReporterImpl.Instances.set(this._token, this);
      }
      begin(title, percentage, message, cancellable) {
        let param = {
          kind: "begin",
          title,
          percentage,
          message,
          cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      report(arg0, arg1) {
        let param = {
          kind: "report"
        };
        if (typeof arg0 === "number") {
          param.percentage = arg0;
          if (arg1 !== void 0) {
            param.message = arg1;
          }
        } else {
          param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      done() {
        _WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
      }
    };
    WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
    var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
      constructor(connection2, token) {
        super(connection2, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
        super.done();
      }
      cancel() {
        this._source.cancel();
      }
    };
    var NullProgressReporter = class {
      constructor() {
      }
      begin() {
      }
      report() {
      }
      done() {
      }
    };
    var NullProgressServerReporter = class extends NullProgressReporter {
      constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
      }
      cancel() {
        this._source.cancel();
      }
    };
    function attachWorkDone(connection2, params) {
      if (params === void 0 || params.workDoneToken === void 0) {
        return new NullProgressReporter();
      }
      const token = params.workDoneToken;
      delete params.workDoneToken;
      return new WorkDoneProgressReporterImpl(connection2, token);
    }
    exports2.attachWorkDone = attachWorkDone;
    var ProgressFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._progressSupported = false;
        }
        initialize(capabilities) {
          var _a;
          super.initialize(capabilities);
          if (((_a = capabilities == null ? void 0 : capabilities.window) == null ? void 0 : _a.workDoneProgress) === true) {
            this._progressSupported = true;
            this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
              let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
              if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                progress.cancel();
              }
            });
          }
        }
        attachWorkDoneProgress(token) {
          if (token === void 0) {
            return new NullProgressReporter();
          } else {
            return new WorkDoneProgressReporterImpl(this.connection, token);
          }
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            const token = (0, uuid_1.generateUuid)();
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
              const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
              return result;
            });
          } else {
            return Promise.resolve(new NullProgressServerReporter());
          }
        }
      };
    };
    exports2.ProgressFeature = ProgressFeature;
    var ResultProgress;
    (function(ResultProgress2) {
      ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
    })(ResultProgress || (ResultProgress = {}));
    var ResultProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
      }
      report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
      }
    };
    function attachPartialResult(connection2, params) {
      if (params === void 0 || params.partialResultToken === void 0) {
        return void 0;
      }
      const token = params.partialResultToken;
      delete params.partialResultToken;
      return new ResultProgressReporterImpl(connection2, token);
    }
    exports2.attachPartialResult = attachPartialResult;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/configuration.js
var require_configuration = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
            if (Array.isArray(result)) {
              return Array.isArray(arg) ? result : result[0];
            } else {
              return Array.isArray(arg) ? [] : null;
            }
          });
        }
      };
    };
    exports2.ConfigurationFeature = ConfigurationFeature;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/workspaceFolder.js
var require_workspaceFolder = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceFoldersFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._notificationIsAutoRegistered = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        fillServerCapabilities(capabilities) {
          var _a, _b;
          super.fillServerCapabilities(capabilities);
          const changeNotifications = (_b = (_a = capabilities.workspace) == null ? void 0 : _a.workspaceFolders) == null ? void 0 : _b.changeNotifications;
          this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._notificationIsAutoRegistered && !this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
    exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var CallHierarchyFeature = (Base) => {
      return class extends Base {
        get callHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onIncomingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onOutgoingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensBuilder = exports2.SemanticTokensDiff = exports2.SemanticTokensFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var SemanticTokensFeature = (Base) => {
      return class extends Base {
        get semanticTokens() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onDelta: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onRange: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.SemanticTokensFeature = SemanticTokensFeature;
    var SemanticTokensDiff = class {
      constructor(originalSequence, modifiedSequence) {
        this.originalSequence = originalSequence;
        this.modifiedSequence = modifiedSequence;
      }
      computeDiff() {
        const originalLength = this.originalSequence.length;
        const modifiedLength = this.modifiedSequence.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
          startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
          let originalEndIndex = originalLength - 1;
          let modifiedEndIndex = modifiedLength - 1;
          while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
            originalEndIndex--;
            modifiedEndIndex--;
          }
          if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
            originalEndIndex++;
            modifiedEndIndex++;
          }
          const deleteCount = originalEndIndex - startIndex + 1;
          const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
          if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
            return [
              { start: startIndex, deleteCount: deleteCount - 1 }
            ];
          } else {
            return [
              { start: startIndex, deleteCount, data: newData }
            ];
          }
        } else if (startIndex < modifiedLength) {
          return [
            { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
          ];
        } else if (startIndex < originalLength) {
          return [
            { start: startIndex, deleteCount: originalLength - startIndex }
          ];
        } else {
          return [];
        }
      }
    };
    exports2.SemanticTokensDiff = SemanticTokensDiff;
    var SemanticTokensBuilder = class {
      constructor() {
        this._prevData = void 0;
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      get id() {
        return this._id.toString();
      }
      previousResult(id) {
        if (this.id === id) {
          this._prevData = this._data;
        }
        this.initialize();
      }
      build() {
        this._prevData = void 0;
        return {
          resultId: this.id,
          data: this._data
        };
      }
      canBuildEdits() {
        return this._prevData !== void 0;
      }
      buildEdits() {
        if (this._prevData !== void 0) {
          return {
            resultId: this.id,
            edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
          };
        } else {
          return this.build();
        }
      }
    };
    exports2.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/showDocument.js
var require_showDocument = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var ShowDocumentFeature = (Base) => {
      return class extends Base {
        showDocument(params) {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
      };
    };
    exports2.ShowDocumentFeature = ShowDocumentFeature;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileOperationsFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FileOperationsFeature = (Base) => {
      return class extends Base {
        onDidCreateFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidRenameFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidDeleteFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onWillCreateFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillRenameFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillDeleteFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
      };
    };
    exports2.FileOperationsFeature = FileOperationsFeature;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var LinkedEditingRangeFeature = (Base) => {
      return class extends Base {
        onLinkedEditingRange(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
          });
        }
      };
    };
    exports2.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/typeHierarchy.js
var require_typeHierarchy = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TypeHierarchyFeature = (Base) => {
      return class extends Base {
        get typeHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onSupertypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onSubtypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.TypeHierarchyFeature = TypeHierarchyFeature;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/inlineValue.js
var require_inlineValue = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineValueFeature = (Base) => {
      return class extends Base {
        get inlineValue() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineValueFeature = InlineValueFeature;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/inlayHint.js
var require_inlayHint = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlayHintFeature = (Base) => {
      return class extends Base {
        get inlayHint() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            },
            resolve: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                return handler(params, cancel);
              });
            }
          };
        }
      };
    };
    exports2.InlayHintFeature = InlayHintFeature;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/diagnostic.js
var require_diagnostic = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var DiagnosticFeature = (Base) => {
      return class extends Base {
        get diagnostics() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
              });
            },
            onWorkspace: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
              });
            }
          };
        }
      };
    };
    exports2.DiagnosticFeature = DiagnosticFeature;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/textDocuments.js
var require_textDocuments = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextDocuments = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TextDocuments = class {
      /**
       * Create a new text document manager.
       */
      constructor(configuration) {
        this._configuration = configuration;
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened.
       */
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been opened or the content changes.
       */
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * will be saved.
       */
      get onWillSave() {
        return this._onWillSave.event;
      }
      /**
       * Sets a handler that will be called if a participant wants to provide
       * edits during a text document save.
       */
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been saved.
       */
      get onDidSave() {
        return this._onDidSave.event;
      }
      /**
       * An event that fires when a text document managed by this manager
       * has been closed.
       */
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Returns the document for the given URI. Returns undefined if
       * the document is not managed by this instance.
       *
       * @param uri The text document's URI to retrieve.
       * @return the text document or `undefined`.
       */
      get(uri) {
        return this._syncedDocuments.get(uri);
      }
      /**
       * Returns all text documents managed by this instance.
       *
       * @return all text documents.
       */
      all() {
        return Array.from(this._syncedDocuments.values());
      }
      /**
       * Returns the URIs of all text documents managed by this instance.
       *
       * @return the URI's of all text documents.
       */
      keys() {
        return Array.from(this._syncedDocuments.keys());
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the text documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
       * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
       *
       * Use the corresponding events on the TextDocuments instance instead.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        connection2.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
        const disposables = [];
        disposables.push(connection2.onDidOpenTextDocument((event) => {
          const td = event.textDocument;
          const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
          this._syncedDocuments.set(td.uri, document);
          const toFire = Object.freeze({ document });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        }));
        disposables.push(connection2.onDidChangeTextDocument((event) => {
          const td = event.textDocument;
          const changes = event.contentChanges;
          if (changes.length === 0) {
            return;
          }
          const { version } = td;
          if (version === null || version === void 0) {
            throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
          }
          let syncedDocument = this._syncedDocuments.get(td.uri);
          if (syncedDocument !== void 0) {
            syncedDocument = this._configuration.update(syncedDocument, changes, version);
            this._syncedDocuments.set(td.uri, syncedDocument);
            this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onDidCloseTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._syncedDocuments.delete(event.textDocument.uri);
            this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
          }
        }));
        disposables.push(connection2.onWillSaveTextDocumentWaitUntil((event, token) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
          } else {
            return [];
          }
        }));
        disposables.push(connection2.onDidSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
    };
    exports2.TextDocuments = TextDocuments;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/notebook.js
var require_notebook = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotebookDocuments = exports2.NotebookSyncFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var textDocuments_1 = require_textDocuments();
    var NotebookSyncFeature = (Base) => {
      return class extends Base {
        get synchronization() {
          return {
            onDidOpenNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidChangeNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidSaveNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidCloseNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            }
          };
        }
      };
    };
    exports2.NotebookSyncFeature = NotebookSyncFeature;
    var CellTextDocumentConnection = class _CellTextDocumentConnection {
      onDidOpenTextDocument(handler) {
        this.openHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.openHandler = void 0;
        });
      }
      openTextDocument(params) {
        this.openHandler && this.openHandler(params);
      }
      onDidChangeTextDocument(handler) {
        this.changeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.changeHandler = handler;
        });
      }
      changeTextDocument(params) {
        this.changeHandler && this.changeHandler(params);
      }
      onDidCloseTextDocument(handler) {
        this.closeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.closeHandler = void 0;
        });
      }
      closeTextDocument(params) {
        this.closeHandler && this.closeHandler(params);
      }
      onWillSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onWillSaveTextDocumentWaitUntil() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
      onDidSaveTextDocument() {
        return _CellTextDocumentConnection.NULL_DISPOSE;
      }
    };
    CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
    } });
    var NotebookDocuments = class {
      constructor(configurationOrTextDocuments) {
        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
          this._cellTextDocuments = configurationOrTextDocuments;
        } else {
          this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
        }
        this.notebookDocuments = /* @__PURE__ */ new Map();
        this.notebookCellMap = /* @__PURE__ */ new Map();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
      }
      get cellTextDocuments() {
        return this._cellTextDocuments;
      }
      getCellTextDocument(cell) {
        return this._cellTextDocuments.get(cell.document);
      }
      getNotebookDocument(uri) {
        return this.notebookDocuments.get(uri);
      }
      getNotebookCell(uri) {
        const value = this.notebookCellMap.get(uri);
        return value && value[0];
      }
      findNotebookDocumentForCell(cell) {
        const key = typeof cell === "string" ? cell : cell.document;
        const value = this.notebookCellMap.get(key);
        return value && value[1];
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidChange() {
        return this._onDidChange.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      /**
       * Listens for `low level` notification on the given connection to
       * update the notebook documents managed by this instance.
       *
       * Please note that the connection only provides handlers not an event model. Therefore
       * listening on a connection will overwrite the following handlers on a connection:
       * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,
       *  and `onDidCloseNotebookDocument`.
       *
       * @param connection The connection to listen on.
       */
      listen(connection2) {
        const cellTextDocumentConnection = new CellTextDocumentConnection();
        const disposables = [];
        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
        disposables.push(connection2.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
          this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
          }
          this.updateCellMap(params.notebookDocument);
          this._onDidOpen.fire(params.notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          notebookDocument.version = params.notebookDocument.version;
          const oldMetadata = notebookDocument.metadata;
          let metadataChanged = false;
          const change = params.change;
          if (change.metadata !== void 0) {
            metadataChanged = true;
            notebookDocument.metadata = change.metadata;
          }
          const opened = [];
          const closed = [];
          const data = [];
          const text = [];
          if (change.cells !== void 0) {
            const changedCells = change.cells;
            if (changedCells.structure !== void 0) {
              const array = changedCells.structure.array;
              notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== void 0 ? array.cells : []);
              if (changedCells.structure.didOpen !== void 0) {
                for (const open of changedCells.structure.didOpen) {
                  cellTextDocumentConnection.openTextDocument({ textDocument: open });
                  opened.push(open.uri);
                }
              }
              if (changedCells.structure.didClose) {
                for (const close of changedCells.structure.didClose) {
                  cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                  closed.push(close.uri);
                }
              }
            }
            if (changedCells.data !== void 0) {
              const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
              for (let i = 0; i <= notebookDocument.cells.length; i++) {
                const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                if (change2 !== void 0) {
                  const old = notebookDocument.cells.splice(i, 1, change2);
                  data.push({ old: old[0], new: change2 });
                  cellUpdates.delete(change2.document);
                  if (cellUpdates.size === 0) {
                    break;
                  }
                }
              }
            }
            if (changedCells.textContent !== void 0) {
              for (const cellTextDocument of changedCells.textContent) {
                cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                text.push(cellTextDocument.document.uri);
              }
            }
          }
          this.updateCellMap(notebookDocument);
          const changeEvent = { notebookDocument };
          if (metadataChanged) {
            changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
          }
          const added = [];
          for (const open of opened) {
            added.push(this.getNotebookCell(open));
          }
          const removed = [];
          for (const close of closed) {
            removed.push(this.getNotebookCell(close));
          }
          const textContent = [];
          for (const change2 of text) {
            textContent.push(this.getNotebookCell(change2));
          }
          if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
            changeEvent.cells = { added, removed, changed: { data, textContent } };
          }
          if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
            this._onDidChange.fire(changeEvent);
          }
        }));
        disposables.push(connection2.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidSave.fire(notebookDocument);
        }));
        disposables.push(connection2.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidClose.fire(notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
          }
          this.notebookDocuments.delete(params.notebookDocument.uri);
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.delete(cell.document);
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
      updateCellMap(notebookDocument) {
        for (const cell of notebookDocument.cells) {
          this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
        }
      }
    };
    exports2.NotebookDocuments = NotebookDocuments;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/moniker.js
var require_moniker = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var MonikerFeature = (Base) => {
      return class extends Base {
        get moniker() {
          return {
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.MonikerRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.MonikerFeature = MonikerFeature;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/server.js
var require_server = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.combineFeatures = exports2.combineNotebooksFeatures = exports2.combineLanguagesFeatures = exports2.combineWorkspaceFeatures = exports2.combineWindowFeatures = exports2.combineClientFeatures = exports2.combineTracerFeatures = exports2.combineTelemetryFeatures = exports2.combineConsoleFeatures = exports2._NotebooksImpl = exports2._LanguagesImpl = exports2.BulkUnregistration = exports2.BulkRegistration = exports2.ErrorMessageTracker = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var UUID = require_uuid();
    var progress_1 = require_progress();
    var configuration_1 = require_configuration();
    var workspaceFolder_1 = require_workspaceFolder();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var showDocument_1 = require_showDocument();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var typeHierarchy_1 = require_typeHierarchy();
    var inlineValue_1 = require_inlineValue();
    var inlayHint_1 = require_inlayHint();
    var diagnostic_1 = require_diagnostic();
    var notebook_1 = require_notebook();
    var moniker_1 = require_moniker();
    function null2Undefined(value) {
      if (value === null) {
        return void 0;
      }
      return value;
    }
    var ErrorMessageTracker = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Add a message to the tracker.
       *
       * @param message The message to add.
       */
      add(message) {
        let count = this._messages[message];
        if (!count) {
          count = 0;
        }
        count++;
        this._messages[message] = count;
      }
      /**
       * Send all tracked messages to the connection's window.
       *
       * @param connection The connection established between client and server.
       */
      sendErrors(connection2) {
        Object.keys(this._messages).forEach((message) => {
          connection2.window.showErrorMessage(message);
        });
      }
    };
    exports2.ErrorMessageTracker = ErrorMessageTracker;
    var RemoteConsoleImpl = class {
      constructor() {
      }
      rawAttach(connection2) {
        this._rawConnection = connection2;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
      }
      warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
      }
      info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
      }
      log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
      }
      send(type, message) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
            (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
          });
        }
      }
    };
    var _RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
    };
    var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
    var BulkRegistration;
    (function(BulkRegistration2) {
      function create() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create;
    })(BulkRegistration = exports2.BulkRegistration || (exports2.BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function(BulkUnregistration2) {
      function create() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create;
    })(BulkUnregistration = exports2.BulkUnregistration || (exports2.BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var RemoteClientImpl = class {
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method).catch(() => {
              this.connection.console.info(`Un-registering capability with id ${id} failed.`);
            });
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var _RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
          return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value) {
        this._trace = value;
      }
      log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        }).catch(() => {
        });
      }
    };
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
          this.connection.console.log(`Sending TelemetryEventNotification failed`);
        });
      }
    };
    var _LanguagesImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._LanguagesImpl = _LanguagesImpl;
    var LanguagesImpl = (0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl))))))));
    var _NotebooksImpl = class {
      constructor() {
      }
      attach(connection2) {
        this._connection = connection2;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._NotebooksImpl = _NotebooksImpl;
    var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
    function combineConsoleFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineLanguagesFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineLanguagesFeatures = combineLanguagesFeatures;
    function combineNotebooksFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineNotebooksFeatures = combineNotebooksFeatures;
    function combineFeatures(one, two) {
      function combine(one2, two2, func) {
        if (one2 && two2) {
          return func(one2, two2);
        } else if (one2) {
          return one2;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
        languages: combine(one.languages, two.languages, combineLanguagesFeatures),
        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
      };
      return result;
    }
    exports2.combineFeatures = combineFeatures;
    function createConnection(connectionFactory, watchDog, factories) {
      const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
      const connection2 = connectionFactory(logger);
      logger.rawAttach(connection2);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
      const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
      const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (Is.thenable(value)) {
          return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection2.listen(),
        sendRequest: (type, ...params) => connection2.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection2.onRequest(type, handler),
        sendNotification: (type, param) => {
          const method = Is.string(type) ? type : type.method;
          if (arguments.length === 1) {
            return connection2.sendNotification(method);
          } else {
            return connection2.sendNotification(method, param);
          }
        },
        onNotification: (type, handler) => connection2.onNotification(type, handler),
        onProgress: connection2.onProgress,
        sendProgress: connection2.sendProgress,
        onInitialize: (handler) => {
          initializeHandler = handler;
          return {
            dispose: () => {
              initializeHandler = void 0;
            }
          };
        },
        onInitialized: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => {
          shutdownHandler = handler;
          return {
            dispose: () => {
              shutdownHandler = void 0;
            }
          };
        },
        onExit: (handler) => {
          exitHandler = handler;
          return {
            dispose: () => {
              exitHandler = void 0;
            }
          };
        },
        get console() {
          return logger;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        get languages() {
          return languages;
        },
        get notebooks() {
          return notebooks;
        },
        onDidChangeConfiguration: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection2.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection2.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onCompletion: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCompletionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDeclaration: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onTypeDefinition: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onImplementation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onReferences: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentHighlight: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbol: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onWorkspaceSymbolResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
        onCodeAction: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeActionResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onCodeLensResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentRangeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onDocumentOnTypeFormatting: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        onPrepareRename: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onDocumentLinkResolve: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onColorPresentation: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onFoldingRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onSelectionRanges: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), (0, progress_1.attachPartialResult)(connection2, params));
        }),
        onExecuteCommand: (handler) => connection2.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection2, params), void 0);
        }),
        dispose: () => connection2.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection2.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection2, params), void 0);
          return asPromise(result).then((value) => {
            if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value;
            }
            let result2 = value;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
              capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection2.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (watchDog.shutdownReceived) {
            watchDog.exit(0);
          } else {
            watchDog.exit(1);
          }
        }
      });
      connection2.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    exports2.createConnection = createConnection;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/node/files.js
var require_files = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/node/files.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveModulePath = exports2.FileSystem = exports2.resolveGlobalYarnPath = exports2.resolveGlobalNodePath = exports2.resolve = exports2.uriToFilePath = void 0;
    var url = require("url");
    var path = require("path");
    var fs = require("fs");
    var child_process_1 = require("child_process");
    function uriToFilePath(uri) {
      let parsed = url.parse(uri);
      if (parsed.protocol !== "file:" || !parsed.path) {
        return void 0;
      }
      let segments = parsed.path.split("/");
      for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
      }
      if (process.platform === "win32" && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        if (first.length === 0 && second.length > 1 && second[1] === ":") {
          segments.shift();
        }
      }
      return path.normalize(segments.join("/"));
    }
    exports2.uriToFilePath = uriToFilePath;
    function isWindows() {
      return process.platform === "win32";
    }
    function resolve(moduleName, nodePath, cwd, tracer) {
      const nodePathKey = "NODE_PATH";
      const app = [
        "var p = process;",
        "p.on('message',function(m){",
        "if(m.c==='e'){",
        "p.exit(0);",
        "}",
        "else if(m.c==='rs'){",
        "try{",
        "var r=require.resolve(m.a);",
        "p.send({c:'r',s:true,r:r});",
        "}",
        "catch(err){",
        "p.send({c:'r',s:false});",
        "}",
        "}",
        "});"
      ].join("");
      return new Promise((resolve2, reject) => {
        let env = process.env;
        let newEnv = /* @__PURE__ */ Object.create(null);
        Object.keys(env).forEach((key) => newEnv[key] = env[key]);
        if (nodePath && fs.existsSync(nodePath)) {
          if (newEnv[nodePathKey]) {
            newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
          } else {
            newEnv[nodePathKey] = nodePath;
          }
          if (tracer) {
            tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
          }
        }
        newEnv["ELECTRON_RUN_AS_NODE"] = "1";
        try {
          let cp = (0, child_process_1.fork)("", [], {
            cwd,
            env: newEnv,
            execArgv: ["-e", app]
          });
          if (cp.pid === void 0) {
            reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
            return;
          }
          cp.on("error", (error) => {
            reject(error);
          });
          cp.on("message", (message2) => {
            if (message2.c === "r") {
              cp.send({ c: "e" });
              if (message2.s) {
                resolve2(message2.r);
              } else {
                reject(new Error(`Failed to resolve module: ${moduleName}`));
              }
            }
          });
          let message = {
            c: "rs",
            a: moduleName
          };
          cp.send(message);
        } catch (error) {
          reject(error);
        }
      });
    }
    exports2.resolve = resolve;
    function resolveGlobalNodePath(tracer) {
      let npmCommand = "npm";
      const env = /* @__PURE__ */ Object.create(null);
      Object.keys(process.env).forEach((key) => env[key] = process.env[key]);
      env["NO_UPDATE_NOTIFIER"] = "true";
      const options = {
        encoding: "utf8",
        env
      };
      if (isWindows()) {
        npmCommand = "npm.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let stdout = (0, child_process_1.spawnSync)(npmCommand, ["config", "get", "prefix"], options).stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'npm config get prefix' didn't return a value.`);
          }
          return void 0;
        }
        let prefix = stdout.trim();
        if (tracer) {
          tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
          if (isWindows()) {
            return path.join(prefix, "node_modules");
          } else {
            return path.join(prefix, "lib", "node_modules");
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalNodePath = resolveGlobalNodePath;
    function resolveGlobalYarnPath(tracer) {
      let yarnCommand = "yarn";
      let options = {
        encoding: "utf8"
      };
      if (isWindows()) {
        yarnCommand = "yarn.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let results = (0, child_process_1.spawnSync)(yarnCommand, ["global", "dir", "--json"], options);
        let stdout = results.stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'yarn global dir' didn't return a value.`);
            if (results.stderr) {
              tracer(results.stderr);
            }
          }
          return void 0;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
          try {
            let yarn = JSON.parse(line);
            if (yarn.type === "log") {
              return path.join(yarn.data, "node_modules");
            }
          } catch (e) {
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalYarnPath = resolveGlobalYarnPath;
    var FileSystem;
    (function(FileSystem2) {
      let _isCaseSensitive = void 0;
      function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
          return _isCaseSensitive;
        }
        if (process.platform === "win32") {
          _isCaseSensitive = false;
        } else {
          _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
      }
      FileSystem2.isCaseSensitive = isCaseSensitive;
      function isParent(parent, child) {
        if (isCaseSensitive()) {
          return path.normalize(child).indexOf(path.normalize(parent)) === 0;
        } else {
          return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;
        }
      }
      FileSystem2.isParent = isParent;
    })(FileSystem = exports2.FileSystem || (exports2.FileSystem = {}));
    function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
      if (nodePath) {
        if (!path.isAbsolute(nodePath)) {
          nodePath = path.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
          if (FileSystem.isParent(nodePath, value)) {
            return value;
          } else {
            return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
          }
        }).then(void 0, (_error) => {
          return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
      } else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
      }
    }
    exports2.resolveModulePath = resolveModulePath;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-protocol/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/api.js
var require_api3 = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProposedFeatures = exports2.NotebookDocuments = exports2.TextDocuments = exports2.SemanticTokensBuilder = void 0;
    var semanticTokens_1 = require_semanticTokens();
    Object.defineProperty(exports2, "SemanticTokensBuilder", { enumerable: true, get: function() {
      return semanticTokens_1.SemanticTokensBuilder;
    } });
    __exportStar(require_main3(), exports2);
    var textDocuments_1 = require_textDocuments();
    Object.defineProperty(exports2, "TextDocuments", { enumerable: true, get: function() {
      return textDocuments_1.TextDocuments;
    } });
    var notebook_1 = require_notebook();
    Object.defineProperty(exports2, "NotebookDocuments", { enumerable: true, get: function() {
      return notebook_1.NotebookDocuments;
    } });
    __exportStar(require_server(), exports2);
    var ProposedFeatures;
    (function(ProposedFeatures2) {
      ProposedFeatures2.all = {
        __brand: "features"
      };
    })(ProposedFeatures = exports2.ProposedFeatures || (exports2.ProposedFeatures = {}));
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/node/main.js
var require_main4 = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.Files = void 0;
    var Is = require_is();
    var server_1 = require_server();
    var fm = require_files();
    var node_12 = require_node2();
    __exportStar(require_node2(), exports2);
    __exportStar(require_api3(), exports2);
    var Files;
    (function(Files2) {
      Files2.uriToFilePath = fm.uriToFilePath;
      Files2.resolveGlobalNodePath = fm.resolveGlobalNodePath;
      Files2.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
      Files2.resolve = fm.resolve;
      Files2.resolveModulePath = fm.resolveModulePath;
    })(Files = exports2.Files || (exports2.Files = {}));
    var _protocolConnection;
    function endProtocolConnection() {
      if (_protocolConnection === void 0) {
        return;
      }
      try {
        _protocolConnection.end();
      } catch (_err) {
      }
    }
    var _shutdownReceived = false;
    var exitTimer = void 0;
    function setupExitTimer() {
      const argName = "--clientProcessId";
      function runTimer(value) {
        try {
          let processId = parseInt(value);
          if (!isNaN(processId)) {
            exitTimer = setInterval(() => {
              try {
                process.kill(processId, 0);
              } catch (ex) {
                endProtocolConnection();
                process.exit(_shutdownReceived ? 0 : 1);
              }
            }, 3e3);
          }
        } catch (e) {
        }
      }
      for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
          runTimer(process.argv[i + 1]);
          return;
        } else {
          let args = arg.split("=");
          if (args[0] === argName) {
            runTimer(args[1]);
          }
        }
      }
    }
    setupExitTimer();
    var watchDog = {
      initialize: (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === void 0) {
          setInterval(() => {
            try {
              process.kill(processId, 0);
            } catch (ex) {
              process.exit(_shutdownReceived ? 0 : 1);
            }
          }, 3e3);
        }
      },
      get shutdownReceived() {
        return _shutdownReceived;
      },
      set shutdownReceived(value) {
        _shutdownReceived = value;
      },
      exit: (code) => {
        endProtocolConnection();
        process.exit(code);
      }
    };
    function createConnection(arg1, arg2, arg3, arg4) {
      let factories;
      let input;
      let output;
      let options;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (node_12.ConnectionStrategy.is(arg1) || node_12.ConnectionOptions.is(arg1)) {
        options = arg1;
      } else {
        input = arg1;
        output = arg2;
        options = arg3;
      }
      return _createConnection(input, output, options, factories);
    }
    exports2.createConnection = createConnection;
    function _createConnection(input, output, options, factories) {
      if (!input && !output && process.argv.length > 2) {
        let port2 = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
          let arg = argv[i];
          if (arg === "--node-ipc") {
            input = new node_12.StreamMessageReader(process.stdin);
            output = new node_12.StreamMessageWriter(process.stdout);
            break;
          } else if (arg === "--stdio") {
            input = process.stdin;
            output = process.stdout;
            break;
          } else if (arg === "--socket") {
            port2 = parseInt(argv[i + 1]);
            break;
          } else if (arg === "--pipe") {
            pipeName = argv[i + 1];
            break;
          } else {
            var args = arg.split("=");
            if (args[0] === "--socket") {
              port2 = parseInt(args[1]);
              break;
            } else if (args[0] === "--pipe") {
              pipeName = args[1];
              break;
            }
          }
        }
        if (port2) {
          let transport = (0, node_12.createServerSocketTransport)(port2);
          input = transport[0];
          output = transport[1];
        } else if (pipeName) {
          let transport = (0, node_12.createServerPipeTransport)(pipeName);
          input = transport[0];
          output = transport[1];
        }
      }
      var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
      if (!input) {
        throw new Error("Connection input stream is not set. " + commandLineMessage);
      }
      if (!output) {
        throw new Error("Connection output stream is not set. " + commandLineMessage);
      }
      if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on("end", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on("close", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
      }
      const connectionFactory = (logger) => {
        const result = (0, node_12.createProtocolConnection)(input, output, logger, options);
        return result;
      };
      return (0, server_1.createConnection)(connectionFactory, watchDog, factories);
    }
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/node.js
var require_node3 = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main4();
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-uri/lib/umd/index.js
var require_umd = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-uri/lib/umd/index.js"(exports2, module2) {
    !function(t, e) {
      if ("object" == typeof exports2 && "object" == typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var r = e();
        for (var n in r)
          ("object" == typeof exports2 ? exports2 : t)[n] = r[n];
      }
    }(exports2, () => (() => {
      "use strict";
      var t = { 470: (t2) => {
        function e2(t3) {
          if ("string" != typeof t3)
            throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
        }
        function r2(t3, e3) {
          for (var r3, n3 = "", o = 0, i = -1, a = 0, s = 0; s <= t3.length; ++s) {
            if (s < t3.length)
              r3 = t3.charCodeAt(s);
            else {
              if (47 === r3)
                break;
              r3 = 47;
            }
            if (47 === r3) {
              if (i === s - 1 || 1 === a)
                ;
              else if (i !== s - 1 && 2 === a) {
                if (n3.length < 2 || 2 !== o || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
                  if (n3.length > 2) {
                    var h = n3.lastIndexOf("/");
                    if (h !== n3.length - 1) {
                      -1 === h ? (n3 = "", o = 0) : o = (n3 = n3.slice(0, h)).length - 1 - n3.lastIndexOf("/"), i = s, a = 0;
                      continue;
                    }
                  } else if (2 === n3.length || 1 === n3.length) {
                    n3 = "", o = 0, i = s, a = 0;
                    continue;
                  }
                }
                e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", o = 2);
              } else
                n3.length > 0 ? n3 += "/" + t3.slice(i + 1, s) : n3 = t3.slice(i + 1, s), o = s - i - 1;
              i = s, a = 0;
            } else
              46 === r3 && -1 !== a ? ++a : a = -1;
          }
          return n3;
        }
        var n2 = { resolve: function() {
          for (var t3, n3 = "", o = false, i = arguments.length - 1; i >= -1 && !o; i--) {
            var a;
            i >= 0 ? a = arguments[i] : (void 0 === t3 && (t3 = process.cwd()), a = t3), e2(a), 0 !== a.length && (n3 = a + "/" + n3, o = 47 === a.charCodeAt(0));
          }
          return n3 = r2(n3, !o), o ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
        }, normalize: function(t3) {
          if (e2(t3), 0 === t3.length)
            return ".";
          var n3 = 47 === t3.charCodeAt(0), o = 47 === t3.charCodeAt(t3.length - 1);
          return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && o && (t3 += "/"), n3 ? "/" + t3 : t3;
        }, isAbsolute: function(t3) {
          return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
        }, join: function() {
          if (0 === arguments.length)
            return ".";
          for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
            var o = arguments[r3];
            e2(o), o.length > 0 && (void 0 === t3 ? t3 = o : t3 += "/" + o);
          }
          return void 0 === t3 ? "." : n2.normalize(t3);
        }, relative: function(t3, r3) {
          if (e2(t3), e2(r3), t3 === r3)
            return "";
          if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3)))
            return "";
          for (var o = 1; o < t3.length && 47 === t3.charCodeAt(o); ++o)
            ;
          for (var i = t3.length, a = i - o, s = 1; s < r3.length && 47 === r3.charCodeAt(s); ++s)
            ;
          for (var h = r3.length - s, c = a < h ? a : h, f = -1, u = 0; u <= c; ++u) {
            if (u === c) {
              if (h > c) {
                if (47 === r3.charCodeAt(s + u))
                  return r3.slice(s + u + 1);
                if (0 === u)
                  return r3.slice(s + u);
              } else
                a > c && (47 === t3.charCodeAt(o + u) ? f = u : 0 === u && (f = 0));
              break;
            }
            var l = t3.charCodeAt(o + u);
            if (l !== r3.charCodeAt(s + u))
              break;
            47 === l && (f = u);
          }
          var p = "";
          for (u = o + f + 1; u <= i; ++u)
            u !== i && 47 !== t3.charCodeAt(u) || (0 === p.length ? p += ".." : p += "/..");
          return p.length > 0 ? p + r3.slice(s + f) : (s += f, 47 === r3.charCodeAt(s) && ++s, r3.slice(s));
        }, _makeLong: function(t3) {
          return t3;
        }, dirname: function(t3) {
          if (e2(t3), 0 === t3.length)
            return ".";
          for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, o = -1, i = true, a = t3.length - 1; a >= 1; --a)
            if (47 === (r3 = t3.charCodeAt(a))) {
              if (!i) {
                o = a;
                break;
              }
            } else
              i = false;
          return -1 === o ? n3 ? "/" : "." : n3 && 1 === o ? "//" : t3.slice(0, o);
        }, basename: function(t3, r3) {
          if (void 0 !== r3 && "string" != typeof r3)
            throw new TypeError('"ext" argument must be a string');
          e2(t3);
          var n3, o = 0, i = -1, a = true;
          if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
            if (r3.length === t3.length && r3 === t3)
              return "";
            var s = r3.length - 1, h = -1;
            for (n3 = t3.length - 1; n3 >= 0; --n3) {
              var c = t3.charCodeAt(n3);
              if (47 === c) {
                if (!a) {
                  o = n3 + 1;
                  break;
                }
              } else
                -1 === h && (a = false, h = n3 + 1), s >= 0 && (c === r3.charCodeAt(s) ? -1 == --s && (i = n3) : (s = -1, i = h));
            }
            return o === i ? i = h : -1 === i && (i = t3.length), t3.slice(o, i);
          }
          for (n3 = t3.length - 1; n3 >= 0; --n3)
            if (47 === t3.charCodeAt(n3)) {
              if (!a) {
                o = n3 + 1;
                break;
              }
            } else
              -1 === i && (a = false, i = n3 + 1);
          return -1 === i ? "" : t3.slice(o, i);
        }, extname: function(t3) {
          e2(t3);
          for (var r3 = -1, n3 = 0, o = -1, i = true, a = 0, s = t3.length - 1; s >= 0; --s) {
            var h = t3.charCodeAt(s);
            if (47 !== h)
              -1 === o && (i = false, o = s + 1), 46 === h ? -1 === r3 ? r3 = s : 1 !== a && (a = 1) : -1 !== r3 && (a = -1);
            else if (!i) {
              n3 = s + 1;
              break;
            }
          }
          return -1 === r3 || -1 === o || 0 === a || 1 === a && r3 === o - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, o);
        }, format: function(t3) {
          if (null === t3 || "object" != typeof t3)
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
          return function(t4, e3) {
            var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
            return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
          }(0, t3);
        }, parse: function(t3) {
          e2(t3);
          var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
          if (0 === t3.length)
            return r3;
          var n3, o = t3.charCodeAt(0), i = 47 === o;
          i ? (r3.root = "/", n3 = 1) : n3 = 0;
          for (var a = -1, s = 0, h = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f)
            if (47 !== (o = t3.charCodeAt(f)))
              -1 === h && (c = false, h = f + 1), 46 === o ? -1 === a ? a = f : 1 !== u && (u = 1) : -1 !== a && (u = -1);
            else if (!c) {
              s = f + 1;
              break;
            }
          return -1 === a || -1 === h || 0 === u || 1 === u && a === h - 1 && a === s + 1 ? -1 !== h && (r3.base = r3.name = 0 === s && i ? t3.slice(1, h) : t3.slice(s, h)) : (0 === s && i ? (r3.name = t3.slice(1, a), r3.base = t3.slice(1, h)) : (r3.name = t3.slice(s, a), r3.base = t3.slice(s, h)), r3.ext = t3.slice(a, h)), s > 0 ? r3.dir = t3.slice(0, s - 1) : i && (r3.dir = "/"), r3;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        n2.posix = n2, t2.exports = n2;
      }, 674: (t2, e2) => {
        if (Object.defineProperty(e2, "__esModule", { value: true }), e2.isWindows = void 0, "object" == typeof process)
          e2.isWindows = "win32" === process.platform;
        else if ("object" == typeof navigator) {
          var r2 = navigator.userAgent;
          e2.isWindows = r2.indexOf("Windows") >= 0;
        }
      }, 796: function(t2, e2, r2) {
        var n2, o, i = this && this.__extends || (n2 = function(t3, e3) {
          return n2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
            t4.__proto__ = e4;
          } || function(t4, e4) {
            for (var r3 in e4)
              Object.prototype.hasOwnProperty.call(e4, r3) && (t4[r3] = e4[r3]);
          }, n2(t3, e3);
        }, function(t3, e3) {
          if ("function" != typeof e3 && null !== e3)
            throw new TypeError("Class extends value " + String(e3) + " is not a constructor or null");
          function r3() {
            this.constructor = t3;
          }
          n2(t3, e3), t3.prototype = null === e3 ? Object.create(e3) : (r3.prototype = e3.prototype, new r3());
        });
        Object.defineProperty(e2, "__esModule", { value: true }), e2.uriToFsPath = e2.URI = void 0;
        var a = r2(674), s = /^\w[\w\d+.-]*$/, h = /^\//, c = /^\/\//;
        function f(t3, e3) {
          if (!t3.scheme && e3)
            throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(t3.authority, '", path: "').concat(t3.path, '", query: "').concat(t3.query, '", fragment: "').concat(t3.fragment, '"}'));
          if (t3.scheme && !s.test(t3.scheme))
            throw new Error("[UriError]: Scheme contains illegal characters.");
          if (t3.path) {
            if (t3.authority) {
              if (!h.test(t3.path))
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            } else if (c.test(t3.path))
              throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
          }
        }
        var u = "", l = "/", p = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, d = function() {
          function t3(t4, e3, r3, n3, o2, i2) {
            void 0 === i2 && (i2 = false), "object" == typeof t4 ? (this.scheme = t4.scheme || u, this.authority = t4.authority || u, this.path = t4.path || u, this.query = t4.query || u, this.fragment = t4.fragment || u) : (this.scheme = /* @__PURE__ */ function(t5, e4) {
              return t5 || e4 ? t5 : "file";
            }(t4, i2), this.authority = e3 || u, this.path = function(t5, e4) {
              switch (t5) {
                case "https":
                case "http":
                case "file":
                  e4 ? e4[0] !== l && (e4 = l + e4) : e4 = l;
              }
              return e4;
            }(this.scheme, r3 || u), this.query = n3 || u, this.fragment = o2 || u, f(this, i2));
          }
          return t3.isUri = function(e3) {
            return e3 instanceof t3 || !!e3 && "string" == typeof e3.authority && "string" == typeof e3.fragment && "string" == typeof e3.path && "string" == typeof e3.query && "string" == typeof e3.scheme && "string" == typeof e3.fsPath && "function" == typeof e3.with && "function" == typeof e3.toString;
          }, Object.defineProperty(t3.prototype, "fsPath", { get: function() {
            return C(this, false);
          }, enumerable: false, configurable: true }), t3.prototype.with = function(t4) {
            if (!t4)
              return this;
            var e3 = t4.scheme, r3 = t4.authority, n3 = t4.path, o2 = t4.query, i2 = t4.fragment;
            return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = u), void 0 === r3 ? r3 = this.authority : null === r3 && (r3 = u), void 0 === n3 ? n3 = this.path : null === n3 && (n3 = u), void 0 === o2 ? o2 = this.query : null === o2 && (o2 = u), void 0 === i2 ? i2 = this.fragment : null === i2 && (i2 = u), e3 === this.scheme && r3 === this.authority && n3 === this.path && o2 === this.query && i2 === this.fragment ? this : new v(e3, r3, n3, o2, i2);
          }, t3.parse = function(t4, e3) {
            void 0 === e3 && (e3 = false);
            var r3 = p.exec(t4);
            return r3 ? new v(r3[2] || u, x(r3[4] || u), x(r3[5] || u), x(r3[7] || u), x(r3[9] || u), e3) : new v(u, u, u, u, u);
          }, t3.file = function(t4) {
            var e3 = u;
            if (a.isWindows && (t4 = t4.replace(/\\/g, l)), t4[0] === l && t4[1] === l) {
              var r3 = t4.indexOf(l, 2);
              -1 === r3 ? (e3 = t4.substring(2), t4 = l) : (e3 = t4.substring(2, r3), t4 = t4.substring(r3) || l);
            }
            return new v("file", e3, t4, u, u);
          }, t3.from = function(t4) {
            var e3 = new v(t4.scheme, t4.authority, t4.path, t4.query, t4.fragment);
            return f(e3, true), e3;
          }, t3.prototype.toString = function(t4) {
            return void 0 === t4 && (t4 = false), A(this, t4);
          }, t3.prototype.toJSON = function() {
            return this;
          }, t3.revive = function(e3) {
            if (e3) {
              if (e3 instanceof t3)
                return e3;
              var r3 = new v(e3);
              return r3._formatted = e3.external, r3._fsPath = e3._sep === g ? e3.fsPath : null, r3;
            }
            return e3;
          }, t3;
        }();
        e2.URI = d;
        var g = a.isWindows ? 1 : void 0, v = function(t3) {
          function e3() {
            var e4 = null !== t3 && t3.apply(this, arguments) || this;
            return e4._formatted = null, e4._fsPath = null, e4;
          }
          return i(e3, t3), Object.defineProperty(e3.prototype, "fsPath", { get: function() {
            return this._fsPath || (this._fsPath = C(this, false)), this._fsPath;
          }, enumerable: false, configurable: true }), e3.prototype.toString = function(t4) {
            return void 0 === t4 && (t4 = false), t4 ? A(this, true) : (this._formatted || (this._formatted = A(this, false)), this._formatted);
          }, e3.prototype.toJSON = function() {
            var t4 = { $mid: 1 };
            return this._fsPath && (t4.fsPath = this._fsPath, t4._sep = g), this._formatted && (t4.external = this._formatted), this.path && (t4.path = this.path), this.scheme && (t4.scheme = this.scheme), this.authority && (t4.authority = this.authority), this.query && (t4.query = this.query), this.fragment && (t4.fragment = this.fragment), t4;
          }, e3;
        }(d), y = ((o = {})[58] = "%3A", o[47] = "%2F", o[63] = "%3F", o[35] = "%23", o[91] = "%5B", o[93] = "%5D", o[64] = "%40", o[33] = "%21", o[36] = "%24", o[38] = "%26", o[39] = "%27", o[40] = "%28", o[41] = "%29", o[42] = "%2A", o[43] = "%2B", o[44] = "%2C", o[59] = "%3B", o[61] = "%3D", o[32] = "%20", o);
        function m(t3, e3, r3) {
          for (var n3 = void 0, o2 = -1, i2 = 0; i2 < t3.length; i2++) {
            var a2 = t3.charCodeAt(i2);
            if (a2 >= 97 && a2 <= 122 || a2 >= 65 && a2 <= 90 || a2 >= 48 && a2 <= 57 || 45 === a2 || 46 === a2 || 95 === a2 || 126 === a2 || e3 && 47 === a2 || r3 && 91 === a2 || r3 && 93 === a2 || r3 && 58 === a2)
              -1 !== o2 && (n3 += encodeURIComponent(t3.substring(o2, i2)), o2 = -1), void 0 !== n3 && (n3 += t3.charAt(i2));
            else {
              void 0 === n3 && (n3 = t3.substr(0, i2));
              var s2 = y[a2];
              void 0 !== s2 ? (-1 !== o2 && (n3 += encodeURIComponent(t3.substring(o2, i2)), o2 = -1), n3 += s2) : -1 === o2 && (o2 = i2);
            }
          }
          return -1 !== o2 && (n3 += encodeURIComponent(t3.substring(o2))), void 0 !== n3 ? n3 : t3;
        }
        function b(t3) {
          for (var e3 = void 0, r3 = 0; r3 < t3.length; r3++) {
            var n3 = t3.charCodeAt(r3);
            35 === n3 || 63 === n3 ? (void 0 === e3 && (e3 = t3.substr(0, r3)), e3 += y[n3]) : void 0 !== e3 && (e3 += t3[r3]);
          }
          return void 0 !== e3 ? e3 : t3;
        }
        function C(t3, e3) {
          var r3;
          return r3 = t3.authority && t3.path.length > 1 && "file" === t3.scheme ? "//".concat(t3.authority).concat(t3.path) : 47 === t3.path.charCodeAt(0) && (t3.path.charCodeAt(1) >= 65 && t3.path.charCodeAt(1) <= 90 || t3.path.charCodeAt(1) >= 97 && t3.path.charCodeAt(1) <= 122) && 58 === t3.path.charCodeAt(2) ? e3 ? t3.path.substr(1) : t3.path[1].toLowerCase() + t3.path.substr(2) : t3.path, a.isWindows && (r3 = r3.replace(/\//g, "\\")), r3;
        }
        function A(t3, e3) {
          var r3 = e3 ? b : m, n3 = "", o2 = t3.scheme, i2 = t3.authority, a2 = t3.path, s2 = t3.query, h2 = t3.fragment;
          if (o2 && (n3 += o2, n3 += ":"), (i2 || "file" === o2) && (n3 += l, n3 += l), i2) {
            var c2 = i2.indexOf("@");
            if (-1 !== c2) {
              var f2 = i2.substr(0, c2);
              i2 = i2.substr(c2 + 1), -1 === (c2 = f2.lastIndexOf(":")) ? n3 += r3(f2, false, false) : (n3 += r3(f2.substr(0, c2), false, false), n3 += ":", n3 += r3(f2.substr(c2 + 1), false, true)), n3 += "@";
            }
            -1 === (c2 = (i2 = i2.toLowerCase()).lastIndexOf(":")) ? n3 += r3(i2, false, true) : (n3 += r3(i2.substr(0, c2), false, true), n3 += i2.substr(c2));
          }
          if (a2) {
            if (a2.length >= 3 && 47 === a2.charCodeAt(0) && 58 === a2.charCodeAt(2))
              (u2 = a2.charCodeAt(1)) >= 65 && u2 <= 90 && (a2 = "/".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(3)));
            else if (a2.length >= 2 && 58 === a2.charCodeAt(1)) {
              var u2;
              (u2 = a2.charCodeAt(0)) >= 65 && u2 <= 90 && (a2 = "".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(2)));
            }
            n3 += r3(a2, true, false);
          }
          return s2 && (n3 += "?", n3 += r3(s2, false, false)), h2 && (n3 += "#", n3 += e3 ? h2 : m(h2, false, false)), n3;
        }
        function w(t3) {
          try {
            return decodeURIComponent(t3);
          } catch (e3) {
            return t3.length > 3 ? t3.substr(0, 3) + w(t3.substr(3)) : t3;
          }
        }
        e2.uriToFsPath = C;
        var _ = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
        function x(t3) {
          return t3.match(_) ? t3.replace(_, function(t4) {
            return w(t4);
          }) : t3;
        }
      }, 679: function(t2, e2, r2) {
        var n2 = this && this.__spreadArray || function(t3, e3, r3) {
          if (r3 || 2 === arguments.length)
            for (var n3, o2 = 0, i2 = e3.length; o2 < i2; o2++)
              !n3 && o2 in e3 || (n3 || (n3 = Array.prototype.slice.call(e3, 0, o2)), n3[o2] = e3[o2]);
          return t3.concat(n3 || Array.prototype.slice.call(e3));
        };
        Object.defineProperty(e2, "__esModule", { value: true }), e2.Utils = void 0;
        var o, i = r2(470), a = i.posix || i, s = "/";
        (o = e2.Utils || (e2.Utils = {})).joinPath = function(t3) {
          for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
            e3[r3 - 1] = arguments[r3];
          return t3.with({ path: a.join.apply(a, n2([t3.path], e3, false)) });
        }, o.resolvePath = function(t3) {
          for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
            e3[r3 - 1] = arguments[r3];
          var o2 = t3.path, i2 = false;
          o2[0] !== s && (o2 = s + o2, i2 = true);
          var h = a.resolve.apply(a, n2([o2], e3, false));
          return i2 && h[0] === s && !t3.authority && (h = h.substring(1)), t3.with({ path: h });
        }, o.dirname = function(t3) {
          if (0 === t3.path.length || t3.path === s)
            return t3;
          var e3 = a.dirname(t3.path);
          return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t3.with({ path: e3 });
        }, o.basename = function(t3) {
          return a.basename(t3.path);
        }, o.extname = function(t3) {
          return a.extname(t3.path);
        };
      } }, e = {};
      function r(n2) {
        var o = e[n2];
        if (void 0 !== o)
          return o.exports;
        var i = e[n2] = { exports: {} };
        return t[n2].call(i.exports, i, i.exports, r), i.exports;
      }
      var n = {};
      return (() => {
        var t2 = n;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Utils = t2.URI = void 0;
        var e2 = r(796);
        Object.defineProperty(t2, "URI", { enumerable: true, get: function() {
          return e2.URI;
        } });
        var o = r(679);
        Object.defineProperty(t2, "Utils", { enumerable: true, get: function() {
          return o.Utils;
        } });
      })(), n;
    })());
  }
});

// unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-textdocument/lib/umd/main.js
var require_main5 = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/vscode-languageserver-textdocument/lib/umd/main.js"(exports2, module2) {
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0)
          module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.TextDocument = void 0;
      var FullTextDocument = (
        /** @class */
        function() {
          function FullTextDocument2(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = void 0;
          }
          Object.defineProperty(FullTextDocument2.prototype, "uri", {
            get: function() {
              return this._uri;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "languageId", {
            get: function() {
              return this._languageId;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(FullTextDocument2.prototype, "version", {
            get: function() {
              return this._version;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument2.prototype.getText = function(range) {
            if (range) {
              var start = this.offsetAt(range.start);
              var end = this.offsetAt(range.end);
              return this._content.substring(start, end);
            }
            return this._content;
          };
          FullTextDocument2.prototype.update = function(changes, version) {
            for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
              var change = changes_1[_i];
              if (FullTextDocument2.isIncremental(change)) {
                var range = getWellformedRange(change.range);
                var startOffset = this.offsetAt(range.start);
                var endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                var startLine = Math.max(range.start.line, 0);
                var endLine = Math.max(range.end.line, 0);
                var lineOffsets = this._lineOffsets;
                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                  for (var i = 0, len = addedLineOffsets.length; i < len; i++) {
                    lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                  }
                } else {
                  if (addedLineOffsets.length < 1e4) {
                    lineOffsets.splice.apply(lineOffsets, __spreadArray([startLine + 1, endLine - startLine], addedLineOffsets, false));
                  } else {
                    this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                  }
                }
                var diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                  for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                    lineOffsets[i] = lineOffsets[i] + diff;
                  }
                }
              } else if (FullTextDocument2.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = void 0;
              } else {
                throw new Error("Unknown change event received");
              }
            }
            this._version = version;
          };
          FullTextDocument2.prototype.getLineOffsets = function() {
            if (this._lineOffsets === void 0) {
              this._lineOffsets = computeLineOffsets(this._content, true);
            }
            return this._lineOffsets;
          };
          FullTextDocument2.prototype.positionAt = function(offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
              return { line: 0, character: offset };
            }
            while (low < high) {
              var mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset) {
                high = mid;
              } else {
                low = mid + 1;
              }
            }
            var line = low - 1;
            return { line, character: offset - lineOffsets[line] };
          };
          FullTextDocument2.prototype.offsetAt = function(position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
              return this._content.length;
            } else if (position.line < 0) {
              return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
          };
          Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
            get: function() {
              return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
          });
          FullTextDocument2.isIncremental = function(event) {
            var candidate = event;
            return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
          };
          FullTextDocument2.isFull = function(event) {
            var candidate = event;
            return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
          };
          return FullTextDocument2;
        }()
      );
      var TextDocument;
      (function(TextDocument2) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument2.create = create;
        function update(document, changes, version) {
          if (document instanceof FullTextDocument) {
            document.update(changes, version);
            return document;
          } else {
            throw new Error("TextDocument.update: document must be created by TextDocument.create");
          }
        }
        TextDocument2.update = update;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort(edits.map(getWellformedEdit), function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = 0;
          var spans = [];
          for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {
            var e = sortedEdits_1[_i];
            var startOffset = document.offsetAt(e.range.start);
            if (startOffset < lastModifiedOffset) {
              throw new Error("Overlapping edit");
            } else if (startOffset > lastModifiedOffset) {
              spans.push(text.substring(lastModifiedOffset, startOffset));
            }
            if (e.newText.length) {
              spans.push(e.newText);
            }
            lastModifiedOffset = document.offsetAt(e.range.end);
          }
          spans.push(text.substr(lastModifiedOffset));
          return spans.join("");
        }
        TextDocument2.applyEdits = applyEdits;
      })(TextDocument = exports3.TextDocument || (exports3.TextDocument = {}));
      function mergeSort(data, compare) {
        if (data.length <= 1) {
          return data;
        }
        var p = data.length / 2 | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          var ret = compare(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
      function computeLineOffsets(text, isAtLineStart, textOffset) {
        if (textOffset === void 0) {
          textOffset = 0;
        }
        var result = isAtLineStart ? [textOffset] : [];
        for (var i = 0; i < text.length; i++) {
          var ch = text.charCodeAt(i);
          if (ch === 13 || ch === 10) {
            if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
              i++;
            }
            result.push(textOffset + i + 1);
          }
        }
        return result;
      }
      function getWellformedRange(range) {
        var start = range.start;
        var end = range.end;
        if (start.line > end.line || start.line === end.line && start.character > end.character) {
          return { start: end, end: start };
        }
        return range;
      }
      function getWellformedEdit(textEdit) {
        var range = getWellformedRange(textEdit.range);
        if (range !== textEdit.range) {
          return { newText: textEdit.newText, range };
        }
        return textEdit;
      }
    });
  }
});

// unreal-angelscript-lsp/language-server/out/database.js
var require_database = __commonJS({
  "unreal-angelscript-lsp/language-server/out/database.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FormatDocumentationComment = exports2.RemoveTypeFromDatabase = exports2.AddUnrealTypeToDatabase = exports2.AddTypeToDatabase = exports2.FinishTypesFromUnreal = exports2.HasTypesFromUnreal = exports2.AddTypesFromUnreal = exports2.IsPrimitiveFloatType = exports2.ArePrimitiveTypesEquivalent = exports2.AddPrimitiveTypes = exports2.IsPrimitive = exports2.HasTypeWithPrefix = exports2.LookupGlobalSymbolsWithPrefix = exports2.LookupGlobalSymbol = exports2.FormatTemplateTypename = exports2.LookupType = exports2.RemoveNamespaceDeclaration = exports2.DeclareNamespace = exports2.GetRootNamespace = exports2.LookupNamespacesWithPrefix = exports2.LookupNamespace = exports2.GetAllNamespaces = exports2.GetAllTypesById = exports2.GetTypeById = exports2.GetTypeByName = exports2.ReplaceTemplateType = exports2.TransferTypeQualifiers = exports2.TypenameEquals = exports2.CleanTypeName = exports2.OnDirtyTypeCaches = exports2.DBAccessPermission = exports2.DBAccessSpecifier = exports2.DBNamespace = exports2.DBNamespaceDeclaration = exports2.DBType = exports2.DBMethod = exports2.DBMethodAnnotation = exports2.DBArg = exports2.DBProperty = exports2.DBTypeClassification = exports2.FilterAllowsSymbol = exports2.AllowsTypes = exports2.AllowsProperties = exports2.AllowsFunctions = exports2.DBAllowSymbol = void 0;
    var DBAllowSymbol;
    (function(DBAllowSymbol2) {
      DBAllowSymbol2[DBAllowSymbol2["None"] = 0] = "None";
      DBAllowSymbol2[DBAllowSymbol2["All"] = -1] = "All";
      DBAllowSymbol2[DBAllowSymbol2["Properties"] = 1] = "Properties";
      DBAllowSymbol2[DBAllowSymbol2["Functions"] = 2] = "Functions";
      DBAllowSymbol2[DBAllowSymbol2["Mixins"] = 4] = "Mixins";
      DBAllowSymbol2[DBAllowSymbol2["Types"] = 8] = "Types";
      DBAllowSymbol2[DBAllowSymbol2["PropertiesAndFunctions"] = 3] = "PropertiesAndFunctions";
      DBAllowSymbol2[DBAllowSymbol2["FunctionsAndMixins"] = 6] = "FunctionsAndMixins";
    })(DBAllowSymbol = exports2.DBAllowSymbol || (exports2.DBAllowSymbol = {}));
    function AllowsFunctions(allowSymbol) {
      return (allowSymbol & DBAllowSymbol.Functions) != 0;
    }
    exports2.AllowsFunctions = AllowsFunctions;
    function AllowsProperties(allowSymbol) {
      return (allowSymbol & DBAllowSymbol.Properties) != 0;
    }
    exports2.AllowsProperties = AllowsProperties;
    function AllowsTypes(allowSymbol) {
      return (allowSymbol & DBAllowSymbol.Types) != 0;
    }
    exports2.AllowsTypes = AllowsTypes;
    function FilterAllowsSymbol(symbol, allowSymbol) {
      if (symbol instanceof DBProperty) {
        if ((allowSymbol & DBAllowSymbol.Properties) != 0)
          return true;
      } else if (symbol instanceof DBMethod) {
        if (symbol.isMixin) {
          if ((allowSymbol & DBAllowSymbol.Mixins) != 0)
            return true;
        } else {
          if ((allowSymbol & DBAllowSymbol.Functions) != 0)
            return true;
        }
      } else if (symbol instanceof DBType) {
        if ((allowSymbol & DBAllowSymbol.Types) != 0)
          return true;
      }
      return false;
    }
    exports2.FilterAllowsSymbol = FilterAllowsSymbol;
    var DBTypeClassification;
    (function(DBTypeClassification2) {
      DBTypeClassification2[DBTypeClassification2["Unknown"] = 0] = "Unknown";
      DBTypeClassification2[DBTypeClassification2["Other"] = 1] = "Other";
      DBTypeClassification2[DBTypeClassification2["Component"] = 2] = "Component";
      DBTypeClassification2[DBTypeClassification2["Actor"] = 3] = "Actor";
      DBTypeClassification2[DBTypeClassification2["Struct"] = 4] = "Struct";
      DBTypeClassification2[DBTypeClassification2["Event"] = 5] = "Event";
      DBTypeClassification2[DBTypeClassification2["Delegate"] = 6] = "Delegate";
      DBTypeClassification2[DBTypeClassification2["Primitive"] = 7] = "Primitive";
    })(DBTypeClassification = exports2.DBTypeClassification || (exports2.DBTypeClassification = {}));
    var DBProperty = class _DBProperty {
      constructor() {
        this.isProtected = false;
        this.isPrivate = false;
        this.isNoEdit = false;
        this.isEditOnly = false;
        this.isAutoGenerated = false;
        this.isLiteralAsset = false;
        this.accessSpecifier = null;
        this.moduleOffsetEnd = -1;
        this.containingType = null;
        this.namespace = null;
        this.keywords = null;
        this.isUProperty = false;
        this.macroSpecifiers = null;
        this.macroMeta = null;
        this.auxiliarySymbols = null;
      }
      fromJSON(name, input) {
        this.name = name;
        this.typename = input[0];
        this.isProtected = false;
        this.isPrivate = false;
        this.isNoEdit = false;
        this.isEditOnly = false;
        let flags = 0;
        for (let i = 1; i < input.length; ++i) {
          if (typeof input[i] == "string") {
            if (input[i] == "NoEdit")
              flags |= 1;
            else if (input[i] == "EditOnly")
              flags |= 2;
            else
              this.documentation = FormatDocumentationComment(input[i]);
          } else if (typeof input[i] == "number") {
            flags = input[i];
          }
        }
        if (flags & 1)
          this.isNoEdit = true;
        if (flags & 2)
          this.isEditOnly = true;
        if (flags & 4)
          this.isProtected = true;
      }
      format(prefix = null) {
        let str = "";
        if (this.isProtected)
          str += "protected ";
        if (this.isPrivate)
          str += "private ";
        str += this.typename;
        str += " ";
        if (prefix)
          str += prefix;
        str += this.name;
        return str;
      }
      createTemplateInstance(templateTypes, actualTypes) {
        let inst = new _DBProperty();
        inst.name = this.name;
        inst.typename = ReplaceTemplateType(this.typename, templateTypes, actualTypes);
        return inst;
      }
    };
    exports2.DBProperty = DBProperty;
    var DBArg = class _DBArg {
      init(typename, name, defaultvalue = "") {
        this.name = name;
        this.typename = typename;
        if (defaultvalue)
          this.defaultvalue = defaultvalue;
        return this;
      }
      fromJSON(input) {
        this.name = "name" in input ? input["name"] : null;
        this.typename = input["type"];
        this.defaultvalue = "default" in input ? input["default"] : null;
      }
      format(overrideType = null) {
        let decl = this.typename;
        if (overrideType)
          decl = overrideType;
        if (this.name != null)
          decl += " " + this.name;
        if (this.defaultvalue != null)
          decl += " = " + this.defaultvalue;
        return decl;
      }
      createTemplateInstance(templateTypes, actualTypes) {
        let inst = new _DBArg();
        inst.name = this.name;
        inst.defaultvalue = this.defaultvalue;
        inst.typename = ReplaceTemplateType(this.typename, templateTypes, actualTypes);
        return inst;
      }
    };
    exports2.DBArg = DBArg;
    var DBMethodAnnotation;
    (function(DBMethodAnnotation2) {
      DBMethodAnnotation2[DBMethodAnnotation2["None"] = 0] = "None";
      DBMethodAnnotation2[DBMethodAnnotation2["IsHexColor"] = 1] = "IsHexColor";
      DBMethodAnnotation2[DBMethodAnnotation2["IsLinearColor"] = 2] = "IsLinearColor";
    })(DBMethodAnnotation = exports2.DBMethodAnnotation || (exports2.DBMethodAnnotation = {}));
    var DBMethod = class _DBMethod {
      constructor() {
        this.isProtected = false;
        this.isPrivate = false;
        this.isConstructor = false;
        this.isBlueprintEvent = false;
        this.isCallable = true;
        this.isBlueprintOverride = false;
        this.isConst = false;
        this.isFinal = false;
        this.isProperty = false;
        this.isOverride = false;
        this.isDefaultsOnly = false;
        this.isLocal = false;
        this.id = NextMethodId++;
        this.containingType = null;
        this.namespace = null;
        this.keywords = null;
        this.isAutoGenerated = false;
        this.isMixin = false;
        this.accessSpecifier = null;
        this.auxiliarySymbols = null;
        this.determinesOutputTypeArgumentIndex = -1;
        this.isUFunction = false;
        this.unrealName = null;
        this.macroSpecifiers = null;
        this.macroMeta = null;
        this.hasSuperCall = false;
        this.isEmpty = false;
        this.isDelegateBindFunction = false;
        this.delegateBindType = null;
        this.delegateObjectParam = -1;
        this.delegateFunctionParam = -1;
        this.delegateWildcardParam = -1;
        this.methodAnnotation = DBMethodAnnotation.None;
        this.isTemplateInstantiation = false;
        this.moduleOffsetEnd = -1;
        this.moduleScopeStart = -1;
        this.moduleScopeEnd = -1;
      }
      createTemplateInstance(templateTypes, actualTypes) {
        let inst = new _DBMethod();
        inst.name = this.name;
        inst.returnType = ReplaceTemplateType(this.returnType, templateTypes, actualTypes);
        inst.argumentStr = this.argumentStr;
        inst.documentation = this.documentation;
        inst.isProtected = this.isProtected;
        inst.isPrivate = this.isPrivate;
        inst.isConstructor = this.isConstructor;
        inst.isBlueprintEvent = this.isBlueprintEvent;
        inst.isCallable = this.isCallable;
        inst.isBlueprintOverride = this.isBlueprintOverride;
        inst.isConst = this.isConst;
        inst.isProperty = this.isProperty;
        inst.isDefaultsOnly = this.isDefaultsOnly;
        inst.determinesOutputTypeArgumentIndex = this.determinesOutputTypeArgumentIndex;
        inst.isTemplateInstantiation = true;
        inst.args = [];
        for (let argval of this.args)
          inst.args.push(argval.createTemplateInstance(templateTypes, actualTypes));
        return inst;
      }
      fromJSON(input) {
        this.name = input.name;
        if ("return" in input)
          this.returnType = input["return"];
        else
          this.returnType = "void";
        this.args = new Array();
        if ("args" in input) {
          for (let argDesc of input["args"]) {
            let arg = new DBArg();
            arg.fromJSON(argDesc);
            this.args.push(arg);
          }
        }
        if ("doc" in input)
          this.documentation = FormatDocumentationComment(input["doc"]);
        else
          this.documentation = null;
        if ("isConstructor" in input)
          this.isConstructor = input["isConstructor"];
        else
          this.isConstructor = false;
        if ("callable" in input)
          this.isCallable = input["callable"];
        else
          this.isCallable = true;
        if ("const" in input)
          this.isConst = input["const"];
        else
          this.isConst = false;
        if ("event" in input)
          this.isBlueprintEvent = input["event"];
        else
          this.isBlueprintEvent = false;
        if ("isProperty" in input)
          this.isProperty = input["isProperty"];
        else
          this.isProperty = true;
        if ("protected" in input)
          this.isProtected = input["protected"];
        else
          this.isProtected = false;
        if ("defaultsonly" in input)
          this.isDefaultsOnly = input["defaultsonly"];
        if ("keywords" in input)
          this.keywords = input["keywords"];
        if ("outputTypeIndex" in input)
          this.determinesOutputTypeArgumentIndex = input["outputTypeIndex"];
        if ("ufunction" in input) {
          this.isUFunction = input["ufunction"];
          if ("unrealname" in input)
            this.unrealName = input["unrealname"];
        }
        if ("meta" in input) {
          if (!this.macroMeta)
            this.macroMeta = /* @__PURE__ */ new Map();
          for (let metaSpec in input["meta"])
            this.macroMeta.set(metaSpec.toLowerCase(), input["meta"][metaSpec]);
          this.cacheDelegateMeta();
        }
      }
      cacheDelegateMeta() {
        if (!this.macroMeta)
          return;
        if (this.macroMeta.has("delegatefunctionparam") && this.macroMeta.has("delegateobjectparam") && this.macroMeta.has("delegatebindtype")) {
          this.isDelegateBindFunction = true;
          this.delegateBindType = this.macroMeta.get("delegatebindtype");
          let functionParam = this.macroMeta.get("delegatefunctionparam");
          let objectParam = this.macroMeta.get("delegateobjectparam");
          let wildcardParam = this.macroMeta.get("delegatewildcardparam");
          for (let i = 0, count = this.args.length; i < count; ++i) {
            if (this.args[i].name == objectParam)
              this.delegateObjectParam = i;
            else if (this.args[i].name == functionParam)
              this.delegateFunctionParam = i;
            else if (wildcardParam && this.args[i].name == wildcardParam)
              this.delegateWildcardParam = i;
          }
        }
      }
      format(prefix = null, skipFirstArg = false, skipReturn = false, replaceName = null, determineType = null) {
        let decl = "";
        if (!skipReturn) {
          if (determineType) {
            let outputType = this.applyDeterminesOutputType(this.returnType, determineType);
            if (outputType)
              decl += outputType.name + " ";
            else
              decl += this.returnType + " ";
          } else if (this.determinesOutputTypeArgumentIndex != -1) {
            decl += "auto ";
          } else {
            decl += this.returnType + " ";
          }
        }
        if (prefix != null)
          decl += prefix;
        if (replaceName)
          decl += replaceName + "(";
        else
          decl += this.name + "(";
        let firstArg = true;
        if (this.argumentStr) {
          let argStr = this.argumentStr;
          if (skipFirstArg) {
            let cPos = argStr.search(",");
            if (cPos != -1)
              argStr = argStr.substr(cPos + 1).trim();
            else
              argStr = "";
          }
          decl += argStr;
        } else if (this.args) {
          for (let i = 0; i < this.args.length; ++i) {
            if (skipFirstArg && i == 0)
              continue;
            let argDecl = this.args[i].format();
            if (determineType && this.determinesOutputTypeArgumentIndex == i)
              argDecl = this.args[i].format(this.applyDeterminesOutputType(this.args[i].typename, determineType).name);
            if (i > 1 || !skipFirstArg && i > 0)
              decl += ", ";
            decl += argDecl;
          }
        }
        decl += ")";
        if (this.isConst)
          decl += " const";
        if (this.isProperty && this.declaredModule)
          decl += " property";
        return decl;
      }
      // Get documentation either from this function or from the
      // first parent function we're overriding
      findAvailableDocumentation(includeParent = true, includeType = true) {
        if (this.documentation)
          return this.documentation;
        if (this.containingType && includeParent) {
          for (let checktype of this.containingType.getInheritanceTypes()) {
            let parentFunc = checktype.findFirstSymbol(this.name, DBAllowSymbol.Functions);
            if (parentFunc && parentFunc instanceof _DBMethod && parentFunc.documentation)
              return parentFunc.documentation;
          }
        }
        if (this.isConstructor && includeType) {
          let dbReturn = LookupType(this.namespace, this.returnType);
          if (dbReturn && dbReturn instanceof DBType && dbReturn.documentation)
            return dbReturn.documentation;
        }
        return null;
      }
      getUnrealName() {
        if (this.unrealName)
          return this.unrealName;
        else
          return this.name;
      }
      hasMetaData(meta) {
        if (!this.macroMeta)
          return false;
        return this.macroMeta.has(meta.toLowerCase());
      }
      getRequiredArgumentCount() {
        if (!this.args)
          return 0;
        for (let i = 0, argCount = this.args.length; i < argCount; ++i) {
          if (this.args[i].defaultvalue)
            return i;
        }
        return this.args.length;
      }
      isSignatureEqual(otherFunc) {
        if (!!this.args != !!otherFunc.args)
          return false;
        if (this.args) {
          if (this.args.length != otherFunc.args.length)
            return false;
          for (let i = 0, argCount = this.args.length; i < argCount; ++i) {
            if (this.args[i].typename != otherFunc.args[i].typename)
              return false;
          }
        }
        if (this.returnType != otherFunc.returnType)
          return false;
        return true;
      }
      applyDeterminesOutputType(originalType, determineType) {
        let resultType = LookupType(this.namespace, originalType);
        if (!resultType)
          return resultType;
        if (!determineType)
          return resultType;
        if (determineType.isTemplateInstantiation) {
          let foundSubType = false;
          for (let subTypeName of determineType.templateSubTypes) {
            let subType = LookupType(this.namespace, subTypeName);
            if (!subType)
              continue;
            foundSubType = true;
            determineType = subType;
            break;
          }
          if (!foundSubType)
            return resultType;
        }
        let targetIsValueType = determineType.isValueType();
        if (determineType.name == "UClass")
          return resultType;
        if (determineType.name == "UScriptStruct")
          return resultType;
        if (resultType.isTemplateInstantiation) {
          let replacedAny = false;
          let newDeclaration = resultType.templateBaseType + "<";
          for (let i = 0, Count = resultType.templateSubTypes.length; i < Count; ++i) {
            if (i != 0)
              newDeclaration += ",";
            let subType = LookupType(this.namespace, resultType.templateSubTypes[i]);
            if (subType && subType.isValueType() == targetIsValueType && (targetIsValueType || determineType.inheritsFrom(subType.name)) && !replacedAny) {
              newDeclaration += TransferTypeQualifiers(resultType.templateSubTypes[i], determineType.getQualifiedTypenameInNamespace(this.namespace));
              replacedAny = true;
            } else {
              newDeclaration += resultType.templateSubTypes[i];
            }
          }
          if (replacedAny) {
            newDeclaration += ">";
            let newType = LookupType(this.namespace, newDeclaration);
            if (newType)
              return newType;
          }
        }
        if (resultType.isValueType() != targetIsValueType)
          return resultType;
        if (!targetIsValueType && !determineType.inheritsFrom(resultType.name))
          return resultType;
        return determineType;
      }
    };
    exports2.DBMethod = DBMethod;
    var DBType = class _DBType {
      constructor() {
        this.typeid = -1;
        this.isDelegate = false;
        this.isEvent = false;
        this.isPrimitive = false;
        this.isTemplateInstantiation = false;
        this.isTemplateCovariant = false;
        this.isTemplateInheritSpecializations = false;
        this.templateBaseType = null;
        this.classification = DBTypeClassification.Unknown;
        this.acccessSpecifiers = null;
        this.keywords = null;
        this.macroSpecifiers = null;
        this.macroMeta = null;
        this.delegateArgs = null;
        this.delegateReturn = null;
        this.moduleOffsetEnd = -1;
        this.moduleScopeStart = -1;
        this.moduleScopeEnd = -1;
        this.symbols = /* @__PURE__ */ new Map();
        this.symbolsByPrefix = /* @__PURE__ */ new Map();
        this.containingType = null;
        this.auxiliarySymbols = null;
        this.extendTypes = null;
        this.extendTypesId = -1;
      }
      createTemplateInstance(actualTypes) {
        if (actualTypes.length != this.templateSubTypes.length)
          return null;
        let inst = new _DBType();
        inst.name = this.name;
        inst.supertype = this.supertype;
        inst.isEnum = this.isEnum;
        inst.declaredModule = this.declaredModule;
        inst.moduleOffset = this.moduleOffset;
        inst.moduleOffsetEnd = this.moduleOffsetEnd;
        inst.isTemplateInstantiation = true;
        inst.isTemplateInheritSpecializations = this.isTemplateInheritSpecializations;
        inst.isTemplateCovariant = this.isTemplateCovariant;
        inst.templateSubTypes = actualTypes;
        inst.templateBaseType = this.name;
        let baseType = this;
        this.forEachSymbol(function(sym) {
          if (sym instanceof DBProperty) {
            let newProp = sym.createTemplateInstance(baseType.templateSubTypes, actualTypes);
            inst.addSymbol(newProp);
          } else if (sym instanceof DBMethod) {
            let newMethod = sym.createTemplateInstance(baseType.templateSubTypes, actualTypes);
            inst.addSymbol(newMethod);
          }
        });
        return inst;
      }
      initEmpty(name) {
        this.name = name;
        return this;
      }
      fromJSON(name, input) {
        this.name = name;
        for (let key in input.properties) {
          let prop = new DBProperty();
          prop.fromJSON(key, input.properties[key]);
          this.addSymbol(prop);
        }
        for (let key in input.methods) {
          let func = new DBMethod();
          func.fromJSON(input.methods[key]);
          this.addSymbol(func);
        }
        if ("subtypes" in input) {
          this.templateSubTypes = new Array();
          for (let subtype of input["subtypes"]) {
            this.templateSubTypes.push(subtype);
          }
        }
        if ("supertype" in input) {
          this.unrealsuper = input["supertype"];
        }
        if ("inherits" in input) {
          this.supertype = input["inherits"];
        }
        if ("doc" in input)
          this.documentation = FormatDocumentationComment(input["doc"]);
        else
          this.documentation = null;
        if ("keywords" in input)
          this.keywords = input["keywords"];
        if ("isStruct" in input)
          this.isStruct = input["isStruct"];
        else
          this.isStruct = false;
        if ("isEnum" in input)
          this.isEnum = input["isEnum"];
        else
          this.isEnum = false;
        let delegateSignatureMethod = null;
        if ("isEvent" in input) {
          this.isEvent = input["isEvent"];
          if (this.isEvent)
            delegateSignatureMethod = this.findFirstSymbol("Broadcast");
        } else {
          delegateSignatureMethod = this.findFirstSymbol("Broadcast");
          this.isEvent = delegateSignatureMethod != null;
        }
        if ("isDelegate" in input) {
          this.isDelegate = input["isDelegate"];
          if (this.isDelegate)
            delegateSignatureMethod = this.findFirstSymbol("ExecuteIfBound");
        } else {
          if (!this.isEvent) {
            delegateSignatureMethod = this.findFirstSymbol("ExecuteIfBound");
            this.isDelegate = delegateSignatureMethod != null;
          } else {
            this.isDelegate = false;
          }
        }
        if ("template_covariant" in input)
          this.isTemplateCovariant = input["template_covariant"];
        if ("template_inherit_specializations" in input)
          this.isTemplateInheritSpecializations = input["template_inherit_specializations"];
        if (delegateSignatureMethod != null && delegateSignatureMethod instanceof DBMethod) {
          this.delegateArgs = delegateSignatureMethod.args;
          this.delegateReturn = delegateSignatureMethod.returnType;
          let bindFuncs = [];
          if (this.isEvent)
            bindFuncs = [this.findFirstSymbol("AddUFunction"), this.findFirstSymbol("Unbind")];
          else
            bindFuncs = [this.findFirstSymbol("BindUFunction")];
          bindFuncs.forEach((bindFunc) => {
            if (bindFunc instanceof DBMethod) {
              bindFunc.isDelegateBindFunction = true;
              bindFunc.delegateBindType = this.name;
              bindFunc.delegateObjectParam = 0;
              bindFunc.delegateFunctionParam = 1;
            }
          });
        }
      }
      getDisplayName() {
        return this.name;
      }
      isTemplateType() {
        return this.templateSubTypes && this.templateSubTypes.length != 0;
      }
      getSuperType() {
        if (!this.supertype)
          return null;
        return LookupType(this.namespace, this.supertype);
      }
      equalsTypename(typename) {
        if (typename == this.name)
          return true;
        let cleaned = CleanTypeName(typename);
        if (cleaned == this.name)
          return true;
        return false;
      }
      isUnrealType() {
        return !this.declaredModule;
      }
      hasExtendTypes() {
        if (this.supertype)
          return true;
        if (this.isTemplateInstantiation && this.isTemplateInheritSpecializations)
          return true;
        return false;
      }
      isShadowingNamespace() {
        if (this.namespace)
          return this.namespace.findChildNamespace(this.name) != null;
        else
          return RootNamespace.findChildNamespace(this.name) != null;
      }
      getExtendTypesList() {
        if (this.extendTypes) {
          if (this.extendTypesId == DirtyTypeCacheId)
            return this.extendTypes;
        }
        this.extendTypes = [this];
        this.extendTypesId = DirtyTypeCacheId;
        let checkIndex = 0;
        while (checkIndex < this.extendTypes.length) {
          let checkType = this.extendTypes[checkIndex];
          if (checkType.supertype) {
            let dbsuper = LookupType(checkType.namespace, checkType.supertype);
            if (dbsuper && !this.extendTypes.includes(dbsuper))
              this.extendTypes.push(dbsuper);
          }
          if (checkType.isTemplateInstantiation && checkType.templateSubTypes.length > 0 && this.isTemplateInheritSpecializations) {
            let subType = LookupType(checkType.namespace, checkType.templateSubTypes[0]);
            while (subType && subType.supertype) {
              subType = LookupType(checkType.namespace, subType.supertype);
              if (subType) {
                let subtypes = this.templateSubTypes.slice();
                subtypes[0] = subType.name;
                let subtypeTemplateName = FormatTemplateTypename(checkType.templateBaseType, subtypes);
                let subtypeTemplate = LookupType(checkType.namespace, subtypeTemplateName);
                if (subtypeTemplate && !this.extendTypes.includes(subtypeTemplate))
                  this.extendTypes.push(subtypeTemplate);
              }
            }
          }
          checkIndex += 1;
        }
        return this.extendTypes;
      }
      formatDelegateSignature(wildcardName = null, wildcardType = null) {
        let decl = "";
        if (this.delegateReturn)
          decl += this.delegateReturn + " ";
        decl += this.name + "(";
        if (this.delegateArgs) {
          for (let i = 0; i < this.delegateArgs.length; ++i) {
            if (i > 0)
              decl += ", ";
            if (wildcardName && wildcardType && this.delegateArgs[i].name == wildcardName) {
              decl += this.delegateArgs[i].format(TransferTypeQualifiers(this.delegateArgs[i].typename, wildcardType.name));
            } else {
              decl += this.delegateArgs[i].format();
            }
          }
        }
        decl += ")";
        return decl;
      }
      getProperty(name, recurseSuper = true) {
        if (!recurseSuper || !this.hasExtendTypes()) {
          let prop = this.findFirstSymbol(name, DBAllowSymbol.Properties);
          if (prop instanceof DBProperty)
            return prop;
        } else {
          for (let extendType of this.getExtendTypesList()) {
            let prop = extendType.findFirstSymbol(name, DBAllowSymbol.Properties);
            if (prop instanceof DBProperty)
              return prop;
          }
        }
        return null;
      }
      getMethod(name, recurseSuper = true) {
        if (!recurseSuper || !this.hasExtendTypes()) {
          let method = this.findFirstSymbol(name, DBAllowSymbol.Functions);
          if (method instanceof DBMethod)
            return method;
        } else {
          for (let extendType of this.getExtendTypesList()) {
            let method = extendType.findFirstSymbol(name, DBAllowSymbol.Functions);
            if (method instanceof DBMethod)
              return method;
          }
        }
        return null;
      }
      getMethodWithIdHint(name, id, recurseSuper = true) {
        let fallback = null;
        let method = this.findFirstSymbol(name, DBAllowSymbol.Functions);
        if (method instanceof DBMethod) {
          if (method.id == id)
            return method;
          else
            fallback = method;
        }
        if (!recurseSuper)
          return fallback;
        if (!this.hasExtendTypes())
          return fallback;
        for (let extend of this.getExtendTypesList()) {
          if (extend == this)
            continue;
          let extendMethod = extend.getMethodWithIdHint(name, id, false);
          if (extendMethod) {
            if (extendMethod.id == id)
              return extendMethod;
            else if (!fallback)
              fallback = extendMethod;
          }
        }
        return fallback;
      }
      inheritsFrom(checktype) {
        let it = this;
        let dbCheck = LookupType(this.namespace, checktype);
        if (!dbCheck)
          return false;
        let depth = 0;
        while (it && depth < 100) {
          if (it == dbCheck)
            return true;
          if (it.supertype) {
            it = LookupType(it.namespace, it.supertype);
            depth += 1;
            continue;
          } else if (it.unrealsuper) {
            it = LookupType(it.namespace, it.unrealsuper);
            depth += 1;
            continue;
          } else {
            break;
          }
        }
        return false;
      }
      isValueType() {
        if (this.isPrimitive)
          return true;
        if (this.isStruct)
          return true;
        if (this.isEnum)
          return true;
        return false;
      }
      getInheritanceTypes() {
        let typeList = new Array();
        let check = this;
        while (check && typeList.indexOf(check) == -1) {
          typeList.push(check);
          check = LookupType(check.namespace, check.supertype);
        }
        return typeList;
      }
      canOverrideFromParent(methodname) {
        let checktype = this.supertype;
        let depth = 0;
        while (checktype && depth < 100) {
          let dbsuper = LookupType(this.namespace, checktype);
          if (!dbsuper)
            break;
          let method = dbsuper.getMethod(methodname, false);
          if (method) {
            if (!dbsuper.isUnrealType() || method.isBlueprintEvent)
              return true;
          }
          checktype = dbsuper.supertype;
          depth += 1;
        }
        return false;
      }
      forEachSymbol(func, recurseSuper = true) {
        if (!recurseSuper || !this.hasExtendTypes()) {
          for (let [_, syms] of this.symbols) {
            if (syms instanceof Array) {
              for (let sym of syms)
                func(sym);
            } else {
              func(syms);
            }
          }
        } else {
          for (let extendType of this.getExtendTypesList()) {
            for (let [_, syms] of extendType.symbols) {
              if (syms instanceof Array) {
                for (let sym of syms)
                  func(sym);
              } else {
                func(syms);
              }
            }
          }
        }
      }
      findFirstSymbol(name, allowSymbols = DBAllowSymbol.All) {
        for (let type of this.getExtendTypesList()) {
          let syms = type.symbols.get(name);
          if (syms instanceof Array) {
            for (let sym of syms) {
              if (FilterAllowsSymbol(sym, allowSymbols))
                return sym;
            }
          } else {
            if (FilterAllowsSymbol(syms, allowSymbols))
              return syms;
          }
        }
        return null;
      }
      findMethodByUnrealName(unrealName) {
        for (let type of this.getExtendTypesList()) {
          for (let [name, syms] of type.symbols) {
            if (syms instanceof Array) {
              for (let sym of syms) {
                if (sym instanceof DBMethod) {
                  if (sym.unrealName == unrealName)
                    return sym;
                }
              }
            } else if (syms instanceof DBMethod) {
              if (syms.unrealName == unrealName)
                return syms;
            }
          }
        }
        return null;
      }
      // NOTE: Prefix must be at least 2 characters
      findFirstSymbolWithPrefix(prefix, allowSymbols = DBAllowSymbol.All, caseSensitive = true, depth = 100) {
        if (prefix.length < 2)
          return null;
        let charPrefix = prefix.substring(0, 2).toLowerCase();
        for (let type of this.getExtendTypesList()) {
          let syms = type.symbolsByPrefix.get(charPrefix);
          if (syms && syms.length != 0) {
            for (let sym of syms) {
              if (!FilterAllowsSymbol(sym, allowSymbols))
                continue;
              if (caseSensitive) {
                if (sym.name.startsWith(prefix))
                  return sym;
              } else {
                if (sym.name.toLowerCase().startsWith(prefix.toLowerCase()))
                  return sym;
              }
            }
          }
        }
        return null;
      }
      findSymbols(name) {
        let result = [];
        for (let type of this.getExtendTypesList()) {
          let syms = type.symbols.get(name);
          if (syms instanceof Array) {
            for (let sym of syms) {
              result.push(sym);
            }
          } else {
            result.push(syms);
          }
        }
        return result;
      }
      findFunctionSymbolByParameterCount(name, parameterCount) {
        let match = null;
        for (let type of this.getExtendTypesList()) {
          let syms = type.symbols.get(name);
          if (syms instanceof Array) {
            for (let sym of syms) {
              if (sym instanceof DBMethod) {
                if (!match || sym.args.length == parameterCount && match.args.length != parameterCount || sym.args.length >= parameterCount && match.args.length < parameterCount || sym.args.length >= parameterCount && sym.args.length < match.args.length) {
                  match = sym;
                }
              }
            }
          } else {
            if (syms instanceof DBMethod) {
              if (!match || syms.args.length == parameterCount && match.args.length != parameterCount || syms.args.length >= parameterCount && match.args.length < parameterCount || syms.args.length >= parameterCount && syms.args.length < match.args.length) {
                match = syms;
              }
            }
          }
        }
        return match;
      }
      addSymbol(symbol) {
        symbol.containingType = this;
        symbol.namespace = this.namespace;
        {
          let syms = this.symbols.get(symbol.name);
          if (!syms) {
            this.symbols.set(symbol.name, symbol);
          } else if (syms instanceof Array) {
            syms.push(symbol);
          } else {
            this.symbols.set(symbol.name, [symbol, syms]);
          }
        }
        if (symbol.name.length > 2) {
          let prefix = symbol.name.substring(0, 2).toLowerCase();
          let prefixSyms = this.symbolsByPrefix.get(prefix);
          if (!prefixSyms) {
            prefixSyms = new Array();
            this.symbolsByPrefix.set(prefix, prefixSyms);
          }
          prefixSyms.push(symbol);
        }
      }
      removeSymbol(symbol) {
        {
          let syms = this.symbols.get(symbol.name);
          if (syms) {
            if (syms == symbol) {
              this.symbols.delete(symbol.name);
            } else if (syms instanceof Array) {
              let index = syms.indexOf(symbol);
              if (index != -1)
                syms.splice(index, 1);
            }
          }
        }
        if (symbol.name.length > 2) {
          let prefix = symbol.name.substring(0, 2).toLowerCase();
          let prefixSyms = this.symbolsByPrefix.get(prefix);
          if (prefixSyms) {
            let index = prefixSyms.indexOf(symbol);
            if (index != -1)
              prefixSyms.splice(index, 1);
          }
        }
      }
      getBaseMethod(name) {
        let checkSym = this.findFirstSymbol(name, DBAllowSymbol.FunctionsAndMixins);
        let baseFunction = checkSym;
        let checkType = this;
        while (checkType && checkSym) {
          checkType = checkType.getSuperType();
          if (checkType) {
            checkSym = checkType.findFirstSymbol(name, DBAllowSymbol.FunctionsAndMixins);
            if (checkSym)
              baseFunction = checkSym;
          } else {
            checkSym = null;
          }
        }
        return baseFunction;
      }
      getTypeClassification() {
        if (this.classification == DBTypeClassification.Unknown) {
          if (this.isDelegate)
            this.classification = DBTypeClassification.Delegate;
          else if (this.isEvent)
            this.classification = DBTypeClassification.Event;
          else if (this.isStruct)
            this.classification = DBTypeClassification.Struct;
          else if (this.isPrimitive)
            this.classification = DBTypeClassification.Primitive;
          else if (this.inheritsFrom("UActorComponent"))
            this.classification = DBTypeClassification.Component;
          else if (this.inheritsFrom("AActor"))
            this.classification = DBTypeClassification.Actor;
          else
            this.classification = DBTypeClassification.Other;
        }
        return this.classification;
      }
      getAccessSpecifier(name, create = true) {
        if (this.acccessSpecifiers) {
          for (let spec of this.acccessSpecifiers) {
            if (spec.name == name)
              return spec;
          }
        }
        if (create) {
          let spec = new DBAccessSpecifier();
          spec.name = name;
          spec.declaredType = this.name;
          if (this.acccessSpecifiers)
            this.acccessSpecifiers.push(spec);
          else
            this.acccessSpecifiers = [spec];
          return spec;
        }
        return null;
      }
      getQualifiedTypenameInNamespace(accessNamespace) {
        if (!this.namespace || this.namespace.isRootNamespace())
          return this.name;
        let typename = this.namespace.getQualifiedNamespace() + "::" + this.name;
        if (accessNamespace && !accessNamespace.isRootNamespace()) {
          let accessPrefix = accessNamespace.getQualifiedNamespace() + "::";
          if (typename.startsWith(accessPrefix))
            typename = typename.substring(accessPrefix.length);
        }
        return typename;
      }
    };
    exports2.DBType = DBType;
    var DBNamespaceDeclaration = class {
      constructor() {
        this.isNestedParent = false;
      }
    };
    exports2.DBNamespaceDeclaration = DBNamespaceDeclaration;
    var DBNamespace = class {
      constructor() {
        this.name = "";
        this.qualifiedNamespace = null;
        this.parentNamespace = null;
        this.childNamespaces = /* @__PURE__ */ new Map();
        this.childNamespacesByPrefix = /* @__PURE__ */ new Map();
        this.symbols = /* @__PURE__ */ new Map();
        this.symbolsByPrefix = /* @__PURE__ */ new Map();
        this.declarations = new Array();
      }
      // Get the full namespace starting at the root
      getQualifiedNamespace() {
        if (this.qualifiedNamespace !== null)
          return this.qualifiedNamespace;
        this.qualifiedNamespace = this.name;
        let checkParent = this.parentNamespace;
        while (checkParent) {
          if (!checkParent.isRootNamespace())
            this.qualifiedNamespace = checkParent.name + "::" + this.qualifiedNamespace;
          checkParent = checkParent.parentNamespace;
        }
        return this.qualifiedNamespace;
      }
      // Whether this namespace shadows a declared type
      isShadowingType() {
        if (!this.parentNamespace)
          return false;
        if (this.parentNamespace.findFirstSymbol(this.name, DBAllowSymbol.Types))
          return true;
        return false;
      }
      // Get which type this namespace is shadowing
      getShadowedType() {
        if (!this.parentNamespace)
          return null;
        let sym = this.parentNamespace.findFirstSymbol(this.name, DBAllowSymbol.Types);
        if (sym instanceof DBType)
          return sym;
        return null;
      }
      isRootNamespace() {
        return this.parentNamespace === null;
      }
      isChildNamespaceOf(parent) {
        let checkNamespace = this;
        while (checkNamespace) {
          if (checkNamespace == parent)
            return true;
          checkNamespace = checkNamespace.parentNamespace;
        }
        return false;
      }
      forEachSymbol(func) {
        for (let [_, syms] of this.symbols) {
          if (syms instanceof Array) {
            for (let sym of syms)
              func(sym);
          } else {
            func(syms);
          }
        }
      }
      findFirstSymbol(name, allowSymbols = DBAllowSymbol.All) {
        let syms = this.symbols.get(name);
        if (syms instanceof Array) {
          for (let sym of syms) {
            if (FilterAllowsSymbol(sym, allowSymbols))
              return sym;
          }
        } else {
          if (FilterAllowsSymbol(syms, allowSymbols))
            return syms;
        }
        return null;
      }
      findFirstSymbolWithPrefix(prefix, allowSymbols = DBAllowSymbol.All, caseSensitive = true) {
        if (prefix.length < 2)
          return null;
        let charPrefix = prefix.substring(0, 2).toLowerCase();
        let syms = this.symbolsByPrefix.get(charPrefix);
        if (syms && syms.length != 0) {
          for (let sym of syms) {
            if (!FilterAllowsSymbol(sym, allowSymbols))
              continue;
            if (caseSensitive) {
              if (sym.name.startsWith(prefix))
                return sym;
            } else {
              if (sym.name.toLowerCase().startsWith(prefix.toLowerCase()))
                return sym;
            }
          }
        }
        return null;
      }
      findSymbols(name, allowSymbol = DBAllowSymbol.All) {
        let result = [];
        let syms = this.symbols.get(name);
        if (syms instanceof Array) {
          for (let sym of syms) {
            if (FilterAllowsSymbol(sym, allowSymbol))
              result.push(sym);
          }
        } else {
          if (FilterAllowsSymbol(syms, allowSymbol))
            result.push(syms);
        }
        return result;
      }
      findSymbolsWithPrefix(prefix, allowSymbols = DBAllowSymbol.All, caseSensitive = true) {
        if (prefix.length < 2)
          return null;
        let result = [];
        let charPrefix = prefix.substring(0, 2).toLowerCase();
        let syms = this.symbolsByPrefix.get(charPrefix);
        if (syms && syms.length != 0) {
          for (let sym of syms) {
            if (!FilterAllowsSymbol(sym, allowSymbols))
              continue;
            if (caseSensitive) {
              if (sym.name.startsWith(prefix))
                result.push(sym);
            } else {
              if (sym.name.toLowerCase().startsWith(prefix.toLowerCase()))
                result.push(sym);
            }
          }
        }
        return result;
      }
      findChildNamespace(name) {
        let childNamespace = this.childNamespaces.get(name);
        return childNamespace;
      }
      findChildNamespacesWithPrefix(prefix, caseSensitive = true) {
        if (prefix.length < 2)
          return null;
        let result = new Array();
        let charPrefix = prefix.substring(0, 2).toLowerCase();
        let namespaces = this.childNamespacesByPrefix.get(charPrefix);
        if (namespaces && namespaces.length != 0) {
          for (let ns of namespaces) {
            if (caseSensitive) {
              if (ns.name.startsWith(prefix))
                result.push(ns);
            } else {
              if (ns.name.toLowerCase().startsWith(prefix.toLowerCase()))
                result.push(ns);
            }
          }
        }
        return result;
      }
      addSymbol(symbol) {
        symbol.containingType = null;
        symbol.namespace = this;
        {
          let syms = this.symbols.get(symbol.name);
          if (!syms) {
            this.symbols.set(symbol.name, symbol);
          } else if (syms instanceof Array) {
            syms.push(symbol);
          } else {
            this.symbols.set(symbol.name, [symbol, syms]);
          }
        }
        if (symbol.name.length > 2) {
          let prefix = symbol.name.substring(0, 2).toLowerCase();
          let prefixSyms = this.symbolsByPrefix.get(prefix);
          if (!prefixSyms) {
            prefixSyms = new Array();
            this.symbolsByPrefix.set(prefix, prefixSyms);
          }
          prefixSyms.push(symbol);
        }
      }
      removeSymbol(symbol) {
        {
          let syms = this.symbols.get(symbol.name);
          if (syms) {
            if (syms == symbol) {
              this.symbols.delete(symbol.name);
            } else if (syms instanceof Array) {
              let index = syms.indexOf(symbol);
              if (index != -1)
                syms.splice(index, 1);
            }
          }
        }
        if (symbol.name.length > 2) {
          let prefix = symbol.name.substring(0, 2).toLowerCase();
          let prefixSyms = this.symbolsByPrefix.get(prefix);
          if (prefixSyms) {
            let index = prefixSyms.indexOf(symbol);
            if (index != -1)
              prefixSyms.splice(index, 1);
          }
        }
      }
      addChildNamespace(childNS) {
        childNS.parentNamespace = this;
        this.childNamespaces.set(childNS.name, childNS);
        NamespacesByFullName.set(childNS.getQualifiedNamespace(), childNS);
        if (childNS.name.length > 2) {
          let prefix = childNS.name.substring(0, 2).toLowerCase();
          let prefixSyms = this.childNamespacesByPrefix.get(prefix);
          if (!prefixSyms) {
            prefixSyms = new Array();
            this.childNamespacesByPrefix.set(prefix, prefixSyms);
          }
          prefixSyms.push(childNS);
        }
      }
      removeChildNamespace(childNS) {
        let existingChild = this.childNamespaces.get(childNS.name);
        if (existingChild == childNS)
          this.childNamespaces.delete(childNS.name);
        let existingNS = NamespacesByFullName.get(childNS.getQualifiedNamespace());
        if (existingNS == childNS) {
          NamespacesByFullName.delete(childNS.getQualifiedNamespace());
        }
        childNS.parentNamespace = null;
        childNS.qualifiedNamespace = null;
        if (childNS.name.length > 2) {
          let prefix = childNS.name.substring(0, 2).toLowerCase();
          let prefixSyms = this.childNamespacesByPrefix.get(prefix);
          if (prefixSyms) {
            let index = prefixSyms.indexOf(childNS);
            if (index != -1)
              prefixSyms.splice(index, 1);
          }
        }
      }
      addScriptDeclaration(decl) {
        this.declarations.push(decl);
      }
      removeScriptDeclarations(moduleName) {
        for (let i = this.declarations.length - 1; i >= 0; --i) {
          if (this.declarations[i].declaredModule == moduleName)
            this.declarations.splice(i, 1);
        }
      }
      removeSymbolsDeclaredIn(declaredModule, removeSymbols = DBAllowSymbol.All) {
        let oldSymbols = this.symbols;
        this.symbols = /* @__PURE__ */ new Map();
        this.symbolsByPrefix = /* @__PURE__ */ new Map();
        for (let [_, syms] of oldSymbols) {
          if (syms instanceof Array) {
            for (let sym of syms) {
              if (sym.declaredModule == declaredModule && FilterAllowsSymbol(sym, removeSymbols))
                continue;
              this.addSymbol(sym);
            }
          } else {
            if (syms.declaredModule == declaredModule && FilterAllowsSymbol(syms, removeSymbols))
              continue;
            this.addSymbol(syms);
          }
        }
      }
      getDeclarationInModule(declaredModule) {
        for (let decl of this.declarations) {
          if (decl.declaredModule == declaredModule)
            return decl;
        }
        return null;
      }
      getFirstScriptDeclaration() {
        for (let decl of this.declarations) {
          if (decl.declaredModule)
            return decl;
        }
        return null;
      }
      getCppDeclaration() {
        for (let decl of this.declarations) {
          if (decl.declaredModule === null)
            return decl;
        }
        return null;
      }
    };
    exports2.DBNamespace = DBNamespace;
    var DBAccessSpecifier = class {
      constructor() {
        this.isDeclared = false;
        this.isPrivate = false;
        this.isProtected = false;
        this.bAnyReadOnly = false;
        this.bAnyEditDefaults = false;
        this.moduleOffsetEnd = -1;
      }
      getAccess(fromType, fromFunction) {
        if (fromType == null && fromFunction == null)
          return [this.bAnyReadOnly, false, this.bAnyEditDefaults];
        if (fromType) {
          if (this.isProtected) {
            if (fromType.inheritsFrom(this.declaredType))
              return [true, true, true];
          } else {
            if (fromType.name == this.declaredType)
              return [true, true, true];
          }
        }
        let read = false;
        let write = false;
        let edit = false;
        if (this.bAnyEditDefaults)
          edit = true;
        if (this.bAnyReadOnly)
          read = true;
        if (this.permissions) {
          for (let cls of this.permissions) {
            let clsApplies = false;
            if (fromType) {
              if (cls.bInherited)
                clsApplies = fromType.inheritsFrom(cls.accessName);
              else
                clsApplies = fromType.name == cls.accessName;
            } else if (fromFunction) {
              clsApplies = fromFunction.name == cls.accessName;
            }
            if (clsApplies) {
              if (cls.bReadOnly) {
                read = true;
                if (cls.bEditDefaults)
                  edit = true;
              } else {
                if (cls.bEditDefaults) {
                  edit = true;
                } else {
                  read = true;
                  edit = true;
                  write = true;
                }
              }
            }
          }
        }
        return [read, write, edit];
      }
    };
    exports2.DBAccessSpecifier = DBAccessSpecifier;
    var DBAccessPermission = class {
      constructor() {
        this.bInherited = false;
        this.bReadOnly = false;
        this.bEditDefaults = false;
      }
    };
    exports2.DBAccessPermission = DBAccessPermission;
    var DirtyTypeCacheId = 0;
    function OnDirtyTypeCaches() {
      DirtyTypeCacheId++;
    }
    exports2.OnDirtyTypeCaches = OnDirtyTypeCaches;
    var UnrealTypesLoaded = false;
    var RootNamespace = new DBNamespace();
    var TypesById = /* @__PURE__ */ new Map();
    var NamespacesByFullName = /* @__PURE__ */ new Map([["", RootNamespace]]);
    var TypesByName = /* @__PURE__ */ new Map();
    var NextMethodId = 1;
    var NextTypeId = 1;
    function CleanTypeName(typename) {
      if (typename.startsWith("const "))
        typename = typename.substring(6);
      if (typename.endsWith("&"))
        typename = typename.substring(0, typename.length - 1);
      else if (typename.endsWith("&out"))
        typename = typename.substring(0, typename.length - 4);
      else if (typename.endsWith("&in"))
        typename = typename.substring(0, typename.length - 3);
      else if (typename.endsWith("&inout"))
        typename = typename.substring(0, typename.length - 6);
      else if (typename.endsWith("@"))
        typename = typename.substring(0, typename.length - 1);
      return typename;
    }
    exports2.CleanTypeName = CleanTypeName;
    function TypenameEquals(left, right) {
      return CleanTypeName(left) == CleanTypeName(right);
    }
    exports2.TypenameEquals = TypenameEquals;
    function TransferTypeQualifiers(typename, newtype) {
      if (typename.startsWith("const "))
        newtype = "const " + newtype;
      if (typename.endsWith("&"))
        newtype = newtype + "&";
      else if (typename.endsWith("&out"))
        newtype = newtype + "&out";
      else if (typename.endsWith("&in"))
        newtype = newtype + "&in";
      else if (typename.endsWith("&inout"))
        newtype = newtype + "&inout";
      return newtype;
    }
    exports2.TransferTypeQualifiers = TransferTypeQualifiers;
    var re_template = /([A-Za-z_0-9]+)\<(([A-Za-z_0-9:]+\s*(<[A-Za-z_0-9,:\s]+>)?,?)+)\>/;
    function ReplaceTemplateType(typename, templateTypes, actualTypes) {
      let cleanType = CleanTypeName(typename);
      for (let i = 0; i < templateTypes.length; ++i) {
        if (cleanType == templateTypes[i]) {
          return TransferTypeQualifiers(typename, actualTypes[i]);
        }
      }
      if (cleanType.indexOf("<") != -1) {
        let match = cleanType.match(re_template);
        if (match != null) {
          let basetype = match[1];
          let newtype = "";
          for (let subtype of match[2].split(",")) {
            subtype = subtype.trim();
            let templIndex = templateTypes.indexOf(subtype);
            if (templIndex != -1)
              subtype = actualTypes[templIndex];
            if (newtype.length != 0)
              newtype += ",";
            newtype += subtype;
          }
          return TransferTypeQualifiers(typename, basetype + "<" + newtype + ">");
        }
      }
      return typename;
    }
    exports2.ReplaceTemplateType = ReplaceTemplateType;
    function GetTypeByName(typename) {
      let found = TypesByName.get(typename);
      if (found instanceof Array)
        return found[0];
      else
        return found;
    }
    exports2.GetTypeByName = GetTypeByName;
    function GetTypeById(typeid) {
      return TypesById.get(typeid);
    }
    exports2.GetTypeById = GetTypeById;
    function GetAllTypesById() {
      return TypesById;
    }
    exports2.GetAllTypesById = GetAllTypesById;
    function GetAllNamespaces() {
      return NamespacesByFullName;
    }
    exports2.GetAllNamespaces = GetAllNamespaces;
    function SplitNamespace(identifier) {
      return identifier.split("::");
    }
    function LookupNamespace(namespace, name) {
      if (!namespace)
        namespace = RootNamespace;
      if (!name || name.length == 0)
        return namespace;
      let namespaceIndex = name.indexOf("::");
      if (namespaceIndex == -1) {
        let checkNamespace2 = namespace;
        while (checkNamespace2) {
          let targetNamespace = checkNamespace2.findChildNamespace(name);
          if (targetNamespace)
            return targetNamespace;
          checkNamespace2 = checkNamespace2.parentNamespace;
        }
        return null;
      }
      if (namespaceIndex == 0) {
        namespace = RootNamespace;
        name = name.substring(2);
      }
      let nameParts = SplitNamespace(name);
      let checkNamespace = namespace;
      while (checkNamespace) {
        let targetNamespace = checkNamespace;
        for (let part of nameParts) {
          targetNamespace = targetNamespace.findChildNamespace(part.trim());
          if (!targetNamespace)
            break;
        }
        if (targetNamespace)
          return targetNamespace;
        checkNamespace = checkNamespace.parentNamespace;
      }
    }
    exports2.LookupNamespace = LookupNamespace;
    function LookupNamespacesWithPrefix(namespace, prefix, caseSensitive = true) {
      if (!namespace)
        namespace = RootNamespace;
      if (!prefix || prefix.length < 2)
        return null;
      let checkNamespace = namespace;
      let result = null;
      while (checkNamespace) {
        let children = checkNamespace.findChildNamespacesWithPrefix(prefix);
        if (children) {
          if (result)
            result = result.concat(children);
          else
            result = children;
        }
        checkNamespace = checkNamespace.parentNamespace;
      }
      return result;
    }
    exports2.LookupNamespacesWithPrefix = LookupNamespacesWithPrefix;
    function GetRootNamespace() {
      return RootNamespace;
    }
    exports2.GetRootNamespace = GetRootNamespace;
    function DeclareNamespace(namespace, name, decl) {
      if (!namespace)
        namespace = RootNamespace;
      let ns = namespace.findChildNamespace(name);
      if (!ns) {
        ns = new DBNamespace();
        ns.name = name;
        ns.parentNamespace = RootNamespace;
        namespace.addChildNamespace(ns);
      }
      ns.addScriptDeclaration(decl);
      return ns;
    }
    exports2.DeclareNamespace = DeclareNamespace;
    function RemoveNamespaceDeclaration(namespace, moduleName) {
      namespace.removeScriptDeclarations(moduleName);
      if (namespace.declarations.length == 0 && namespace.parentNamespace)
        namespace.parentNamespace.removeChildNamespace(namespace);
    }
    exports2.RemoveNamespaceDeclaration = RemoveNamespaceDeclaration;
    function LookupType(namespace, typename) {
      if (!typename)
        return null;
      let identifier = CleanTypeName(typename);
      let namespaceIndex = identifier.indexOf("::");
      if (namespaceIndex == -1) {
        let found = TypesByName.get(identifier);
        if (found instanceof Array)
          found = found[0];
        if (found) {
          if (!namespace || !found.namespace || namespace == found.namespace || namespace.isChildNamespaceOf(found.namespace))
            return found;
        }
      } else {
        if (!namespace)
          namespace = RootNamespace;
        if (namespaceIndex == 0) {
          namespace = RootNamespace;
          identifier = identifier.substring(2);
        }
        let nameParts = SplitNamespace(identifier);
        let finalIdentifier = nameParts[nameParts.length - 1];
        let checkNamespace = namespace;
        while (checkNamespace) {
          let targetNamespace = checkNamespace;
          for (let i = 0, count = nameParts.length - 1; i < count; ++i) {
            targetNamespace = targetNamespace.findChildNamespace(nameParts[i].trim());
            if (!targetNamespace)
              break;
          }
          if (targetNamespace) {
            let type = targetNamespace.findFirstSymbol(finalIdentifier, DBAllowSymbol.Types);
            if (type instanceof DBType)
              return type;
          }
          checkNamespace = checkNamespace.parentNamespace;
        }
      }
      if (identifier.indexOf("<") != -1) {
        let match = identifier.match(re_template);
        if (match != null) {
          let basetype = match[1];
          let subtypes = match[2].split(",").map(function(s) {
            return s.trim();
          });
          let dbbasetype = LookupType(namespace, basetype);
          if (!dbbasetype || !dbbasetype.isTemplateType())
            return null;
          let inst = dbbasetype.createTemplateInstance(subtypes);
          if (!inst)
            return null;
          inst.name = identifier;
          if (!inst)
            return null;
          AddTypeToDatabase(namespace, inst);
          return inst;
        }
      }
      return null;
    }
    exports2.LookupType = LookupType;
    function FormatTemplateTypename(baseType, subtypes) {
      let typename = baseType;
      if (subtypes.length == 0)
        return typename;
      typename += "<";
      for (let i = 0; i < subtypes.length; ++i) {
        if (i != 0)
          typename += ",";
        typename += subtypes[i];
      }
      typename += ">";
      return typename;
    }
    exports2.FormatTemplateTypename = FormatTemplateTypename;
    function LookupGlobalSymbol(namespace, name, allowSymbol = DBAllowSymbol.All) {
      if (!name)
        return [];
      let identifier = name;
      if (!namespace)
        namespace = RootNamespace;
      let result = null;
      let namespaceIndex = identifier.indexOf("::");
      if (namespaceIndex == -1) {
        let checkNamespace2 = namespace;
        while (checkNamespace2) {
          let symbols = checkNamespace2.findSymbols(identifier, allowSymbol);
          if (symbols) {
            if (result)
              result = result.concat(symbols);
            else
              result = symbols;
          }
          checkNamespace2 = checkNamespace2.parentNamespace;
        }
        return result;
      }
      if (namespaceIndex == 0) {
        namespace = RootNamespace;
        identifier = identifier.substring(2);
      }
      let nameParts = SplitNamespace(identifier);
      let finalIdentifier = nameParts[nameParts.length - 1];
      let checkNamespace = namespace;
      while (checkNamespace) {
        let targetNamespace = checkNamespace;
        for (let i = 0, count = nameParts.length - 1; i < count; ++i) {
          targetNamespace = targetNamespace.findChildNamespace(nameParts[i].trim());
          if (!targetNamespace)
            break;
        }
        if (targetNamespace) {
          let symbols = targetNamespace.findSymbols(finalIdentifier, allowSymbol);
          if (symbols) {
            if (result)
              result = result.concat(symbols);
            else
              result = symbols;
          }
        }
        checkNamespace = checkNamespace.parentNamespace;
      }
      return result;
    }
    exports2.LookupGlobalSymbol = LookupGlobalSymbol;
    function LookupGlobalSymbolsWithPrefix(namespace, prefix, allowSymbol = DBAllowSymbol.All, caseSensitive = true) {
      if (!prefix || prefix.length < 2)
        return [];
      if (!namespace)
        namespace = RootNamespace;
      if (!namespace)
        namespace = RootNamespace;
      let result = null;
      let checkNamespace = namespace;
      while (checkNamespace) {
        let symbols = checkNamespace.findSymbolsWithPrefix(prefix, allowSymbol, caseSensitive);
        if (symbols) {
          if (result)
            result = result.concat(symbols);
          else
            result = symbols;
        }
        checkNamespace = checkNamespace.parentNamespace;
      }
      return result;
    }
    exports2.LookupGlobalSymbolsWithPrefix = LookupGlobalSymbolsWithPrefix;
    function HasTypeWithPrefix(namespace, typenamePrefix, caseSensitive = true) {
      if (!typenamePrefix || typenamePrefix.length < 2)
        return true;
      if (!namespace)
        namespace = RootNamespace;
      let checkNamespace = namespace;
      while (checkNamespace) {
        let symbols = checkNamespace.findSymbolsWithPrefix(typenamePrefix, DBAllowSymbol.Types, caseSensitive);
        if (symbols && symbols.length != 0)
          return true;
        checkNamespace = checkNamespace.parentNamespace;
      }
      return false;
    }
    exports2.HasTypeWithPrefix = HasTypeWithPrefix;
    function IsPrimitive(typename) {
      let type = LookupType(null, typename);
      if (!type)
        return false;
      return type.isPrimitive;
    }
    exports2.IsPrimitive = IsPrimitive;
    var DatabaseFloatIsFloat64 = false;
    var PrimitiveAliases = /* @__PURE__ */ new Map();
    function AddPrimitiveTypes(floatIsFloat64) {
      DatabaseFloatIsFloat64 = floatIsFloat64;
      PrimitiveAliases.clear();
      PrimitiveAliases.set("int", "int32");
      PrimitiveAliases.set("int32", "int32");
      PrimitiveAliases.set("int64", "int64");
      PrimitiveAliases.set("uint", "uint32");
      PrimitiveAliases.set("uint32", "uint32");
      PrimitiveAliases.set("uint64", "uint64");
      PrimitiveAliases.set("int8", "int8");
      PrimitiveAliases.set("uint8", "uint8");
      PrimitiveAliases.set("int16", "int16");
      PrimitiveAliases.set("uint16", "uint16");
      PrimitiveAliases.set("bool", "bool");
      if (DatabaseFloatIsFloat64)
        PrimitiveAliases.set("float", "float64");
      else
        PrimitiveAliases.set("float", "float32");
      PrimitiveAliases.set("float32", "float32");
      PrimitiveAliases.set("float64", "float64");
      PrimitiveAliases.set("double", "float64");
      for (let [primtype, alias] of PrimitiveAliases) {
        let dbtype = new DBType().initEmpty(primtype);
        dbtype.isPrimitive = true;
        AddUnrealTypeToDatabase(null, dbtype);
      }
    }
    exports2.AddPrimitiveTypes = AddPrimitiveTypes;
    function ArePrimitiveTypesEquivalent(typenameA, typenameB) {
      let aliasA = PrimitiveAliases.get(typenameA);
      let aliasB = PrimitiveAliases.get(typenameB);
      return aliasA && aliasB && aliasA == aliasB;
    }
    exports2.ArePrimitiveTypesEquivalent = ArePrimitiveTypesEquivalent;
    function IsPrimitiveFloatType(typename) {
      let realType = PrimitiveAliases.get(typename);
      return realType == "float32" || realType == "float64";
    }
    exports2.IsPrimitiveFloatType = IsPrimitiveFloatType;
    function AddTypesFromUnreal(input) {
      for (let key in input) {
        let type;
        if ("templateSpecialization" in input[key]) {
          let existingType = GetTypeByName(key);
          if (existingType)
            RemoveTypeFromDatabase(existingType);
          type = LookupType(null, key);
        } else {
          type = new DBType();
        }
        type.fromJSON(key, input[key]);
        if (type.name.startsWith("__")) {
          if (type.isEnum) {
            type.name = type.name.substring(2);
            AddUnrealTypeToDatabase(null, type);
          } else {
            let decl = new DBNamespaceDeclaration();
            decl.declaredModule = null;
            decl.isNestedParent = false;
            let identifier = type.name.substring(2);
            let parentNamespace = null;
            let namespaceIndex = identifier.indexOf("::");
            if (namespaceIndex != -1) {
              let parts = identifier.split("::");
              identifier = parts[parts.length - 1];
              for (let i = 0, count = parts.length - 1; i < count; ++i) {
                let parentDecl = new DBNamespaceDeclaration();
                parentDecl.isNestedParent = true;
                parentNamespace = DeclareNamespace(parentNamespace, parts[i], parentDecl);
              }
            }
            let ns = LookupNamespace(parentNamespace, identifier);
            if (!ns) {
              ns = DeclareNamespace(parentNamespace, identifier, decl);
            } else {
              ns.removeSymbolsDeclaredIn(null, ~DBAllowSymbol.Types);
              ns.removeScriptDeclarations(null);
              ns.addScriptDeclaration(decl);
            }
            for (let [name, sym] of type.symbols) {
              if (sym instanceof Array) {
                for (let symElem of sym)
                  ns.addSymbol(symElem);
              } else
                ns.addSymbol(sym);
            }
          }
        } else {
          AddUnrealTypeToDatabase(null, type);
        }
      }
    }
    exports2.AddTypesFromUnreal = AddTypesFromUnreal;
    function HasTypesFromUnreal() {
      return UnrealTypesLoaded;
    }
    exports2.HasTypesFromUnreal = HasTypesFromUnreal;
    function FinishTypesFromUnreal() {
      UnrealTypesLoaded = true;
      let systemLib = RootNamespace.findChildNamespace("System");
      if (systemLib) {
        for (let functionName of [
          "SetTimer",
          "SetTimerForNextTick",
          "ClearTimer",
          "PauseTimer",
          "UnPauseTimer",
          "IsTimerActive",
          "IsTimerPaused",
          "TimerExists",
          "GetTimerElapsedTime",
          "GetTimerRemainingTime"
        ]) {
          let timerFunc = systemLib.findFirstSymbol(functionName, DBAllowSymbol.Functions);
          if (timerFunc instanceof DBMethod) {
            timerFunc.isDelegateBindFunction = true;
            timerFunc.delegateBindType = "FTimerDynamicDelegate";
            timerFunc.delegateObjectParam = 0;
            timerFunc.delegateFunctionParam = 1;
          }
        }
      }
      let linearColorConstructors = RootNamespace.findSymbols("FLinearColor", DBAllowSymbol.Functions);
      for (let method of linearColorConstructors) {
        if (method instanceof DBMethod)
          method.methodAnnotation = DBMethodAnnotation.IsLinearColor;
      }
      let linearColorNS = RootNamespace.findChildNamespace("FLinearColor");
      if (linearColorNS) {
        let fromHexFunction = linearColorNS.findFirstSymbol("MakeFromHex", DBAllowSymbol.Functions);
        if (fromHexFunction instanceof DBMethod)
          fromHexFunction.methodAnnotation = DBMethodAnnotation.IsHexColor;
      }
    }
    exports2.FinishTypesFromUnreal = FinishTypesFromUnreal;
    function AddTypeToDatabase(namespace, dbtype) {
      if (!namespace)
        namespace = RootNamespace;
      dbtype.namespace = namespace;
      dbtype.typeid = NextTypeId++;
      namespace.addSymbol(dbtype);
      TypesById.set(dbtype.typeid, dbtype);
      let found = TypesByName.get(dbtype.name);
      if (!found)
        TypesByName.set(dbtype.name, dbtype);
      else if (found instanceof Array)
        found.splice(0, 0, dbtype);
      else
        TypesByName.set(dbtype.name, [dbtype, found]);
      OnDirtyTypeCaches();
    }
    exports2.AddTypeToDatabase = AddTypeToDatabase;
    function AddUnrealTypeToDatabase(namespace, dbtype) {
      if (!namespace)
        namespace = RootNamespace;
      let existingTypes = namespace.findSymbols(dbtype.name, DBAllowSymbol.Types);
      for (let previousType of existingTypes) {
        if (previousType instanceof DBType) {
          if (!previousType.declaredModule)
            RemoveTypeFromDatabase(previousType);
        }
      }
      AddTypeToDatabase(namespace, dbtype);
    }
    exports2.AddUnrealTypeToDatabase = AddUnrealTypeToDatabase;
    function RemoveTypeFromDatabase(dbtype) {
      if (!dbtype.namespace)
        return;
      dbtype.namespace.removeSymbol(dbtype);
      dbtype.namespace = null;
      TypesById.delete(dbtype.typeid);
      let found = TypesByName.get(dbtype.name);
      if (found == dbtype) {
        TypesByName.delete(dbtype.name);
      } else if (found instanceof Array) {
        let index = found.indexOf(dbtype);
        if (index != -1) {
          found.splice(index, 1);
          if (found.length == 1)
            TypesByName.set(dbtype.name, found[0]);
          else if (found.length == 0)
            TypesByName.delete(dbtype.name);
        }
      }
      OnDirtyTypeCaches();
    }
    exports2.RemoveTypeFromDatabase = RemoveTypeFromDatabase;
    var re_comment_star_start = /^[ \t]*\*+([ \t]|\r?\n)/gi;
    var re_comment_star_end = /[\r\n]+[ \t]*\*+[ \t]*/gi;
    function FormatDocumentationComment(doc) {
      doc = doc.replace(re_comment_star_end, "\n");
      doc = doc.replace(re_comment_star_start, " ");
      doc = doc.trim();
      return doc;
    }
    exports2.FormatDocumentationComment = FormatDocumentationComment;
  }
});

// unreal-angelscript-lsp/language-server/out/generated_code.js
var require_generated_code = __commonJS({
  "unreal-angelscript-lsp/language-server/out/generated_code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProcessScriptTypeGeneratedCode = exports2.GetProjectCodeGenerationSettings = void 0;
    var scriptfiles2 = require_as_parser();
    var typedb2 = require_database();
    var ProjectCodeGenerationSettings = {
      enable: false,
      generators: []
    };
    function GetProjectCodeGenerationSettings() {
      return ProjectCodeGenerationSettings;
    }
    exports2.GetProjectCodeGenerationSettings = GetProjectCodeGenerationSettings;
    function ProcessScriptTypeGeneratedCode(dbtype, asmodule) {
      if (dbtype.isEvent || dbtype.isDelegate)
        AddGeneratedCodeForDelegate(dbtype, asmodule);
      if (!dbtype.isStruct && !dbtype.isEnum) {
        let decl = new typedb2.DBNamespaceDeclaration();
        decl.declaredModule = dbtype.declaredModule;
        decl.declaredOffset = dbtype.moduleOffset;
        decl.declaredOffsetEnd = dbtype.moduleOffsetEnd;
        decl.scopeOffsetStart = dbtype.moduleScopeStart;
        decl.scopeOffsetEnd = dbtype.moduleScopeEnd;
        let nsType = typedb2.DeclareNamespace(dbtype.namespace, dbtype.name, decl);
        AddGeneratedCodeForUObject(asmodule, dbtype, nsType);
        if (dbtype.inheritsFrom("UActorComponent"))
          AddGeneratedCodeForUActorComponent(asmodule, dbtype, nsType);
        if (dbtype.inheritsFrom("AActor"))
          AddGeneratedCodeForAActor(asmodule, dbtype, nsType);
        if (dbtype.inheritsFrom("USubsystem"))
          AddGeneratedCodeForSubsystem(asmodule, dbtype, nsType);
        if (scriptfiles2.GetScriptSettings().useAngelscriptHaze)
          AddHazeGeneratedCode(asmodule, dbtype, nsType);
        if (ProjectCodeGenerationSettings.enable) {
          for (let generator of ProjectCodeGenerationSettings.generators) {
            if (dbtype.inheritsFrom(generator.derivedFrom)) {
              ApplyProjectGeneratedCode(asmodule, dbtype, nsType, generator);
            }
          }
        }
        asmodule.namespaces.push(nsType);
      }
    }
    exports2.ProcessScriptTypeGeneratedCode = ProcessScriptTypeGeneratedCode;
    function AddGlobalFunction(asmodule, dbtype, namespace, name) {
      let method = new typedb2.DBMethod();
      method.name = name;
      method.declaredModule = dbtype.declaredModule;
      method.moduleOffset = dbtype.moduleOffset;
      method.isAutoGenerated = true;
      namespace.addSymbol(method);
      asmodule.globalSymbols.push(method);
      return method;
    }
    function AddMethod(dbtype, name) {
      let method = new typedb2.DBMethod();
      method.name = name;
      method.declaredModule = dbtype.declaredModule;
      method.moduleOffset = dbtype.moduleOffset;
      method.isAutoGenerated = true;
      dbtype.addSymbol(method);
      return method;
    }
    function AddProperty(dbtype, name) {
      let prop = new typedb2.DBProperty();
      prop.name = name;
      prop.declaredModule = dbtype.declaredModule;
      prop.moduleOffset = dbtype.moduleOffset;
      prop.isAutoGenerated = true;
      dbtype.addSymbol(prop);
      return prop;
    }
    function AddGeneratedCodeForUObject(asmodule, dbtype, nsType) {
      if (!scriptfiles2.GetScriptSettings().deprecateStaticClass && !scriptfiles2.GetScriptSettings().disallowStaticClass) {
        let method = AddGlobalFunction(asmodule, dbtype, nsType, "StaticClass");
        method.returnType = "UClass";
        method.documentation = "Gets the descriptor for the class generated for the specified type.";
        method.args = [];
      }
    }
    function AddGeneratedCodeForUActorComponent(asmodule, dbtype, nsType) {
      {
        let method = AddGlobalFunction(asmodule, dbtype, nsType, "Get");
        method.returnType = dbtype.name;
        method.documentation = "Get the component of this type from an actor. Specified name is optional.";
        method.args = [
          new typedb2.DBArg().init("AActor", "Actor"),
          new typedb2.DBArg().init("FName", "WithName", "NAME_None")
        ];
      }
      {
        let method = AddGlobalFunction(asmodule, dbtype, nsType, "GetOrCreate");
        method.returnType = dbtype.name;
        method.documentation = "Get a component of a particular type on an actor, create it if it doesn't exist. Specified name is optional.";
        method.args = [
          new typedb2.DBArg().init("AActor", "Actor"),
          new typedb2.DBArg().init("FName", "WithName", "NAME_None")
        ];
      }
      {
        let method = AddGlobalFunction(asmodule, dbtype, nsType, "Create");
        method.returnType = dbtype.name;
        method.documentation = "Always create a new component of this type on an actor.";
        method.args = [
          new typedb2.DBArg().init("AActor", "Actor"),
          new typedb2.DBArg().init("FName", "WithName", "NAME_None")
        ];
      }
    }
    function AddGeneratedCodeForAActor(asmodule, dbtype, nsType) {
      if (!scriptfiles2.GetScriptSettings().disallowActorGenerics && !scriptfiles2.GetScriptSettings().deprecateActorGenerics) {
        let method = AddGlobalFunction(asmodule, dbtype, nsType, "Spawn");
        method.returnType = dbtype.name;
        method.documentation = "Spawn a new actor of this type into the world.";
        method.args = [
          new typedb2.DBArg().init("FVector", "Location", "FVector::ZeroVector"),
          new typedb2.DBArg().init("FRotator", "Rotation", "FRotator::ZeroRotator"),
          new typedb2.DBArg().init("FName", "Name", "NAME_None"),
          new typedb2.DBArg().init("bool", "bDeferredSpawn", "false"),
          new typedb2.DBArg().init("ULevel", "Level", "nullptr")
        ];
      }
    }
    function AddGeneratedCodeForSubsystem(asmodule, dbtype, nsType) {
      if (dbtype.inheritsFrom("ULocalPlayerSubsystem")) {
        {
          let method = AddGlobalFunction(asmodule, dbtype, nsType, "Get");
          method.returnType = dbtype.name;
          method.documentation = "Get the " + dbtype.getDisplayName() + " subsystem for this local player.";
          method.args = [
            new typedb2.DBArg().init("ULocalPlayer", "LocalPlayer")
          ];
        }
        {
          let method = AddGlobalFunction(asmodule, dbtype, nsType, "Get");
          method.returnType = dbtype.name;
          method.documentation = "Get the " + dbtype.getDisplayName() + " subsystem for this player controller.";
          method.args = [
            new typedb2.DBArg().init("APlayerController", "PlayerController")
          ];
        }
      } else {
        let method = AddGlobalFunction(asmodule, dbtype, nsType, "Get");
        method.returnType = dbtype.name;
        method.documentation = "Get the relevant " + dbtype.getDisplayName() + " subsystem.";
        method.args = [];
      }
    }
    function AddGeneratedCodeForDelegate(dbtype, asmodule) {
      {
        let method = AddMethod(dbtype, "IsBound");
        method.returnType = "bool";
        method.documentation = "Whether the anything is bound to the delegate.";
        method.args = [];
      }
      {
        let method = AddMethod(dbtype, "Clear");
        method.returnType = "void";
        method.documentation = "Remove all bindings from the delegate.";
        method.args = [];
      }
      if (dbtype.isEvent) {
        {
          let method = AddMethod(dbtype, "Broadcast");
          method.returnType = dbtype.delegateReturn;
          method.documentation = "Broadcast event to all existing bindings.";
          method.args = new Array();
          for (let delegateArg of dbtype.delegateArgs) {
            let arg = new typedb2.DBArg();
            arg.name = delegateArg.name;
            arg.typename = delegateArg.typename;
            method.args.push(arg);
          }
        }
        {
          let method = AddMethod(dbtype, "AddUFunction");
          method.returnType = "void";
          method.documentation = "Add a new binding to this event. Make sure the function you're binding is a UFUNCTION().";
          method.isDelegateBindFunction = true;
          method.delegateBindType = dbtype.name;
          method.delegateObjectParam = 0;
          method.delegateFunctionParam = 1;
          method.args = [
            new typedb2.DBArg().init("UObject", "Object"),
            new typedb2.DBArg().init("FName", "FunctionName")
          ];
        }
        {
          let method = AddMethod(dbtype, "Unbind");
          method.returnType = "void";
          method.documentation = "Unbind a specific function that was previously added to this event.";
          method.isDelegateBindFunction = true;
          method.delegateBindType = dbtype.name;
          method.delegateObjectParam = 0;
          method.delegateFunctionParam = 1;
          method.args = [
            new typedb2.DBArg().init("UObject", "Object"),
            new typedb2.DBArg().init("FName", "FunctionName")
          ];
        }
        {
          let method = AddMethod(dbtype, "UnbindObject");
          method.returnType = "void";
          method.documentation = "Unbind all previously added functions that are called on the specified object.";
          method.args = [
            new typedb2.DBArg().init("UObject", "Object")
          ];
        }
      } else {
        {
          let method = AddMethod(dbtype, "Execute");
          method.returnType = dbtype.delegateReturn;
          method.documentation = "Execute the function bound to the delegate. Will throw an error if nothing is bound, use ExecuteIfBound() if you do not want an error in that case.";
          method.args = new Array();
          for (let delegateArg of dbtype.delegateArgs) {
            let arg = new typedb2.DBArg();
            arg.name = delegateArg.name;
            arg.typename = delegateArg.typename;
            method.args.push(arg);
          }
        }
        {
          let method = AddMethod(dbtype, "ExecuteIfBound");
          method.returnType = dbtype.delegateReturn;
          method.documentation = "Execute the function if one is bound to the delegate, otherwise do nothing.";
          method.args = new Array();
          for (let delegateArg of dbtype.delegateArgs) {
            let arg = new typedb2.DBArg();
            arg.name = delegateArg.name;
            arg.typename = delegateArg.typename;
            method.args.push(arg);
          }
        }
        {
          let method = AddMethod(dbtype, "BindUFunction");
          method.returnType = "void";
          method.documentation = "Set the function that is bound to this delegate. Make sure the function you're binding is a UFUNCTION().";
          method.delegateBindType = dbtype.name;
          method.delegateObjectParam = 0;
          method.delegateFunctionParam = 1;
          method.isDelegateBindFunction = true;
          method.args = [
            new typedb2.DBArg().init("UObject", "Object"),
            new typedb2.DBArg().init("FName", "FunctionName")
          ];
        }
        {
          let method = AddMethod(dbtype, "GetUObject");
          method.isProperty = true;
          method.name = "GetUObject";
          method.returnType = "UObject";
          method.documentation = "Get the object that this delegate is bound to. Returns nullptr if unbound.";
          method.args = [];
        }
        {
          let method = AddMethod(dbtype, "GetFunctionName");
          method.isProperty = true;
          method.returnType = "FName";
          method.documentation = "Get the function that this delegate is bound to. Returns NAME_None if unbound.";
          method.args = [];
        }
        {
          let method = AddGlobalFunction(asmodule, dbtype, dbtype.namespace, dbtype.name);
          method.returnType = dbtype.name;
          method.documentation = dbtype.documentation;
          method.isConstructor = true;
          method.args = [
            new typedb2.DBArg().init("UObject", "Object", "nullptr"),
            new typedb2.DBArg().init("FName", "FunctionName", "NAME_None")
          ];
        }
      }
      return dbtype;
    }
    function AddHazeGeneratedCode(asmodule, dbtype, nsType) {
      if (dbtype.inheritsFrom("UHazeComposableSettings"))
        AddGeneratedCodeForUHazeComposableSettings(asmodule, dbtype, nsType);
      else if (dbtype.inheritsFrom("UHazeEffectEventHandler"))
        AddGeneratedCodeForUHazeEffectEventHandler(asmodule, dbtype, nsType);
    }
    function AddGeneratedCodeForUHazeComposableSettings(asmodule, dbtype, nsType) {
      {
        let method = AddGlobalFunction(asmodule, dbtype, nsType, "GetSettings");
        method.returnType = dbtype.name;
        method.documentation = "Get the result settings asset for a specific actor.";
        method.args = [
          new typedb2.DBArg().init("AHazeActor", "Actor")
        ];
      }
      {
        let method = AddGlobalFunction(asmodule, dbtype, nsType, "TakeTransientSettings");
        method.returnType = dbtype.name;
        method.documentation = "Grab a transient settings asset that can be used to temporarily overried values. Must be returned with Actor.ReturnTransientSettings to apply new values.";
        method.args = [
          new typedb2.DBArg().init("AHazeActor", "Actor"),
          new typedb2.DBArg().init("FInstigator", "Instigator"),
          new typedb2.DBArg().init("EHazeSettingsPriority", "Priority", "EHazeSettingsPriority::Script")
        ];
      }
      dbtype.forEachSymbol(function(sym) {
        if (!(sym instanceof typedb2.DBProperty))
          return;
        let dbprop = sym;
        if (!dbprop.isUProperty)
          return;
        {
          let overrideProp = AddProperty(dbtype, "bOverride_" + dbprop.name);
          overrideProp.moduleOffset = dbprop.moduleOffset;
          overrideProp.typename = "bool";
        }
        let setName = dbprop.name;
        if (setName[0] == "b" && setName.length >= 2 && setName[1] == setName[1].toUpperCase())
          setName = setName.substring(1);
        dbprop.auxiliarySymbols = [];
        {
          let method = AddGlobalFunction(asmodule, dbtype, nsType, "Set" + setName);
          method.returnType = "void";
          method.documentation = "Apply a transient override for this composable settings property.";
          method.moduleOffset = dbprop.moduleOffset;
          method.args = [
            new typedb2.DBArg().init("AHazeActor", "Actor"),
            new typedb2.DBArg().init(dbprop.typename, "NewValue"),
            new typedb2.DBArg().init("FInstigator", "Instigator"),
            new typedb2.DBArg().init("EHazeSettingsPriority", "Priority", "EHazeSettingsPriority::Script")
          ];
          method.auxiliarySymbols = [{ symbol_name: dbprop.name, container_type: dbtype.name }, { symbol_name: "Clear" + dbprop.name, container_type: nsType.getQualifiedNamespace() }];
          dbprop.auxiliarySymbols.push({ symbol_name: method.name, container_type: nsType.getQualifiedNamespace() });
        }
        {
          let method = AddGlobalFunction(asmodule, dbtype, nsType, "Clear" + setName);
          method.returnType = "void";
          method.documentation = "Clear a previously applied transient override.";
          method.moduleOffset = dbprop.moduleOffset;
          method.args = [
            new typedb2.DBArg().init("AHazeActor", "Actor"),
            new typedb2.DBArg().init("FInstigator", "Instigator"),
            new typedb2.DBArg().init("EHazeSettingsPriority", "Priority", "EHazeSettingsPriority::Script")
          ];
          method.auxiliarySymbols = [{ symbol_name: dbprop.name, container_type: dbtype.name }, { symbol_name: "Set" + dbprop.name, container_type: nsType.getQualifiedNamespace() }];
          dbprop.auxiliarySymbols.push({ symbol_name: method.name, container_type: nsType.getQualifiedNamespace() });
        }
      });
    }
    function AddGeneratedCodeForUHazeEffectEventHandler(asmodule, dbtype, nsType) {
      dbtype.forEachSymbol(function(sym) {
        if (!(sym instanceof typedb2.DBMethod))
          return;
        let dbfunc = sym;
        if (!dbfunc.isUFunction)
          return;
        if (!dbfunc.isBlueprintEvent)
          return;
        if (dbfunc.isBlueprintOverride)
          return;
        if (dbfunc.returnType && dbfunc.returnType != "void")
          return;
        {
          let method = AddGlobalFunction(asmodule, dbtype, nsType, "Trigger_" + dbfunc.name);
          method.returnType = "void";
          if (dbfunc.documentation)
            method.documentation = dbfunc.documentation;
          else
            method.documentation = `Trigger the effect event ${dbfunc.name} on all handlers for ${dbtype.getDisplayName()}`;
          method.moduleOffset = dbfunc.moduleOffset;
          let actorType = "AHazeActor";
          if (dbtype.macroMeta && dbtype.macroMeta.has("requireactortype"))
            actorType = dbtype.macroMeta.get("requireactortype");
          method.args = [
            new typedb2.DBArg().init(actorType, "Actor")
          ];
          if (dbfunc.args) {
            for (let arg of dbfunc.args)
              method.args.push(arg);
          }
          method.auxiliarySymbols = [{ symbol_name: dbfunc.name, container_type: dbtype.name }];
          dbfunc.auxiliarySymbols = [{ symbol_name: method.name, container_type: nsType.getQualifiedNamespace() }];
        }
      });
    }
    function ApplyProjectGeneratedCode(asmodule, dbtype, nsType, generator) {
      var _a, _b;
      let Replace = (value, replacements) => {
        for (let [token, replacement] of replacements) {
          value = value.replace(new RegExp(`{${token}}`, "g"), replacement);
        }
        return value;
      };
      {
        let tokens = [["class", dbtype.name]];
        (_a = generator.staticFunctions) == null ? void 0 : _a.forEach((func) => {
          let method = AddGlobalFunction(asmodule, dbtype, nsType, Replace(func.name, tokens));
          method.isAutoGenerated = true;
          method.returnType = Replace(func.returnType, tokens);
          method.args = (func.args || []).map((arg) => {
            return new typedb2.DBArg().init(Replace(arg.type, tokens), Replace(arg.name, tokens));
          });
        });
        (_b = generator.memberFunctions) == null ? void 0 : _b.forEach((func) => {
          let method = AddMethod(dbtype, Replace(func.name, tokens));
          method.isAutoGenerated = true;
          method.returnType = Replace(func.returnType, tokens);
          method.isConst = func.const;
          method.isProperty = func.property;
          method.args = (func.args || []).map((arg) => {
            return new typedb2.DBArg().init(Replace(arg.type, tokens), Replace(arg.name, tokens));
          });
        });
      }
      dbtype.forEachSymbol(function(sym) {
        var _a2, _b2;
        if (!(sym instanceof typedb2.DBProperty))
          return;
        let prop = sym;
        if (!prop.declaredModule)
          return;
        let propType = typedb2.LookupType(prop.namespace, prop.typename);
        if (!propType)
          return;
        let tokens = [
          ["class", dbtype.name],
          ["propType", propType.name],
          ["propName", prop.name]
        ];
        (_a2 = generator.staticAccessors) == null ? void 0 : _a2.forEach((func) => {
          if (func.derivedFrom !== void 0 && !propType.inheritsFrom(func.derivedFrom))
            return;
          let method = AddGlobalFunction(asmodule, dbtype, nsType, Replace(func.name, tokens));
          method.isAutoGenerated = true;
          method.returnType = Replace(func.returnType, tokens);
          method.args = (func.args || []).map((arg) => {
            return new typedb2.DBArg().init(Replace(arg.type, tokens), Replace(arg.name, tokens));
          });
        });
        (_b2 = generator.memberAccessors) == null ? void 0 : _b2.forEach((func) => {
          if (func.derivedFrom !== void 0 && !propType.inheritsFrom(func.derivedFrom))
            return;
          let method = AddMethod(dbtype, Replace(func.name, tokens));
          method.isAutoGenerated = true;
          method.returnType = Replace(func.returnType, tokens);
          method.isConst = func.const;
          method.isProperty = func.property;
          method.args = (func.args || []).map((arg) => {
            return new typedb2.DBArg().init(Replace(arg.type, tokens), Replace(arg.name, tokens));
          });
        });
      }, false);
    }
  }
});

// unreal-angelscript-lsp/language-server/grammar/node_types.js
var require_node_types = __commonJS({
  "unreal-angelscript-lsp/language-server/grammar/node_types.js"(exports2, module2) {
    "use strict";
    (function() {
      let i = 0;
      let indexed = true;
      module2.exports = {
        Identifier: indexed ? i++ : "Identifier",
        BinaryOperation: indexed ? i++ : "BinaryOperation",
        UnaryOperation: indexed ? i++ : "UnaryOperation",
        PostfixOperation: indexed ? i++ : "PostfixOperation",
        TernaryOperation: indexed ? i++ : "TernaryOperation",
        CastOperation: indexed ? i++ : "CastOperation",
        Assignment: indexed ? i++ : "Assignment",
        CompoundAssignment: indexed ? i++ : "CompoundAssignment",
        MemberAccess: indexed ? i++ : "MemberAccess",
        NamespaceAccess: indexed ? i++ : "NamespaceAccess",
        FunctionCall: indexed ? i++ : "FunctionCall",
        ConstructorCall: indexed ? i++ : "ConstructorCall",
        NamedArgument: indexed ? i++ : "NamedArgument",
        IndexOperator: indexed ? i++ : "IndexOperator",
        CommaExpression: indexed ? i++ : "CommaExpression",
        This: indexed ? i++ : "This",
        ConstInteger: indexed ? i++ : "ConstInteger",
        ConstHexInteger: indexed ? i++ : "ConstHexInteger",
        ConstOctalInteger: indexed ? i++ : "ConstOctalInteger",
        ConstBinaryInteger: indexed ? i++ : "ConstBinaryInteger",
        ConstFloat: indexed ? i++ : "ConstFloat",
        ConstDouble: indexed ? i++ : "ConstDouble",
        ConstString: indexed ? i++ : "ConstString",
        ConstName: indexed ? i++ : "ConstName",
        ConstFormatString: indexed ? i++ : "ConstFormatString",
        ConstBool: indexed ? i++ : "ConstBool",
        ConstNullptr: indexed ? i++ : "ConstNullptr",
        IfStatement: indexed ? i++ : "IfStatement",
        ElseStatement: indexed ? i++ : "ElseStatement",
        ReturnStatement: indexed ? i++ : "ReturnStatement",
        ImportStatement: indexed ? i++ : "ImportStatement",
        ImportFunctionStatement: indexed ? i++ : "ImportFunctionStatement",
        DefaultStatement: indexed ? i++ : "DefaultStatement",
        SwitchStatement: indexed ? i++ : "SwitchStatement",
        CaseStatement: indexed ? i++ : "CaseStatement",
        DefaultCaseStatement: indexed ? i++ : "DefaultCaseStatement",
        ContinueStatement: indexed ? i++ : "ContinueStatement",
        BreakStatement: indexed ? i++ : "BreakStatement",
        FallthroughStatement: indexed ? i++ : "FallthroughStatement",
        StructDefinition: indexed ? i++ : "StructDefinition",
        ClassDefinition: indexed ? i++ : "ClassDefinition",
        EnumDefinition: indexed ? i++ : "EnumDefinition",
        AssetDefinition: indexed ? i++ : "AssetDefinition",
        NamespaceDefinition: indexed ? i++ : "NamespaceDefinition",
        VariableDecl: indexed ? i++ : "VariableDecl",
        VariableDeclMulti: indexed ? i++ : "VariableDeclMulti",
        FunctionDecl: indexed ? i++ : "FunctionDecl",
        DelegateDecl: indexed ? i++ : "DelegateDecl",
        EventDecl: indexed ? i++ : "EventDecl",
        ConstructorDecl: indexed ? i++ : "ConstructorDecl",
        DestructorDecl: indexed ? i++ : "DestructorDecl",
        ForLoop: indexed ? i++ : "ForLoop",
        ForEachLoop: indexed ? i++ : "ForEachLoop",
        WhileLoop: indexed ? i++ : "WhileLoop",
        Typename: indexed ? i++ : "Typename",
        Parameter: indexed ? i++ : "Parameter",
        ArgumentList: indexed ? i++ : "ArgumentList",
        Argument: indexed ? i++ : "Argument",
        Macro: indexed ? i++ : "Macro",
        MacroArgument: indexed ? i++ : "MacroArgument",
        EnumValueList: indexed ? i++ : "EnumValueList",
        EnumValue: indexed ? i++ : "EnumValue",
        AccessDeclaration: indexed ? i++ : "AccessDeclaration",
        AccessClass: indexed ? i++ : "AccessClass",
        IncompleteAccessSpecifier: indexed ? i++ : "IncompleteAccessSpecifier"
      };
    })();
  }
});

// unreal-angelscript-lsp/language-server/pegjs/angelscript.js
var require_angelscript = __commonJS({
  "unreal-angelscript-lsp/language-server/pegjs/angelscript.js"(exports2, module2) {
    "use strict";
    var n = require_node_types();
    function Literal(range, node_type, value) {
      range.type = node_type;
      range.value = value;
      return range;
    }
    function Identifier(range, value) {
      range.type = n.Identifier;
      range.value = value;
      return range;
    }
    function Compound(range, node_type, children) {
      range.type = node_type;
      range.children = children;
      return range;
    }
    function InnerCompound(range, node_type, children) {
      range.type = node_type;
      range.children = children;
      if (children && children.length != 0) {
        let firstindex = 0;
        while (!children[firstindex] && firstindex < children.length)
          firstindex += 1;
        if (firstindex < children.length)
          range.start = children[firstindex].start;
        let lastindex = children.length - 1;
        while (!children[lastindex] && lastindex > 0)
          lastindex -= 1;
        if (lastindex >= 0)
          range.end = children[lastindex].end;
      }
      return range;
    }
    function CompoundOperator(range, node_type, operator, children) {
      let node = Compound(range, node_type, children);
      node.operator = operator;
      return node;
    }
    function InnerCompoundOperator(range, node_type, operator, children) {
      let node = InnerCompound(range, node_type, children);
      node.operator = operator;
      return node;
    }
    function ExtendedCompound(range, compound) {
      compound.start = range.start;
      compound.end = range.end;
      return compound;
    }
    function peg$subclass(child, parent) {
      function C() {
        this.constructor = child;
      }
      C.prototype = parent.prototype;
      child.prototype = new C();
    }
    function peg$SyntaxError(message, expected, found, location) {
      var self = Error.call(this, message);
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(self, peg$SyntaxError.prototype);
      }
      self.expected = expected;
      self.found = found;
      self.location = location;
      self.name = "SyntaxError";
      return self;
    }
    peg$subclass(peg$SyntaxError, Error);
    function peg$padEnd(str, targetLength, padString) {
      padString = padString || " ";
      if (str.length > targetLength) {
        return str;
      }
      targetLength -= str.length;
      padString += padString.repeat(targetLength);
      return str + padString.slice(0, targetLength);
    }
    peg$SyntaxError.prototype.format = function(sources) {
      var str = "Error: " + this.message;
      if (this.location) {
        var src = null;
        var k;
        for (k = 0; k < sources.length; k++) {
          if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
          }
        }
        var s = this.location.start;
        var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
        var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
        if (src) {
          var e = this.location.end;
          var filler = peg$padEnd("", offset_s.line.toString().length, " ");
          var line = src[s.line - 1];
          var last = s.line === e.line ? e.column : line.length + 1;
          var hatLen = last - s.column || 1;
          str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else {
          str += "\n at " + loc;
        }
      }
      return str;
    };
    peg$SyntaxError.buildMessage = function(expected, found) {
      var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
          return "any character";
        },
        end: function() {
          return "end of input";
        },
        other: function(expectation) {
          return expectation.description;
        }
      };
      function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
      }
      function literalEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function classEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
          return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
          return "\\x" + hex(ch);
        });
      }
      function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
      }
      function describeExpected(expected2) {
        var descriptions = expected2.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
          for (i = 1, j = 1; i < descriptions.length; i++) {
            if (descriptions[i - 1] !== descriptions[i]) {
              descriptions[j] = descriptions[i];
              j++;
            }
          }
          descriptions.length = j;
        }
        switch (descriptions.length) {
          case 1:
            return descriptions[0];
          case 2:
            return descriptions[0] + " or " + descriptions[1];
          default:
            return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
      }
      function describeFound(found2) {
        return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
      }
      return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
      options = options !== void 0 ? options : {};
      var peg$FAILED = {};
      var peg$source = options.grammarSource;
      var peg$startRuleFunctions = { start: peg$parsestart, start_global: peg$parsestart_global, start_class: peg$parsestart_class, start_enum: peg$parsestart_enum };
      var peg$startRuleFunction = peg$parsestart;
      var peg$c0 = "/";
      var peg$c1 = "*";
      var peg$c2 = "#";
      var peg$c3 = "+";
      var peg$c4 = "-";
      var peg$c5 = "&";
      var peg$c6 = "|";
      var peg$c7 = "=";
      var peg$c8 = "%";
      var peg$c9 = "!";
      var peg$c10 = "<";
      var peg$c11 = ">";
      var peg$c12 = "^";
      var peg$c13 = "~";
      var peg$c14 = "mixin";
      var peg$c15 = "local";
      var peg$c16 = "i";
      var peg$c17 = "if";
      var peg$c18 = "(";
      var peg$c19 = ")";
      var peg$c20 = "r";
      var peg$c21 = "return";
      var peg$c22 = "e";
      var peg$c23 = "else";
      var peg$c24 = "s";
      var peg$c25 = "switch";
      var peg$c26 = "f";
      var peg$c27 = "for";
      var peg$c28 = ";";
      var peg$c29 = ":";
      var peg$c30 = ",";
      var peg$c31 = "c";
      var peg$c32 = "case";
      var peg$c33 = "d";
      var peg$c34 = "default";
      var peg$c35 = "continue";
      var peg$c36 = "b";
      var peg$c37 = "break";
      var peg$c38 = "fallthrough";
      var peg$c39 = "w";
      var peg$c40 = "while";
      var peg$c41 = "const";
      var peg$c42 = "inout";
      var peg$c43 = "in";
      var peg$c44 = "o";
      var peg$c45 = "out";
      var peg$c46 = "t";
      var peg$c47 = "this";
      var peg$c48 = "[";
      var peg$c49 = "]";
      var peg$c50 = ".";
      var peg$c51 = "?";
      var peg$c52 = "C";
      var peg$c53 = "Cast";
      var peg$c54 = "true";
      var peg$c55 = "false";
      var peg$c56 = "n";
      var peg$c57 = "nullptr";
      var peg$c58 = "0";
      var peg$c59 = "x";
      var peg$c60 = '"';
      var peg$c61 = "\\";
      var peg$c62 = '"""';
      var peg$c63 = "'";
      var peg$c64 = "class";
      var peg$c65 = "struct";
      var peg$c66 = "v";
      var peg$c67 = "void";
      var peg$c68 = "override";
      var peg$c69 = "delegate";
      var peg$c70 = "p";
      var peg$c71 = "property";
      var peg$c72 = "event";
      var peg$c73 = "enum";
      var peg$c74 = "m";
      var peg$c75 = "l";
      var peg$c76 = "final";
      var peg$c77 = "a";
      var peg$c78 = "access";
      var peg$c79 = "namespace";
      var peg$c80 = "U";
      var peg$c81 = "UFUNCTION";
      var peg$c82 = "UPROPERTY";
      var peg$c83 = "UCLASS";
      var peg$c84 = "UENUM";
      var peg$c85 = "UMETA";
      var peg$c86 = "USTRUCT";
      var peg$c87 = "T";
      var peg$c88 = "TSubclassOf";
      var peg$c89 = "TArray";
      var peg$c90 = "TMap";
      var peg$c91 = "TSet";
      var peg$c92 = "TOptional";
      var peg$c93 = "TWeakObjectPtr";
      var peg$c94 = "TSoftObjectPtr";
      var peg$c95 = "TSoftClassPtr";
      var peg$c96 = "TInstigated";
      var peg$c97 = "TPerPlayer";
      var peg$c98 = "float32";
      var peg$c99 = "float64";
      var peg$c100 = "float";
      var peg$c101 = "int64";
      var peg$c102 = "int32";
      var peg$c103 = "int16";
      var peg$c104 = "int8";
      var peg$c105 = "int";
      var peg$c106 = "u";
      var peg$c107 = "uint64";
      var peg$c108 = "uint32";
      var peg$c109 = "uint16";
      var peg$c110 = "uint8";
      var peg$c111 = "uint";
      var peg$c112 = "bool";
      var peg$c113 = "import";
      var peg$c114 = "from";
      var peg$c115 = "asset";
      var peg$c116 = "of";
      var peg$c117 = "private";
      var peg$c118 = "protected";
      var peg$c119 = "public";
      var peg$r0 = /^[^\r\n]/;
      var peg$r1 = /^[ \t\r\n]/;
      var peg$r2 = /^[\/#]/;
      var peg$r3 = /^[0-9]/;
      var peg$r4 = /^[,)=]/;
      var peg$r5 = /^[^\r\n"\\]/;
      var peg$r6 = /^[A-Za-z"'\\]/;
      var peg$r7 = /^[^\r\n'\\]/;
      var peg$r8 = /^[0-9A-Fa-f]/;
      var peg$r9 = /^[01]/;
      var peg$r10 = /^[0-8]/;
      var peg$r11 = /^[A-Za-z_]/;
      var peg$r12 = /^[A-Za-z_0-9]/;
      var peg$r13 = /^[|:]/;
      var peg$e0 = peg$literalExpectation("/", false);
      var peg$e1 = peg$literalExpectation("*", false);
      var peg$e2 = peg$anyExpectation();
      var peg$e3 = peg$classExpectation(["\r", "\n"], true, false);
      var peg$e4 = peg$literalExpectation("#", false);
      var peg$e5 = peg$classExpectation([" ", "	", "\r", "\n"], false, false);
      var peg$e6 = peg$classExpectation(["/", "#"], false, false);
      var peg$e7 = peg$literalExpectation("+", false);
      var peg$e8 = peg$literalExpectation("-", false);
      var peg$e9 = peg$literalExpectation("&", false);
      var peg$e10 = peg$literalExpectation("|", false);
      var peg$e11 = peg$literalExpectation("=", false);
      var peg$e12 = peg$literalExpectation("%", false);
      var peg$e13 = peg$literalExpectation("!", false);
      var peg$e14 = peg$literalExpectation("<", false);
      var peg$e15 = peg$literalExpectation(">", false);
      var peg$e16 = peg$literalExpectation("^", false);
      var peg$e17 = peg$literalExpectation("~", false);
      var peg$e18 = peg$literalExpectation("mixin", false);
      var peg$e19 = peg$literalExpectation("local", false);
      var peg$e20 = peg$literalExpectation("i", false);
      var peg$e21 = peg$literalExpectation("if", false);
      var peg$e22 = peg$literalExpectation("(", false);
      var peg$e23 = peg$literalExpectation(")", false);
      var peg$e24 = peg$literalExpectation("r", false);
      var peg$e25 = peg$literalExpectation("return", false);
      var peg$e26 = peg$literalExpectation("e", false);
      var peg$e27 = peg$literalExpectation("else", false);
      var peg$e28 = peg$literalExpectation("s", false);
      var peg$e29 = peg$literalExpectation("switch", false);
      var peg$e30 = peg$literalExpectation("f", false);
      var peg$e31 = peg$literalExpectation("for", false);
      var peg$e32 = peg$literalExpectation(";", false);
      var peg$e33 = peg$literalExpectation(":", false);
      var peg$e34 = peg$literalExpectation(",", false);
      var peg$e35 = peg$literalExpectation("c", false);
      var peg$e36 = peg$literalExpectation("case", false);
      var peg$e37 = peg$literalExpectation("d", false);
      var peg$e38 = peg$literalExpectation("default", false);
      var peg$e39 = peg$classExpectation([["0", "9"]], false, false);
      var peg$e40 = peg$literalExpectation("continue", false);
      var peg$e41 = peg$literalExpectation("b", false);
      var peg$e42 = peg$literalExpectation("break", false);
      var peg$e43 = peg$literalExpectation("fallthrough", false);
      var peg$e44 = peg$literalExpectation("w", false);
      var peg$e45 = peg$literalExpectation("while", false);
      var peg$e46 = peg$literalExpectation("const", false);
      var peg$e47 = peg$literalExpectation("inout", false);
      var peg$e48 = peg$literalExpectation("in", false);
      var peg$e49 = peg$literalExpectation("o", false);
      var peg$e50 = peg$literalExpectation("out", false);
      var peg$e51 = peg$literalExpectation("t", false);
      var peg$e52 = peg$literalExpectation("this", false);
      var peg$e53 = peg$literalExpectation("[", false);
      var peg$e54 = peg$literalExpectation("]", false);
      var peg$e55 = peg$literalExpectation(".", false);
      var peg$e56 = peg$classExpectation([",", ")", "="], false, false);
      var peg$e57 = peg$literalExpectation("?", false);
      var peg$e58 = peg$literalExpectation("C", false);
      var peg$e59 = peg$literalExpectation("Cast", false);
      var peg$e60 = peg$literalExpectation("true", false);
      var peg$e61 = peg$literalExpectation("false", false);
      var peg$e62 = peg$literalExpectation("n", false);
      var peg$e63 = peg$literalExpectation("nullptr", false);
      var peg$e64 = peg$literalExpectation("0", false);
      var peg$e65 = peg$literalExpectation("x", false);
      var peg$e66 = peg$literalExpectation('"', false);
      var peg$e67 = peg$classExpectation(["\r", "\n", '"', "\\"], true, false);
      var peg$e68 = peg$literalExpectation("\\", false);
      var peg$e69 = peg$literalExpectation('"""', false);
      var peg$e70 = peg$classExpectation([["A", "Z"], ["a", "z"], '"', "'", "\\"], false, false);
      var peg$e71 = peg$literalExpectation("'", false);
      var peg$e72 = peg$classExpectation(["\r", "\n", "'", "\\"], true, false);
      var peg$e73 = peg$classExpectation([["0", "9"], ["A", "F"], ["a", "f"]], false, false);
      var peg$e74 = peg$classExpectation(["0", "1"], false, false);
      var peg$e75 = peg$classExpectation([["0", "8"]], false, false);
      var peg$e76 = peg$literalExpectation("class", false);
      var peg$e77 = peg$literalExpectation("struct", false);
      var peg$e78 = peg$literalExpectation("v", false);
      var peg$e79 = peg$literalExpectation("void", false);
      var peg$e80 = peg$literalExpectation("override", false);
      var peg$e81 = peg$literalExpectation("delegate", false);
      var peg$e82 = peg$literalExpectation("p", false);
      var peg$e83 = peg$literalExpectation("property", false);
      var peg$e84 = peg$literalExpectation("event", false);
      var peg$e85 = peg$literalExpectation("enum", false);
      var peg$e86 = peg$literalExpectation("m", false);
      var peg$e87 = peg$literalExpectation("l", false);
      var peg$e88 = peg$literalExpectation("final", false);
      var peg$e89 = peg$literalExpectation("a", false);
      var peg$e90 = peg$literalExpectation("access", false);
      var peg$e91 = peg$literalExpectation("namespace", false);
      var peg$e92 = peg$literalExpectation("U", false);
      var peg$e93 = peg$literalExpectation("UFUNCTION", false);
      var peg$e94 = peg$literalExpectation("UPROPERTY", false);
      var peg$e95 = peg$literalExpectation("UCLASS", false);
      var peg$e96 = peg$literalExpectation("UENUM", false);
      var peg$e97 = peg$literalExpectation("UMETA", false);
      var peg$e98 = peg$literalExpectation("USTRUCT", false);
      var peg$e99 = peg$literalExpectation("T", false);
      var peg$e100 = peg$literalExpectation("TSubclassOf", false);
      var peg$e101 = peg$literalExpectation("TArray", false);
      var peg$e102 = peg$literalExpectation("TMap", false);
      var peg$e103 = peg$literalExpectation("TSet", false);
      var peg$e104 = peg$literalExpectation("TOptional", false);
      var peg$e105 = peg$literalExpectation("TWeakObjectPtr", false);
      var peg$e106 = peg$literalExpectation("TSoftObjectPtr", false);
      var peg$e107 = peg$literalExpectation("TSoftClassPtr", false);
      var peg$e108 = peg$literalExpectation("TInstigated", false);
      var peg$e109 = peg$literalExpectation("TPerPlayer", false);
      var peg$e110 = peg$literalExpectation("float32", false);
      var peg$e111 = peg$literalExpectation("float64", false);
      var peg$e112 = peg$literalExpectation("float", false);
      var peg$e113 = peg$literalExpectation("int64", false);
      var peg$e114 = peg$literalExpectation("int32", false);
      var peg$e115 = peg$literalExpectation("int16", false);
      var peg$e116 = peg$literalExpectation("int8", false);
      var peg$e117 = peg$literalExpectation("int", false);
      var peg$e118 = peg$literalExpectation("u", false);
      var peg$e119 = peg$literalExpectation("uint64", false);
      var peg$e120 = peg$literalExpectation("uint32", false);
      var peg$e121 = peg$literalExpectation("uint16", false);
      var peg$e122 = peg$literalExpectation("uint8", false);
      var peg$e123 = peg$literalExpectation("uint", false);
      var peg$e124 = peg$literalExpectation("bool", false);
      var peg$e125 = peg$classExpectation([["A", "Z"], ["a", "z"], "_"], false, false);
      var peg$e126 = peg$classExpectation([["A", "Z"], ["a", "z"], "_", ["0", "9"]], false, false);
      var peg$e127 = peg$literalExpectation("import", false);
      var peg$e128 = peg$literalExpectation("from", false);
      var peg$e129 = peg$classExpectation(["|", ":"], false, false);
      var peg$e130 = peg$literalExpectation("asset", false);
      var peg$e131 = peg$literalExpectation("of", false);
      var peg$e132 = peg$literalExpectation("private", false);
      var peg$e133 = peg$literalExpectation("protected", false);
      var peg$e134 = peg$literalExpectation("public", false);
      var peg$f0 = function() {
        return null;
      };
      var peg$f1 = function(comment, decl) {
        if (comment)
          decl.documentation = comment;
        return decl;
      };
      var peg$f2 = function() {
        return null;
      };
      var peg$f3 = function(comment, decl) {
        if (comment)
          decl.documentation = comment;
        return decl;
      };
      var peg$f4 = function() {
        return null;
      };
      var peg$f5 = function() {
        return null;
      };
      var peg$f6 = function(macro, scope, decl) {
        decl.macro = macro;
        decl.scoping = scope;
        return decl;
      };
      var peg$f7 = function(condition, body) {
        return Compound(range(), n.IfStatement, [condition, body]);
      };
      var peg$f8 = function(value) {
        return Compound(range(), n.ReturnStatement, value ? [value] : []);
      };
      var peg$f9 = function(body) {
        return Compound(range(), n.ElseStatement, [body]);
      };
      var peg$f10 = function(cond) {
        return Compound(range(), n.SwitchStatement, [cond]);
      };
      var peg$f11 = function(init, cond, iter) {
        return [cond, iter];
      };
      var peg$f12 = function(init, loop, body) {
        return Compound(range(), n.ForLoop, loop ? [init, loop[0], loop[1], body] : [init, null, null, body]);
      };
      var peg$f13 = function(type, iterator, expr, body) {
        return Compound(range(), n.ForEachLoop, [type, iterator, expr, body]);
      };
      var peg$f14 = function(inner) {
        return ExtendedCompound(range(), inner);
      };
      var peg$f15 = function(head, tail) {
        if (tail.length != 0)
          return Compound(range(), n.CommaExpression, [head].concat(tail));
        else
          return head;
      };
      var peg$f16 = function(lbl, body) {
        return [true, body];
      };
      var peg$f17 = function(lbl) {
        return [false, "::"];
      };
      var peg$f18 = function(lbl) {
        return [false, ":"];
      };
      var peg$f19 = function(lbl, stmt) {
        if (stmt) {
          if (stmt[0]) {
            let node = Compound(range(), n.CaseStatement, [lbl, stmt[1]]);
            node.has_statement = true;
            return node;
          } else if (lbl.type == n.Identifier) {
            let inner = Compound(range(), n.NamespaceAccess, [lbl, null]);
            if (stmt[1] == ":")
              inner.incomplete_colon = true;
            return Compound(range(), n.CaseStatement, [inner, null]);
          } else {
            let node = Compound(range(), n.CaseStatement, [lbl, null]);
            node.has_statement = true;
            return node;
          }
        } else {
          return Compound(range(), n.CaseStatement, [lbl, null]);
        }
      };
      var peg$f20 = function(inner) {
        return ExtendedCompound(range(), inner);
      };
      var peg$f21 = function(body) {
        return Compound(range(), n.DefaultCaseStatement, [body]);
      };
      var peg$f22 = function() {
        return Literal(range(), n.ConstInteger, text());
      };
      var peg$f23 = function(token) {
        return Literal(range(), n.ContinueStatement, token);
      };
      var peg$f24 = function(token) {
        return Literal(range(), n.BreakStatement, token);
      };
      var peg$f25 = function(token) {
        return Literal(range(), n.FallthroughStatement, token);
      };
      var peg$f26 = function(cond, body) {
        return Compound(range(), n.WhileLoop, [cond, body]);
      };
      var peg$f27 = function(head, op, right) {
        return [op, right];
      };
      var peg$f28 = function(head, tail) {
        return tail.reduce(function(result, element) {
          if (element[0] == "=")
            return Compound(range(), n.Assignment, [result, element[1]]);
          else
            return CompoundOperator(range(), n.CompoundAssignment, element[0], [result, element[1]]);
        }, head);
      };
      var peg$f29 = function(type, head, tail) {
        head.typename = type;
        if (tail.length != 0) {
          let vars = [head];
          for (let part of tail) {
            part.typename = type;
            vars.push(part);
          }
          return Compound(range(), n.VariableDeclMulti, vars);
        } else {
          return ExtendedCompound(range(), head);
        }
      };
      var peg$f30 = function(name, expr) {
        return [0, expr];
      };
      var peg$f31 = function(name, args) {
        return [1, args];
      };
      var peg$f32 = function(name, value) {
        let node = Compound(range(), n.VariableDecl, null);
        node.name = name;
        if (value) {
          if (value[0] == 0)
            node.inline_assignment = true;
          else if (value[0] == 1)
            node.inline_constructor = true;
          node.expression = value[1];
        }
        return node;
      };
      var peg$f33 = function(type) {
        let node = Compound(range(), n.VariableDecl, null);
        node.name = null;
        node.typename = type;
        return node;
      };
      var peg$f34 = function(constq, name, refq) {
        let node = ExtendedCompound(range(), name);
        node.const_qualifier = constq;
        node.ref_qualifier = refq;
        return node;
      };
      var peg$f35 = function(token) {
        return Identifier(range(), token);
      };
      var peg$f36 = function(type) {
        if (type)
          return "&" + type;
        else
          return "&";
      };
      var peg$f37 = function() {
        return Literal(range(), n.Typename, text());
      };
      var peg$f38 = function(basetype, head, tail) {
        return [head].concat(tail);
      };
      var peg$f39 = function(basetype, types) {
        return types;
      };
      var peg$f40 = function(basetype, subtypes) {
        if (subtypes) {
          let name = basetype.value + "<";
          for (let i = 0; i < subtypes.length; ++i) {
            if (i != 0)
              name += ",";
            name += subtypes[i].value;
          }
          name += ">";
          let node = Literal(range(), n.Typename, name);
          node.basetype = basetype;
          node.subtypes = subtypes;
          return node;
        } else {
          let node = Literal(range(), n.Typename, basetype.value);
          node.name = basetype;
          return node;
        }
      };
      var peg$f41 = function() {
        let node = Literal(range(), n.Typename, text());
        node.name = node;
        return node;
      };
      var peg$f42 = function(identifiers) {
        return Literal(range(), n.Typename, text());
      };
      var peg$f43 = function(basetype, head, tail) {
        return [head].concat(tail);
      };
      var peg$f44 = function(basetype, types) {
        return types;
      };
      var peg$f45 = function(basetype, subtypes) {
        if (subtypes) {
          let name = basetype.value + "<";
          for (let i = 0; i < subtypes.length; ++i) {
            if (i != 0)
              name += ",";
            name += subtypes[i].value;
          }
          name += ">";
          let node = Literal(range(), n.Typename, name);
          node.basetype = basetype;
          node.subtypes = subtypes;
          return node;
        } else {
          let node = Literal(range(), n.Typename, basetype.value);
          node.name = basetype;
          return node;
        }
      };
      var peg$f46 = function() {
        return null;
      };
      var peg$f47 = function(token) {
        return Literal(range(), n.This, token);
      };
      var peg$f48 = function(leading, ident, namespaces, trailing) {
        if (leading)
          ident = InnerCompound(range(), n.NamespaceAccess, [null, ident]);
        if (trailing)
          namespaces.push(null);
        if (namespaces.length != 0) {
          let outer = namespaces.reduce(function(result, element) {
            return InnerCompound(range(), n.NamespaceAccess, [result, element]);
          }, ident);
          if (trailing)
            outer.incomplete_colon = true;
          return outer;
        } else {
          return ident;
        }
      };
      var peg$f49 = function(leading, ident, namespaces) {
        if (leading)
          ident = InnerCompound(range(), n.NamespaceAccess, [null, ident]);
        if (namespaces.length != 0) {
          let outer = namespaces.reduce(function(result, element) {
            return InnerCompound(range(), n.NamespaceAccess, [result, element]);
          }, ident);
          return outer;
        } else {
          return ident;
        }
      };
      var peg$f50 = function(head, args) {
        return [0, args, range()];
      };
      var peg$f51 = function(head, inner) {
        return [1, inner, range()];
      };
      var peg$f52 = function(head, inner) {
        return [2, inner];
      };
      var peg$f53 = function(head, tail) {
        return tail.reduce(function(result, element) {
          if (element[0] == 0) {
            let expr = InnerCompound(
              range(),
              n.FunctionCall,
              [result, element[1]]
            );
            if (element[2].end > expr.end)
              expr.end = element[2].end;
            return expr;
          } else if (element[0] == 1) {
            let expr = InnerCompound(
              range(),
              n.IndexOperator,
              [result, element[1]]
            );
            if (element[2].end > expr.end)
              expr.end = element[2].end;
            return expr;
          } else if (element[0] == 2) {
            return InnerCompound(
              range(),
              n.MemberAccess,
              [result, element[1]]
            );
          }
        }, head);
      };
      var peg$f54 = function(head, tail) {
        return Compound(
          range(),
          n.ArgumentList,
          [head].concat(tail)
        );
      };
      var peg$f55 = function() {
        return null;
      };
      var peg$f56 = function(name) {
        let ident = Literal(range(), n.Identifier, name);
        ident.maybeTypename = true;
        return Compound(
          range(),
          n.ArgumentList,
          [ident]
        );
      };
      var peg$f57 = function(expr) {
        return Compound(
          range(),
          n.ArgumentList,
          [expr]
        );
      };
      var peg$f58 = function(name, expr) {
        return Compound(range(), n.NamedArgument, [name, expr]);
      };
      var peg$f59 = function(expr, trailing) {
        if (trailing && expr.type == n.Identifier)
          return Compound(range(), n.NamedArgument, [expr, trailing]);
        else
          return expr;
      };
      var peg$f60 = function(condition, first, second) {
        if (first.type == n.NamespaceAccess && first.incomplete_colon) {
          if (!second || !second[0])
            return [first.children[0], second ? second[1] : null];
        }
        return [first, second ? second[1] : null];
      };
      var peg$f61 = function(condition, result) {
        return result ? result : [null, null];
      };
      var peg$f62 = function(condition, conseq) {
        if (conseq)
          return Compound(range(), n.TernaryOperation, [condition, conseq[0], conseq[1]]);
        else
          return condition;
      };
      var peg$f63 = function(head, op, expr) {
        return [op, expr];
      };
      var peg$f64 = function(head, tail) {
        return tail.reduce(function(result, element) {
          return InnerCompoundOperator(
            range(),
            n.BinaryOperation,
            element[0],
            [result, element[1]]
          );
        }, head);
      };
      var peg$f65 = function(head, op, expr) {
        return [op, expr];
      };
      var peg$f66 = function(head, tail) {
        return tail.reduce(function(result, element) {
          return InnerCompoundOperator(
            range(),
            n.BinaryOperation,
            element[0],
            [result, element[1]]
          );
        }, head);
      };
      var peg$f67 = function(head, op, expr) {
        return [op, expr];
      };
      var peg$f68 = function(head, tail) {
        return tail.reduce(function(result, element) {
          return InnerCompoundOperator(
            range(),
            n.BinaryOperation,
            element[0],
            [result, element[1]]
          );
        }, head);
      };
      var peg$f69 = function(head, op, expr) {
        return [op, expr];
      };
      var peg$f70 = function(head, tail) {
        return tail.reduce(function(result, element) {
          return InnerCompoundOperator(
            range(),
            n.BinaryOperation,
            element[0],
            [result, element[1]]
          );
        }, head);
      };
      var peg$f71 = function(head, op, expr) {
        return [op, expr];
      };
      var peg$f72 = function(head, tail) {
        return tail.reduce(function(result, element) {
          return InnerCompoundOperator(
            range(),
            n.BinaryOperation,
            element[0],
            [result, element[1]]
          );
        }, head);
      };
      var peg$f73 = function(op, expr) {
        return CompoundOperator(
          range(),
          n.UnaryOperation,
          op,
          [expr]
        );
      };
      var peg$f74 = function(expr, op) {
        if (op) {
          return CompoundOperator(
            range(),
            n.PostfixOperation,
            op,
            [expr]
          );
        } else {
          return expr;
        }
      };
      var peg$f75 = function(op) {
        return CompoundOperator(range(), n.UnaryOperation, op, []);
      };
      var peg$f76 = function(type, expr) {
        return Compound(range(), n.CastOperation, [type, expr]);
      };
      var peg$f77 = function(type) {
        return Compound(range(), n.CastOperation, [type, null]);
      };
      var peg$f78 = function() {
        return Compound(range(), n.CastOperation, [null, null]);
      };
      var peg$f79 = function(inner) {
        return ExtendedCompound(range(), inner);
      };
      var peg$f80 = function(type, args) {
        return Compound(range(), n.ConstructorCall, [type, args]);
      };
      var peg$f81 = function() {
        return Literal(range(), n.ConstBool, "true");
      };
      var peg$f82 = function() {
        return Literal(range(), n.ConstBool, "false");
      };
      var peg$f83 = function() {
        return Literal(range(), n.ConstNullptr, "nullptr");
      };
      var peg$f84 = function() {
        return Literal(range(), n.ConstString, text());
      };
      var peg$f85 = function() {
        return Literal(range(), n.ConstString, text());
      };
      var peg$f86 = function() {
        return Literal(range(), n.ConstFormatString, text());
      };
      var peg$f87 = function() {
        return Literal(range(), n.ConstName, text());
      };
      var peg$f88 = function(content) {
        return Literal(range(), n.ConstString, text());
      };
      var peg$f89 = function(head, exponent, suffix) {
        let value = head[1];
        if (exponent)
          value += exponent;
        if (suffix)
          value += suffix;
        if (suffix) {
          return Literal(range(), n.ConstFloat, text());
        } else if (exponent || head[1]) {
          return Literal(range(), n.ConstDouble, text());
        } else {
          return Literal(range(), n.ConstInteger, text());
        }
      };
      var peg$f90 = function(sign, num) {
        if (sign)
          return Literal(range(), num.type, text());
        return num;
      };
      var peg$f91 = function() {
        return Literal(range(), n.ConstHexInteger, text());
      };
      var peg$f92 = function() {
        return Literal(range(), n.ConstBinaryInteger, text());
      };
      var peg$f93 = function() {
        return Literal(range(), n.ConstOctalInteger, text());
      };
      var peg$f94 = function(start, rest) {
        return Identifier(range(), text());
      };
      var peg$f95 = function(head, tail) {
        let identifier = InnerCompound(range(), n.Identifier, [head].concat(tail));
        identifier.value = head.value;
        for (let child of tail)
          identifier.value += "." + child.value;
        return Compound(range(), n.ImportStatement, [identifier]);
      };
      var peg$f96 = function(sig) {
        let value = text();
        return Identifier(range(), value.substring(1, value.length - 1));
      };
      var peg$f97 = function(sig, str) {
        return Compound(range(), n.ImportFunctionStatement, [sig, str]);
      };
      var peg$f98 = function(docs) {
        if (docs.length == 0)
          return null;
        let result = "";
        for (let comment of docs) {
          if (!comment || comment[0] == "#")
            continue;
          else if (comment[0] == "/" && comment[1] == "*")
            result = comment.substring(2, comment.length - 2);
          else if (comment[0] == "/" && comment[1] == "/")
            result = comment.substring(2);
        }
        return result;
      };
      var peg$f99 = function(ret, name) {
        return options.precedesBlock && !options.endsWithSemicolon;
      };
      var peg$f100 = function(ret, name) {
        return !options.precedesBlock || options.endsWithSemicolon;
      };
      var peg$f101 = function(ret, name, params, quals) {
        let node = Compound(range(), n.FunctionDecl, null);
        node.name = name;
        node.returntype = ret;
        node.parameters = params;
        node.qualifiers = quals;
        return node;
      };
      var peg$f102 = function(name, params) {
        let node = Compound(range(), n.FunctionDecl, null);
        node.name = name;
        node.returntype = null;
        node.parameters = params;
        node.qualifiers = [];
        return node;
      };
      var peg$f103 = function(ret, name, params, quals) {
        let node = Compound(range(), n.FunctionDecl, null);
        node.name = name;
        node.returntype = ret;
        node.parameters = params;
        node.qualifiers = quals;
        return node;
      };
      var peg$f104 = function(name, params) {
        let node = Compound(range(), n.FunctionDecl, null);
        node.name = name;
        node.returntype = null;
        node.parameters = params;
        node.qualifiers = [];
        return node;
      };
      var peg$f105 = function() {
        return null;
      };
      var peg$f106 = function(head, tail) {
        let params = [];
        if (head)
          params.push(head);
        for (let p of tail) {
          if (p)
            params.push(p);
        }
        return params;
      };
      var peg$f107 = function(params) {
        return params ? params : [];
      };
      var peg$f108 = function(head, tail) {
        let params = [];
        if (head)
          params.push(head);
        for (let p of tail) {
          if (p)
            params.push(p);
        }
        return params;
      };
      var peg$f109 = function(params) {
        return params ? params : [];
      };
      var peg$f110 = function(type, name, expr) {
        let node = Compound(range(), n.Parameter, null);
        node.typename = type;
        node.name = name;
        node.expression = expr;
        return node;
      };
      var peg$f111 = function() {
        return null;
      };
      var peg$f112 = function() {
        return null;
      };
      var peg$f113 = function() {
        return null;
      };
      var peg$f114 = function(type, name, expr) {
        return [name, expr];
      };
      var peg$f115 = function(type, decl) {
        let node = Compound(range(), n.Parameter, null);
        node.typename = type;
        if (decl) {
          node.name = decl[0];
          node.expression = decl[1];
        }
        return node;
      };
      var peg$f116 = function() {
        return null;
      };
      var peg$f117 = function(macros) {
        return Compound(range(), n.Macro, macros);
      };
      var peg$f118 = function(macros) {
        return Compound(range(), n.Macro, macros);
      };
      var peg$f119 = function(macros) {
        return Compound(range(), n.Macro, macros);
      };
      var peg$f120 = function(macros) {
        return Compound(range(), n.Macro, macros);
      };
      var peg$f121 = function(macros) {
        return Compound(range(), n.Macro, macros);
      };
      var peg$f122 = function(macros) {
        return Compound(range(), n.Macro, macros);
      };
      var peg$f123 = function(head, tail) {
        let specifiers = [];
        if (head)
          specifiers.push(head);
        for (let p of tail) {
          if (p)
            specifiers.push(p);
        }
        return specifiers;
      };
      var peg$f124 = function(specifiers) {
        return specifiers ? specifiers : [];
      };
      var peg$f125 = function(name, value) {
        return [0, value];
      };
      var peg$f126 = function(name, list) {
        return [1, list];
      };
      var peg$f127 = function(name, value) {
        let node = Compound(range(), n.MacroArgument, null);
        node.name = name;
        if (value) {
          if (value[0] == 0)
            node.value = value[1];
          else if (value[0] == 1)
            node.children = value[1];
        }
        return node;
      };
      var peg$f128 = function(str) {
        return Identifier(range(), str.value.substring(1, str.value.length - 1));
      };
      var peg$f129 = function() {
        return Identifier(range(), text());
      };
      var peg$f130 = function() {
        return Identifier(range(), text());
      };
      var peg$f131 = function(sig) {
        return Compound(range(), n.DelegateDecl, [sig]);
      };
      var peg$f132 = function(sig) {
        return Compound(range(), n.EventDecl, [sig]);
      };
      var peg$f133 = function(macro, name) {
        let node = Compound(range(), n.StructDefinition, null);
        node.name = name;
        node.macro = macro;
        return node;
      };
      var peg$f134 = function(macro, name) {
        return Identifier(range(), text());
      };
      var peg$f135 = function(macro, name, superclass) {
        let node = Compound(range(), n.ClassDefinition, null);
        node.name = name;
        node.macro = macro;
        node.superclass = superclass;
        return node;
      };
      var peg$f136 = function(macro, name) {
        let node = Compound(range(), n.EnumDefinition, null);
        node.name = name;
        node.macro = macro;
        return node;
      };
      var peg$f137 = function() {
        return Identifier(range(), text());
      };
      var peg$f138 = function(name) {
        let node = Compound(range(), n.NamespaceDefinition, null);
        node.name = name;
        return node;
      };
      var peg$f139 = function(name, type) {
        let node = Compound(range(), n.AssetDefinition, null);
        node.name = name;
        node.typename = type;
        return node;
      };
      var peg$f140 = function(pre_access, macro, post_access, decl) {
        decl.macro = macro;
        decl.access = pre_access ? pre_access : post_access;
        return decl;
      };
      var peg$f141 = function(name, params) {
        let node = Compound(range(), n.ConstructorDecl, null);
        node.name = name;
        node.parameters = params;
        return node;
      };
      var peg$f142 = function() {
        return Identifier(range(), text());
      };
      var peg$f143 = function(name) {
        let node = Compound(range(), n.DestructorDecl, null);
        node.name = name;
        return node;
      };
      var peg$f144 = function(pre_access, macro, post_access, decl) {
        decl.macro = macro;
        decl.access = pre_access ? pre_access : post_access;
        return decl;
      };
      var peg$f145 = function() {
        return Identifier(range(), text());
      };
      var peg$f146 = function(name, list) {
        let node = Compound(range(), n.AccessDeclaration, null);
        node.name = name;
        node.classList = list ? list : [];
        return node;
      };
      var peg$f147 = function(body) {
        if (!body)
          return null;
        return ExtendedCompound(range(), body);
      };
      var peg$f148 = function(head, tail) {
        return [head].concat(tail);
      };
      var peg$f149 = function() {
        return Identifier(range(), text());
      };
      var peg$f150 = function(name, mods) {
        let node = Compound(range(), n.AccessClass, null);
        node.className = name;
        node.mods = mods;
        return node;
      };
      var peg$f151 = function(head, tail) {
        return [head].concat(tail);
      };
      var peg$f152 = function(name) {
        return Compound(range(), n.IncompleteAccessSpecifier, [name]);
      };
      var peg$f153 = function(expr) {
        return Compound(range(), n.DefaultStatement, [expr]);
      };
      var peg$f154 = function(head, tail) {
        return Compound(range(), n.EnumValueList, [head].concat(tail));
      };
      var peg$f155 = function(comment, name, expr, meta) {
        let node = Compound(range(), n.EnumValue, null);
        node.name = name;
        node.documentation = comment;
        node.value = expr;
        node.meta = meta;
        return node;
      };
      var peg$currPos = 0;
      var peg$savedPos = 0;
      var peg$posDetailsCache = [{ line: 1, column: 1 }];
      var peg$maxFailPos = 0;
      var peg$maxFailExpected = [];
      var peg$silentFails = 0;
      var peg$result;
      if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) {
          throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
        }
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
      }
      function text() {
        return input.substring(peg$savedPos, peg$currPos);
      }
      function offset() {
        return peg$savedPos;
      }
      function range() {
        return {
          source: peg$source,
          start: peg$savedPos,
          end: peg$currPos
        };
      }
      function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
      }
      function expected(description, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError(
          [peg$otherExpectation(description)],
          input.substring(peg$savedPos, peg$currPos),
          location2
        );
      }
      function error(message, location2) {
        location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location2);
      }
      function peg$literalExpectation(text2, ignoreCase) {
        return { type: "literal", text: text2, ignoreCase };
      }
      function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts, inverted, ignoreCase };
      }
      function peg$anyExpectation() {
        return { type: "any" };
      }
      function peg$endExpectation() {
        return { type: "end" };
      }
      function peg$otherExpectation(description) {
        return { type: "other", description };
      }
      function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
          return details;
        } else {
          p = pos - 1;
          while (!peg$posDetailsCache[p]) {
            p--;
          }
          details = peg$posDetailsCache[p];
          details = {
            line: details.line,
            column: details.column
          };
          while (p < pos) {
            if (input.charCodeAt(p) === 10) {
              details.line++;
              details.column = 1;
            } else {
              details.column++;
            }
            p++;
          }
          peg$posDetailsCache[pos] = details;
          return details;
        }
      }
      function peg$computeLocation(startPos, endPos, offset2) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        var res = {
          source: peg$source,
          start: {
            offset: startPos,
            line: startPosDetails.line,
            column: startPosDetails.column
          },
          end: {
            offset: endPos,
            line: endPosDetails.line,
            column: endPosDetails.column
          }
        };
        if (offset2 && peg$source && typeof peg$source.offset === "function") {
          res.start = peg$source.offset(res.start);
          res.end = peg$source.offset(res.end);
        }
        return res;
      }
      function peg$fail(expected2) {
        if (peg$currPos < peg$maxFailPos) {
          return;
        }
        if (peg$currPos > peg$maxFailPos) {
          peg$maxFailPos = peg$currPos;
          peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected2);
      }
      function peg$buildSimpleError(message, location2) {
        return new peg$SyntaxError(message, null, null, location2);
      }
      function peg$buildStructuredError(expected2, found, location2) {
        return new peg$SyntaxError(
          peg$SyntaxError.buildMessage(expected2, found),
          expected2,
          found,
          location2
        );
      }
      function peg$parsestart() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_();
        s2 = peg$parsestatement();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          s0 = s2;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          peg$savedPos = s0;
          s1 = peg$f0();
          s0 = s1;
        }
        return s0;
      }
      function peg$parsestart_global() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_();
        s2 = peg$parseglobal_statement();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          s0 = s2;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecomment_documentation();
          s2 = peg$parseglobal_declaration();
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            peg$savedPos = s0;
            s0 = peg$f1(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();
            peg$savedPos = s0;
            s1 = peg$f2();
            s0 = s1;
          }
        }
        return s0;
      }
      function peg$parsestart_class() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_();
        s2 = peg$parseclass_default_statement();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          s0 = s2;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsecomment_documentation();
          s2 = peg$parseclass_declaration();
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            peg$savedPos = s0;
            s0 = peg$f3(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();
            s2 = peg$parseincomplete_access_specifier();
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              s0 = s2;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parse_();
              peg$savedPos = s0;
              s1 = peg$f4();
              s0 = s1;
            }
          }
        }
        return s0;
      }
      function peg$parsestart_enum() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parseenum_statement();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          peg$savedPos = s0;
          s1 = peg$f5();
          s0 = s1;
        }
        return s0;
      }
      function peg$parsecomment() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 47) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e0);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 42) {
            s2 = peg$c1;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$currPos;
            s5 = peg$currPos;
            peg$silentFails++;
            s6 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 42) {
              s7 = peg$c1;
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            if (s7 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 47) {
                s8 = peg$c0;
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s8 !== peg$FAILED) {
                s7 = [s7, s8];
                s6 = s7;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e2);
                }
              }
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$currPos;
              s5 = peg$currPos;
              peg$silentFails++;
              s6 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 42) {
                s7 = peg$c1;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e1);
                }
              }
              if (s7 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 47) {
                  s8 = peg$c0;
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e0);
                  }
                }
                if (s8 !== peg$FAILED) {
                  s7 = [s7, s8];
                  s6 = s7;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              peg$silentFails--;
              if (s6 === peg$FAILED) {
                s5 = void 0;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e2);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s5 = [s5, s6];
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            }
            if (input.charCodeAt(peg$currPos) === 42) {
              s4 = peg$c1;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e1);
              }
            }
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 47) {
                s5 = peg$c0;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e0);
                }
              }
              if (s5 !== peg$FAILED) {
                s1 = [s1, s2, s3, s4, s5];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s1 = peg$c0;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 47) {
              s2 = peg$c0;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                if (peg$r0.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
              }
              s1 = [s1, s2, s3];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 35) {
              s1 = peg$c2;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e4);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              if (peg$r0.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e3);
                }
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$r0.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e3);
                  }
                }
              }
              s1 = [s1, s2];
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parse__() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = [];
          if (peg$r1.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
          }
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (peg$r2.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e6);
            }
          }
          peg$silentFails--;
          if (s5 !== peg$FAILED) {
            peg$currPos = s4;
            s4 = void 0;
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecomment();
            if (s5 !== peg$FAILED) {
              s6 = [];
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e5);
                  }
                }
              }
              s4 = [s4, s5, s6];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              if (peg$r2.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e6);
                }
              }
              peg$silentFails--;
              if (s5 !== peg$FAILED) {
                peg$currPos = s4;
                s4 = void 0;
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parsecomment();
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  if (peg$r1.test(input.charAt(peg$currPos))) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e5);
                    }
                  }
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    if (peg$r1.test(input.charAt(peg$currPos))) {
                      s7 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e5);
                      }
                    }
                  }
                  s4 = [s4, s5, s6];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parse_() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$r1.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
        }
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        peg$silentFails--;
        if (s5 !== peg$FAILED) {
          peg$currPos = s4;
          s4 = void 0;
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsecomment();
          if (s5 !== peg$FAILED) {
            s6 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
            }
            s4 = [s4, s5, s6];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (peg$r2.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e6);
            }
          }
          peg$silentFails--;
          if (s5 !== peg$FAILED) {
            peg$currPos = s4;
            s4 = void 0;
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsecomment();
            if (s5 !== peg$FAILED) {
              s6 = [];
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e5);
                  }
                }
              }
              s4 = [s4, s5, s6];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        s1 = [s1, s2];
        s0 = s1;
        return s0;
      }
      function peg$parseop_postfix() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s2 = peg$c3;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 43) {
            s3 = peg$c3;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e7);
            }
          }
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s2 = peg$c4;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e8);
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s3 = peg$c4;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e8);
              }
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parseop_binary_logic() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 38) {
          s2 = peg$c5;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 38) {
            s3 = peg$c5;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e9);
            }
          }
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 124) {
            s2 = peg$c6;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 124) {
              s3 = peg$c6;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e10);
              }
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parseop_binary_sum() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s1 = peg$c3;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c7;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          if (s3 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 43) {
              s3 = peg$c3;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e7);
              }
            }
          }
          peg$silentFails--;
          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s1 = peg$c4;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e8);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c7;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e11);
              }
            }
            if (s3 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 45) {
                s3 = peg$c4;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e8);
                }
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseop_binary_product() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 42) {
          s1 = peg$c1;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e1);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c7;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          peg$silentFails--;
          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 47) {
            s1 = peg$c0;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e0);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c7;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e11);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 37) {
              s1 = peg$c8;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e12);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c7;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e11);
                }
              }
              peg$silentFails--;
              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parseop_binary_compare() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 61) {
          s2 = peg$c7;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c7;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 33) {
            s2 = peg$c9;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e13);
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c7;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e11);
              }
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 60) {
              s2 = peg$c10;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e14);
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c7;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e11);
                }
              }
              if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 62) {
                s2 = peg$c11;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e15);
                }
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s3 = peg$c7;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e11);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s2 = [s2, s3];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 62) {
                  s2 = peg$c11;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e15);
                  }
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 62) {
                    s3 = peg$c11;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e15);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s2 = [s2, s3];
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 60) {
                    s2 = peg$c10;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e14);
                    }
                  }
                  if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 60) {
                      s3 = peg$c10;
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e14);
                      }
                    }
                    if (s3 !== peg$FAILED) {
                      s2 = [s2, s3];
                      s1 = s2;
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                  if (s1 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 62) {
                      s1 = peg$c11;
                      peg$currPos++;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e15);
                      }
                    }
                    if (s1 === peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 60) {
                        s1 = peg$c10;
                        peg$currPos++;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e14);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parseop_binary_bitwise() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 124) {
          s1 = peg$c6;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e10);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 124) {
            s3 = peg$c6;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e10);
            }
          }
          if (s3 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c7;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e11);
              }
            }
          }
          peg$silentFails--;
          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 38) {
            s1 = peg$c5;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e9);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 38) {
              s3 = peg$c5;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e9);
              }
            }
            if (s3 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c7;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e11);
                }
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 94) {
              s1 = peg$c12;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e16);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c7;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e11);
                }
              }
              peg$silentFails--;
              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parseop_assignment() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 61) {
          s1 = peg$c7;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e11);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c7;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          peg$silentFails--;
          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseop_compound_assignment() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 43) {
          s2 = peg$c3;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e7);
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c7;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s2 = peg$c4;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e8);
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c7;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e11);
              }
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 47) {
              s2 = peg$c0;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e0);
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 61) {
                s3 = peg$c7;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e11);
                }
              }
              if (s3 !== peg$FAILED) {
                s2 = [s2, s3];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
              s1 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 42) {
                s2 = peg$c1;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e1);
                }
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s3 = peg$c7;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e11);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s2 = [s2, s3];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 === peg$FAILED) {
                s1 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 126) {
                  s2 = peg$c13;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e17);
                  }
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 61) {
                    s3 = peg$c7;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e11);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s2 = [s2, s3];
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
                if (s1 === peg$FAILED) {
                  s1 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 94) {
                    s2 = peg$c12;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e16);
                    }
                  }
                  if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 61) {
                      s3 = peg$c7;
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e11);
                      }
                    }
                    if (s3 !== peg$FAILED) {
                      s2 = [s2, s3];
                      s1 = s2;
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                  if (s1 === peg$FAILED) {
                    s1 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 124) {
                      s2 = peg$c6;
                      peg$currPos++;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e10);
                      }
                    }
                    if (s2 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 61) {
                        s3 = peg$c7;
                        peg$currPos++;
                      } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e11);
                        }
                      }
                      if (s3 !== peg$FAILED) {
                        s2 = [s2, s3];
                        s1 = s2;
                      } else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                    if (s1 === peg$FAILED) {
                      s1 = peg$currPos;
                      if (input.charCodeAt(peg$currPos) === 38) {
                        s2 = peg$c5;
                        peg$currPos++;
                      } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e9);
                        }
                      }
                      if (s2 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 61) {
                          s3 = peg$c7;
                          peg$currPos++;
                        } else {
                          s3 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e11);
                          }
                        }
                        if (s3 !== peg$FAILED) {
                          s2 = [s2, s3];
                          s1 = s2;
                        } else {
                          peg$currPos = s1;
                          s1 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                      }
                      if (s1 === peg$FAILED) {
                        s1 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 37) {
                          s2 = peg$c8;
                          peg$currPos++;
                        } else {
                          s2 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e12);
                          }
                        }
                        if (s2 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 61) {
                            s3 = peg$c7;
                            peg$currPos++;
                          } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e11);
                            }
                          }
                          if (s3 !== peg$FAILED) {
                            s2 = [s2, s3];
                            s1 = s2;
                          } else {
                            peg$currPos = s1;
                            s1 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$FAILED;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parseop_unary() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s1 = peg$c9;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c7;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          peg$silentFails--;
          if (s3 === peg$FAILED) {
            s2 = void 0;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 126) {
            s1 = peg$c13;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e17);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 61) {
              s3 = peg$c7;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e11);
              }
            }
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseglobal_statement() {
        var s0;
        s0 = peg$parseimport_statement();
        if (s0 === peg$FAILED) {
          s0 = peg$parseimport_function_statement();
        }
        return s0;
      }
      function peg$parseglobal_declaration() {
        var s0, s1, s2, s3, s4;
        s0 = peg$parsedelegate_decl();
        if (s0 === peg$FAILED) {
          s0 = peg$parseevent_decl();
          if (s0 === peg$FAILED) {
            s0 = peg$parsestruct_decl();
            if (s0 === peg$FAILED) {
              s0 = peg$parseclass_decl();
              if (s0 === peg$FAILED) {
                s0 = peg$parseenum_decl();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsenamespace_decl();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseasset_decl();
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = peg$currPos;
                      s2 = peg$parseufunction_macro();
                      if (s2 !== peg$FAILED) {
                        s3 = peg$parse_();
                        s1 = s2;
                      } else {
                        peg$currPos = s1;
                        s1 = peg$FAILED;
                      }
                      if (s1 === peg$FAILED) {
                        s1 = null;
                      }
                      s2 = peg$currPos;
                      if (input.substr(peg$currPos, 5) === peg$c14) {
                        s3 = peg$c14;
                        peg$currPos += 5;
                      } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e18);
                        }
                      }
                      if (s3 === peg$FAILED) {
                        if (input.substr(peg$currPos, 5) === peg$c15) {
                          s3 = peg$c15;
                          peg$currPos += 5;
                        } else {
                          s3 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e19);
                          }
                        }
                      }
                      if (s3 !== peg$FAILED) {
                        s4 = peg$parse_();
                        s2 = s3;
                      } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                      }
                      if (s2 === peg$FAILED) {
                        s2 = null;
                      }
                      s3 = peg$parsefunction_signature();
                      if (s3 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f6(s1, s2, s3);
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsevar_decl();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseincomplete_var_decl();
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parseclass_declaration() {
        var s0;
        s0 = peg$parseaccess_decl();
        if (s0 === peg$FAILED) {
          s0 = peg$parseconstructor_decl();
          if (s0 === peg$FAILED) {
            s0 = peg$parsedestructor_decl();
            if (s0 === peg$FAILED) {
              s0 = peg$parseclass_method_decl();
              if (s0 === peg$FAILED) {
                s0 = peg$parseclass_property_decl();
              }
            }
          }
        }
        return s0;
      }
      function peg$parsestatement() {
        var s0;
        s0 = peg$parseif_statement();
        if (s0 === peg$FAILED) {
          s0 = peg$parsereturn_statement();
          if (s0 === peg$FAILED) {
            s0 = peg$parseelse_statement();
            if (s0 === peg$FAILED) {
              s0 = peg$parseswitch_statement();
              if (s0 === peg$FAILED) {
                s0 = peg$parsecontinue_statement();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsebreak_statement();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsewhile_statement();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsefor_statement();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsecase_statement();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parsedefault_case_statement();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsefallthrough_statement();
                            if (s0 === peg$FAILED) {
                              s0 = peg$parsevar_decl();
                              if (s0 === peg$FAILED) {
                                s0 = peg$parseassignment();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$parseincomplete_var_decl();
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parseoptional_statement() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_();
        s2 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        peg$silentFails--;
        if (s3 !== peg$FAILED) {
          peg$currPos = s2;
          s2 = void 0;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsestatement();
          if (s3 !== peg$FAILED) {
            s0 = s3;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = null;
        }
        return s0;
      }
      function peg$parseoptional_expression() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseexpression();
          if (s2 !== peg$FAILED) {
            s0 = s2;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = null;
        }
        return s0;
      }
      function peg$parseoptional_assignment() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parse_();
        s2 = peg$currPos;
        peg$silentFails++;
        if (input.length > peg$currPos) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e2);
          }
        }
        peg$silentFails--;
        if (s3 !== peg$FAILED) {
          peg$currPos = s2;
          s2 = void 0;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseassignment();
          if (s3 !== peg$FAILED) {
            s0 = s3;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = null;
        }
        return s0;
      }
      function peg$parseif_statement() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 105) {
          s2 = peg$c16;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c17) {
            s2 = peg$c17;
            peg$currPos += 2;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e21);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c18;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              s6 = peg$parseoptional_expression();
              if (input.charCodeAt(peg$currPos) === 41) {
                s7 = peg$c19;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parseoptional_statement();
                peg$savedPos = s0;
                s0 = peg$f7(s6, s8);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsereturn_statement() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 114) {
          s2 = peg$c20;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e24);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c21) {
            s2 = peg$c21;
            peg$currPos += 6;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e25);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            s4 = peg$parseoptional_expression();
            peg$savedPos = s0;
            s0 = peg$f8(s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseelse_statement() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 101) {
          s2 = peg$c22;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e26);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c23) {
            s2 = peg$c23;
            peg$currPos += 4;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e27);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseoptional_statement();
            peg$savedPos = s0;
            s0 = peg$f9(s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseswitch_statement() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 115) {
          s2 = peg$c24;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e28);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c25) {
            s2 = peg$c25;
            peg$currPos += 6;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e29);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c18;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              s6 = peg$parseoptional_expression();
              if (input.charCodeAt(peg$currPos) === 41) {
                s7 = peg$c19;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s7 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f10(s6);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsefor_statement() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 102) {
          s2 = peg$c26;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e30);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c27) {
            s2 = peg$c27;
            peg$currPos += 3;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e31);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c18;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = peg$currPos;
              s7 = peg$parse_();
              s8 = peg$parsefor_declaration();
              if (s8 !== peg$FAILED) {
                s6 = s8;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              s7 = peg$currPos;
              s8 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 59) {
                s9 = peg$c28;
                peg$currPos++;
              } else {
                s9 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e32);
                }
              }
              if (s9 !== peg$FAILED) {
                s10 = peg$parse_();
                s11 = peg$parseoptional_expression();
                s12 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 59) {
                  s13 = peg$c28;
                  peg$currPos++;
                } else {
                  s13 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e32);
                  }
                }
                if (s13 !== peg$FAILED) {
                  s14 = peg$parse_();
                  s15 = peg$parsefor_comma_expression_list();
                  if (s15 === peg$FAILED) {
                    s15 = null;
                  }
                  s12 = s15;
                } else {
                  peg$currPos = s12;
                  s12 = peg$FAILED;
                }
                if (s12 === peg$FAILED) {
                  s12 = null;
                }
                peg$savedPos = s7;
                s7 = peg$f11(s6, s11, s12);
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 === peg$FAILED) {
                s7 = null;
              }
              if (input.charCodeAt(peg$currPos) === 41) {
                s8 = peg$c19;
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s8 !== peg$FAILED) {
                s9 = peg$parseoptional_statement();
                peg$savedPos = s5;
                s5 = peg$f12(s6, s7, s9);
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 === peg$FAILED) {
                s5 = peg$currPos;
                s6 = peg$parse_();
                s7 = peg$parsetypename();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  s9 = peg$parseidentifier();
                  if (s9 !== peg$FAILED) {
                    s10 = peg$parse_();
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s11 = peg$c29;
                      peg$currPos++;
                    } else {
                      s11 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e33);
                      }
                    }
                    if (s11 !== peg$FAILED) {
                      s12 = peg$parse_();
                      s13 = peg$parseoptional_expression();
                      if (input.charCodeAt(peg$currPos) === 41) {
                        s14 = peg$c19;
                        peg$currPos++;
                      } else {
                        s14 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e23);
                        }
                      }
                      if (s14 !== peg$FAILED) {
                        s15 = peg$parseoptional_statement();
                        peg$savedPos = s5;
                        s5 = peg$f13(s7, s9, s13, s15);
                      } else {
                        peg$currPos = s5;
                        s5 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f14(s5);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsefor_declaration() {
        var s0;
        s0 = peg$parsevar_decl();
        if (s0 === peg$FAILED) {
          s0 = peg$parseassignment();
        }
        return s0;
      }
      function peg$parsefor_comma_expression_list() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseassignment();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c30;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            s7 = peg$parseassignment();
            if (s7 !== peg$FAILED) {
              s3 = s7;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c30;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              s7 = peg$parseassignment();
              if (s7 !== peg$FAILED) {
                s3 = s7;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f15(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecase_statement() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 99) {
          s2 = peg$c31;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e35);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c32) {
            s2 = peg$c32;
            peg$currPos += 4;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e36);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            s4 = peg$currPos;
            s5 = peg$parsecase_label();
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              s7 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 58) {
                s8 = peg$c29;
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e33);
                }
              }
              if (s8 !== peg$FAILED) {
                s9 = peg$parse_();
                s10 = peg$parsestatement();
                if (s10 !== peg$FAILED) {
                  peg$savedPos = s6;
                  s6 = peg$f16(s5, s10);
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 === peg$FAILED) {
                s6 = peg$currPos;
                s7 = peg$parse_();
                if (input.charCodeAt(peg$currPos) === 58) {
                  s8 = peg$c29;
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e33);
                  }
                }
                if (s8 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s9 = peg$c29;
                    peg$currPos++;
                  } else {
                    s9 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e33);
                    }
                  }
                  if (s9 !== peg$FAILED) {
                    peg$savedPos = s6;
                    s6 = peg$f17(s5);
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 === peg$FAILED) {
                  s6 = peg$currPos;
                  s7 = peg$parse_();
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s8 = peg$c29;
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e33);
                    }
                  }
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s6;
                    s6 = peg$f18(s5);
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                }
              }
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              peg$savedPos = s4;
              s4 = peg$f19(s5, s6);
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f20(s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedefault_case_statement() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 100) {
          s2 = peg$c33;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e37);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 7) === peg$c34) {
            s2 = peg$c34;
            peg$currPos += 7;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e38);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c29;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e33);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseoptional_statement();
              peg$savedPos = s0;
              s0 = peg$f21(s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecase_label() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 40) {
          s1 = peg$c18;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e22);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          s3 = peg$parsecase_label();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 41) {
              s5 = peg$c19;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
            if (s5 !== peg$FAILED) {
              s0 = s3;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 45) {
            s2 = peg$c4;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e8);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          s2 = [];
          if (peg$r3.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e39);
            }
          }
          if (s3 !== peg$FAILED) {
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$r3.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e39);
                }
              }
            }
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f22();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parsenamespaced_identifier_no_trailing();
          }
        }
        return s0;
      }
      function peg$parsecontinue_statement() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 99) {
          s2 = peg$c31;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e35);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c35) {
            s2 = peg$c35;
            peg$currPos += 8;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e40);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f23(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebreak_statement() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 98) {
          s2 = peg$c36;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e41);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c37) {
            s2 = peg$c37;
            peg$currPos += 5;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e42);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f24(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsefallthrough_statement() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 102) {
          s2 = peg$c26;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e30);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 11) === peg$c38) {
            s2 = peg$c38;
            peg$currPos += 11;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e43);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f25(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsewhile_statement() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 119) {
          s2 = peg$c39;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e44);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c40) {
            s2 = peg$c40;
            peg$currPos += 5;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e45);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c18;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              s6 = peg$parseoptional_expression();
              if (input.charCodeAt(peg$currPos) === 41) {
                s7 = peg$c19;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parseoptional_statement();
                peg$savedPos = s0;
                s0 = peg$f26(s6, s8);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseassignment() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseexpression();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parseop_assignment();
          if (s4 === peg$FAILED) {
            s4 = peg$parseop_compound_assignment();
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            s6 = peg$parseexpression();
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            peg$savedPos = s3;
            s3 = peg$f27(s1, s4, s6);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parseop_assignment();
            if (s4 === peg$FAILED) {
              s4 = peg$parseop_compound_assignment();
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              s6 = peg$parseexpression();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              peg$savedPos = s3;
              s3 = peg$f27(s1, s4, s6);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f28(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsevar_decl() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$parsetypename();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          s3 = peg$parsevar_decl_part();
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            s6 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 44) {
              s7 = peg$c30;
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s7 !== peg$FAILED) {
              s8 = peg$parse_();
              s9 = peg$parsevar_decl_part();
              if (s9 !== peg$FAILED) {
                s5 = s9;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$currPos;
              s6 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 44) {
                s7 = peg$c30;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e34);
                }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                s9 = peg$parsevar_decl_part();
                if (s9 !== peg$FAILED) {
                  s5 = s9;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            }
            peg$savedPos = s0;
            s0 = peg$f29(s1, s3, s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsevar_decl_part() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseidentifier();
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 61) {
            s4 = peg$c7;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            s6 = peg$parse_();
            s7 = peg$parseexpression();
            if (s7 !== peg$FAILED) {
              s5 = s7;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            peg$savedPos = s2;
            s2 = peg$f30(s1, s5);
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c18;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              s6 = peg$parseargument_list_or_typename();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              if (input.charCodeAt(peg$currPos) === 41) {
                s7 = peg$c19;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s7 !== peg$FAILED) {
                peg$savedPos = s2;
                s2 = peg$f31(s1, s6);
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;
              s3 = peg$currPos;
              s4 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 61) {
                s5 = peg$c7;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e11);
                }
              }
              if (s5 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 40) {
                  s5 = peg$c18;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e22);
                  }
                }
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              peg$silentFails--;
              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f32(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseincomplete_var_decl() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parsetypename();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f33(s1);
        }
        s0 = s1;
        return s0;
      }
      function peg$parsetypename() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parseconst_qualifier();
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s2 = peg$parseunqualified_typename();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseref_qualifiers();
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f34(s1, s2, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseconst_qualifier() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 99) {
          s2 = peg$c31;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e35);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c41) {
            s2 = peg$c41;
            peg$currPos += 5;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e46);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            peg$savedPos = s0;
            s0 = peg$f35(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseref_qualifiers() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (input.charCodeAt(peg$currPos) === 38) {
          s2 = peg$c5;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e9);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parse_();
          s5 = peg$currPos;
          s6 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 105) {
            s7 = peg$c16;
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          peg$silentFails--;
          if (s7 !== peg$FAILED) {
            peg$currPos = s6;
            s6 = void 0;
          } else {
            s6 = peg$FAILED;
          }
          if (s6 !== peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c42) {
              s7 = peg$c42;
              peg$currPos += 5;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e47);
              }
            }
            if (s7 === peg$FAILED) {
              if (input.substr(peg$currPos, 2) === peg$c43) {
                s7 = peg$c43;
                peg$currPos += 2;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e48);
                }
              }
            }
            if (s7 !== peg$FAILED) {
              s5 = s7;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 === peg$FAILED) {
            s5 = peg$currPos;
            s6 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 111) {
              s7 = peg$c44;
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e49);
              }
            }
            peg$silentFails--;
            if (s7 !== peg$FAILED) {
              peg$currPos = s6;
              s6 = void 0;
            } else {
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              if (input.substr(peg$currPos, 3) === peg$c45) {
                s7 = peg$c45;
                peg$currPos += 3;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e50);
                }
              }
              if (s7 !== peg$FAILED) {
                s5 = s7;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$currPos;
            peg$silentFails++;
            s7 = peg$parseidentifier_char();
            peg$silentFails--;
            if (s7 === peg$FAILED) {
              s6 = void 0;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s3 = s5;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f36(s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsetemplate_typename() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsetypename_name();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          peg$silentFails++;
          s4 = peg$parseidentifier_char();
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f37();
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 60) {
            s4 = peg$c10;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e14);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            s6 = peg$parse_();
            s7 = peg$parsetypename();
            if (s7 !== peg$FAILED) {
              s8 = [];
              s9 = peg$currPos;
              s10 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 44) {
                s11 = peg$c30;
                peg$currPos++;
              } else {
                s11 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e34);
                }
              }
              if (s11 !== peg$FAILED) {
                s12 = peg$parse_();
                s13 = peg$parsetypename();
                if (s13 !== peg$FAILED) {
                  s9 = s13;
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
              } else {
                peg$currPos = s9;
                s9 = peg$FAILED;
              }
              while (s9 !== peg$FAILED) {
                s8.push(s9);
                s9 = peg$currPos;
                s10 = peg$parse_();
                if (input.charCodeAt(peg$currPos) === 44) {
                  s11 = peg$c30;
                  peg$currPos++;
                } else {
                  s11 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e34);
                  }
                }
                if (s11 !== peg$FAILED) {
                  s12 = peg$parse_();
                  s13 = peg$parsetypename();
                  if (s13 !== peg$FAILED) {
                    s9 = s13;
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
              }
              peg$savedPos = s5;
              s5 = peg$f38(s1, s7, s8);
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            s6 = peg$currPos;
            s7 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 44) {
              s8 = peg$c30;
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s8 !== peg$FAILED) {
              s7 = [s7, s8];
              s6 = s7;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            s7 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 62) {
              s8 = peg$c11;
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e15);
              }
            }
            if (s8 !== peg$FAILED) {
              peg$savedPos = s2;
              s2 = peg$f39(s1, s5);
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f40(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseprimitive_typename() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parseprimitive_types();
        if (s1 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$f41();
        }
        s0 = s1;
        return s0;
      }
      function peg$parseunqualified_typename() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$currPos;
        s3 = [];
        s4 = peg$parsetypename_name();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$currPos;
          s5 = peg$currPos;
          s6 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 58) {
            s7 = peg$c29;
            peg$currPos++;
          } else {
            s7 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e33);
            }
          }
          if (s7 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s8 = peg$c29;
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e33);
              }
            }
            if (s8 !== peg$FAILED) {
              s9 = peg$parse_();
              s6 = [s6, s7, s8, s9];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s5 = peg$parsetypename_name();
            if (s5 === peg$FAILED) {
              peg$currPos = s4;
              s4 = peg$FAILED;
            } else {
              s4 = s5;
            }
          } else {
            s4 = s5;
          }
        }
        if (s3.length < 1) {
          peg$currPos = s2;
          s2 = peg$FAILED;
        } else {
          s2 = s3;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s1;
          s2 = peg$f42(s2);
        }
        s1 = s2;
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 60) {
            s4 = peg$c10;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e14);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            s6 = peg$parse_();
            s7 = peg$parsetypename();
            if (s7 !== peg$FAILED) {
              s8 = [];
              s9 = peg$currPos;
              s10 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 44) {
                s11 = peg$c30;
                peg$currPos++;
              } else {
                s11 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e34);
                }
              }
              if (s11 !== peg$FAILED) {
                s12 = peg$parse_();
                s13 = peg$parsetypename();
                if (s13 !== peg$FAILED) {
                  s9 = s13;
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
              } else {
                peg$currPos = s9;
                s9 = peg$FAILED;
              }
              while (s9 !== peg$FAILED) {
                s8.push(s9);
                s9 = peg$currPos;
                s10 = peg$parse_();
                if (input.charCodeAt(peg$currPos) === 44) {
                  s11 = peg$c30;
                  peg$currPos++;
                } else {
                  s11 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e34);
                  }
                }
                if (s11 !== peg$FAILED) {
                  s12 = peg$parse_();
                  s13 = peg$parsetypename();
                  if (s13 !== peg$FAILED) {
                    s9 = s13;
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
              }
              peg$savedPos = s5;
              s5 = peg$f43(s1, s7, s8);
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            s6 = peg$currPos;
            s7 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 44) {
              s8 = peg$c30;
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s8 !== peg$FAILED) {
              s7 = [s7, s8];
              s6 = s7;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            s7 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 62) {
              s8 = peg$c11;
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e15);
              }
            }
            if (s8 !== peg$FAILED) {
              peg$savedPos = s2;
              s2 = peg$f44(s1, s5);
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f45(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseexpression() {
        var s0, s1, s2, s3;
        s0 = peg$parseexpr_ternary();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsekeyword();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            peg$silentFails++;
            s3 = peg$parseidentifier_char();
            peg$silentFails--;
            if (s3 === peg$FAILED) {
              s2 = void 0;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              peg$savedPos = s0;
              s0 = peg$f46();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseprimary_expression() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 116) {
          s2 = peg$c46;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e51);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c47) {
            s2 = peg$c47;
            peg$currPos += 4;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e52);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            peg$savedPos = s0;
            s0 = peg$f47(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c18;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e22);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            s3 = peg$parseoptional_expression();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s4 = peg$c19;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                s0 = s3;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsenamespaced_identifier();
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              s3 = peg$currPos;
              peg$silentFails++;
              s4 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 60) {
                s5 = peg$c10;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e14);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                s7 = [];
                s8 = peg$parsetypename();
                while (s8 !== peg$FAILED) {
                  s7.push(s8);
                  s8 = peg$currPos;
                  s9 = peg$currPos;
                  s10 = peg$parse_();
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s11 = peg$c30;
                    peg$currPos++;
                  } else {
                    s11 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e34);
                    }
                  }
                  if (s11 !== peg$FAILED) {
                    s12 = peg$parse_();
                    s10 = [s10, s11, s12];
                    s9 = s10;
                  } else {
                    peg$currPos = s9;
                    s9 = peg$FAILED;
                  }
                  if (s9 !== peg$FAILED) {
                    s9 = peg$parsetypename();
                    if (s9 === peg$FAILED) {
                      peg$currPos = s8;
                      s8 = peg$FAILED;
                    } else {
                      s8 = s9;
                    }
                  } else {
                    s8 = s9;
                  }
                }
                s8 = peg$parse_();
                if (input.charCodeAt(peg$currPos) === 62) {
                  s9 = peg$c11;
                  peg$currPos++;
                } else {
                  s9 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e15);
                  }
                }
                if (s9 !== peg$FAILED) {
                  s10 = peg$parse_();
                  if (input.charCodeAt(peg$currPos) === 40) {
                    s11 = peg$c18;
                    peg$currPos++;
                  } else {
                    s11 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e22);
                    }
                  }
                  if (s11 !== peg$FAILED) {
                    s5 = [s5, s6, s7, s8, s9, s10, s11];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = void 0;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsecast_expression();
              if (s1 !== peg$FAILED) {
                s2 = peg$parse_();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseconstructor_call();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parse_();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsenamespaced_identifier() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 58) {
          s2 = peg$c29;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e33);
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s3 = peg$c29;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e33);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s2 = peg$parseidentifier();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          s5 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 58) {
            s6 = peg$c29;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e33);
            }
          }
          if (s6 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s7 = peg$c29;
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e33);
              }
            }
            if (s7 !== peg$FAILED) {
              s8 = peg$parse_();
              s9 = peg$parseidentifier();
              if (s9 === peg$FAILED) {
                s9 = null;
              }
              s4 = s9;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            s5 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 58) {
              s6 = peg$c29;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e33);
              }
            }
            if (s6 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s7 = peg$c29;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e33);
                }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                s9 = peg$parseidentifier();
                if (s9 === peg$FAILED) {
                  s9 = null;
                }
                s4 = s9;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c29;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e33);
            }
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f48(s1, s2, s3, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenamespaced_identifier_no_trailing() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 58) {
          s2 = peg$c29;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e33);
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s3 = peg$c29;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e33);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s2 = peg$parseidentifier();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$currPos;
          s5 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 58) {
            s6 = peg$c29;
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e33);
            }
          }
          if (s6 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s7 = peg$c29;
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e33);
              }
            }
            if (s7 !== peg$FAILED) {
              s8 = peg$parse_();
              s9 = peg$parseidentifier();
              if (s9 !== peg$FAILED) {
                s4 = s9;
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$currPos;
            s5 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 58) {
              s6 = peg$c29;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e33);
              }
            }
            if (s6 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s7 = peg$c29;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e33);
                }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                s9 = peg$parseidentifier();
                if (s9 !== peg$FAILED) {
                  s4 = s9;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f49(s1, s2, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecall_expression() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parseprimary_expression();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s5 = peg$c18;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e22);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            s7 = peg$parseargument_list();
            if (s7 === peg$FAILED) {
              s7 = null;
            }
            if (input.charCodeAt(peg$currPos) === 41) {
              s8 = peg$c19;
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
            if (s8 !== peg$FAILED) {
              peg$savedPos = s4;
              s4 = peg$f50(s1, s7);
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 === peg$FAILED) {
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s5 = peg$c48;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e53);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              s7 = peg$parseoptional_expression();
              if (s7 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s8 = peg$c49;
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e54);
                  }
                }
                if (s8 !== peg$FAILED) {
                  peg$savedPos = s4;
                  s4 = peg$f51(s1, s7);
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 === peg$FAILED) {
              s4 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 46) {
                s5 = peg$c50;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e55);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$currPos;
                s7 = peg$parse_();
                s8 = peg$parseidentifier();
                if (s8 !== peg$FAILED) {
                  s6 = s8;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                if (s6 === peg$FAILED) {
                  s6 = null;
                }
                peg$savedPos = s4;
                s4 = peg$f52(s1, s6);
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 40) {
              s5 = peg$c18;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              s7 = peg$parseargument_list();
              if (s7 === peg$FAILED) {
                s7 = null;
              }
              if (input.charCodeAt(peg$currPos) === 41) {
                s8 = peg$c19;
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s8 !== peg$FAILED) {
                peg$savedPos = s4;
                s4 = peg$f50(s1, s7);
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 === peg$FAILED) {
              s4 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 91) {
                s5 = peg$c48;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e53);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                s7 = peg$parseoptional_expression();
                if (s7 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s8 = peg$c49;
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e54);
                    }
                  }
                  if (s8 !== peg$FAILED) {
                    peg$savedPos = s4;
                    s4 = peg$f51(s1, s7);
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 === peg$FAILED) {
                s4 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 46) {
                  s5 = peg$c50;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e55);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$currPos;
                  s7 = peg$parse_();
                  s8 = peg$parseidentifier();
                  if (s8 !== peg$FAILED) {
                    s6 = s8;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                  if (s6 === peg$FAILED) {
                    s6 = null;
                  }
                  peg$savedPos = s4;
                  s4 = peg$f52(s1, s6);
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f53(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseargument_list() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseargument();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s4 = peg$c30;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            s6 = peg$parseargument();
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            s3 = s6;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s4 = peg$c30;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              s6 = peg$parseargument();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              s3 = s6;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f54(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 44) {
            s1 = peg$c30;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f55();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseargument_list_or_typename() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parsetypename_name();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          s3 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 41) {
            s4 = peg$c19;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e23);
            }
          }
          peg$silentFails--;
          if (s4 !== peg$FAILED) {
            peg$currPos = s3;
            s3 = void 0;
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f56(s1);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsetemplate_typename();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            s3 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 41) {
              s4 = peg$c19;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
            peg$silentFails--;
            if (s4 !== peg$FAILED) {
              peg$currPos = s3;
              s3 = void 0;
            } else {
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f57(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseargument_list();
          }
        }
        return s0;
      }
      function peg$parseargument() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$parseidentifier();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          s3 = peg$parseop_assignment();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            s5 = peg$parseoptional_expression();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f58(s1, s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseexpression();
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$currPos;
            peg$silentFails++;
            if (peg$r4.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e56);
              }
            }
            peg$silentFails--;
            if (s4 === peg$FAILED) {
              s3 = void 0;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              s4 = peg$parseexpression();
              if (s4 !== peg$FAILED) {
                s2 = s4;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 === peg$FAILED) {
              s2 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f59(s1, s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseexpr_ternary() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = peg$parseexpr_binary_compare();
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 63) {
            s3 = peg$c51;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e57);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            s5 = peg$currPos;
            s6 = peg$parseexpression();
            if (s6 !== peg$FAILED) {
              s7 = peg$currPos;
              s8 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 58) {
                s9 = peg$c29;
                peg$currPos++;
              } else {
                s9 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e33);
                }
              }
              if (s9 !== peg$FAILED) {
                s10 = peg$parse_();
                s9 = [s9, s10];
                s8 = s9;
              } else {
                peg$currPos = s8;
                s8 = peg$FAILED;
              }
              if (s8 === peg$FAILED) {
                s8 = null;
              }
              s9 = peg$parseoptional_expression();
              if (s9 !== peg$FAILED) {
                s7 = [s8, s9];
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              if (s7 === peg$FAILED) {
                s7 = null;
              }
              peg$savedPos = s5;
              s5 = peg$f60(s1, s6, s7);
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            peg$savedPos = s2;
            s2 = peg$f61(s1, s5);
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f62(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseexpr_binary_compare() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseexpr_binary_logic();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parseop_binary_compare();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            s6 = peg$parseexpr_binary_logic();
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            peg$savedPos = s3;
            s3 = peg$f63(s1, s4, s6);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parseop_binary_compare();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              s6 = peg$parseexpr_binary_logic();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              peg$savedPos = s3;
              s3 = peg$f63(s1, s4, s6);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f64(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseexpr_binary_logic() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseexpr_binary_bitwise();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parseop_binary_logic();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            s6 = peg$parseexpr_binary_bitwise();
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            peg$savedPos = s3;
            s3 = peg$f65(s1, s4, s6);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parseop_binary_logic();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              s6 = peg$parseexpr_binary_bitwise();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              peg$savedPos = s3;
              s3 = peg$f65(s1, s4, s6);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f66(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseexpr_binary_bitwise() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseexpr_binary_sum();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parseop_binary_bitwise();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            s6 = peg$parseexpr_binary_sum();
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            peg$savedPos = s3;
            s3 = peg$f67(s1, s4, s6);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parseop_binary_bitwise();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              s6 = peg$parseexpr_binary_sum();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              peg$savedPos = s3;
              s3 = peg$f67(s1, s4, s6);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f68(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseexpr_binary_sum() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseexpr_binary_product();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parseop_binary_sum();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            s6 = peg$parseexpr_binary_product();
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            peg$savedPos = s3;
            s3 = peg$f69(s1, s4, s6);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parseop_binary_sum();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              s6 = peg$parseexpr_binary_product();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              peg$savedPos = s3;
              s3 = peg$f69(s1, s4, s6);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f70(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseexpr_binary_product() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseexpr_unary();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parseop_binary_product();
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            s6 = peg$parseexpr_unary();
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            peg$savedPos = s3;
            s3 = peg$f71(s1, s4, s6);
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parseop_binary_product();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              s6 = peg$parseexpr_unary();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              peg$savedPos = s3;
              s3 = peg$f71(s1, s4, s6);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          peg$savedPos = s0;
          s0 = peg$f72(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseexpr_unary() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parseop_unary();
        if (s1 === peg$FAILED) {
          s1 = peg$parseop_binary_sum();
          if (s1 === peg$FAILED) {
            s1 = peg$parseop_postfix();
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          s3 = peg$parseexpr_unary();
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            peg$savedPos = s0;
            s0 = peg$f73(s1, s3);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseexpr_postfix();
        }
        return s0;
      }
      function peg$parseexpr_postfix() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseexpr_leaf();
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parseop_postfix();
          if (s3 === peg$FAILED) {
            s3 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 33) {
              s4 = peg$c9;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e13);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 61) {
                s6 = peg$c7;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e11);
                }
              }
              peg$silentFails--;
              if (s6 === peg$FAILED) {
                s5 = void 0;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f74(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseexpr_leaf() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parsecall_expression();
        if (s1 !== peg$FAILED) {
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseconstant();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseop_unary();
            if (s1 === peg$FAILED) {
              s1 = peg$parseop_binary_sum();
              if (s1 === peg$FAILED) {
                s1 = peg$parseop_postfix();
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parse_();
              peg$savedPos = s0;
              s0 = peg$f75(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
        }
        return s0;
      }
      function peg$parsecast_expression() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 67) {
          s2 = peg$c52;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e58);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c53) {
            s2 = peg$c53;
            peg$currPos += 4;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e59);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 60) {
              s5 = peg$c10;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e14);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              s7 = peg$parsetypename();
              if (s7 !== peg$FAILED) {
                s8 = peg$parse_();
                if (input.charCodeAt(peg$currPos) === 62) {
                  s9 = peg$c11;
                  peg$currPos++;
                } else {
                  s9 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e15);
                  }
                }
                if (s9 !== peg$FAILED) {
                  s10 = peg$parse_();
                  if (input.charCodeAt(peg$currPos) === 40) {
                    s11 = peg$c18;
                    peg$currPos++;
                  } else {
                    s11 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e22);
                    }
                  }
                  if (s11 !== peg$FAILED) {
                    s12 = peg$parse_();
                    s13 = peg$parseoptional_expression();
                    if (s13 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 41) {
                        s14 = peg$c19;
                        peg$currPos++;
                      } else {
                        s14 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e23);
                        }
                      }
                      if (s14 !== peg$FAILED) {
                        peg$savedPos = s4;
                        s4 = peg$f76(s7, s13);
                      } else {
                        peg$currPos = s4;
                        s4 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 === peg$FAILED) {
              s4 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 60) {
                s5 = peg$c10;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e14);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                s7 = peg$parsetypename();
                if (s7 !== peg$FAILED) {
                  s8 = peg$currPos;
                  s9 = peg$parse_();
                  if (input.charCodeAt(peg$currPos) === 62) {
                    s10 = peg$c11;
                    peg$currPos++;
                  } else {
                    s10 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e15);
                    }
                  }
                  if (s10 !== peg$FAILED) {
                    s9 = [s9, s10];
                    s8 = s9;
                  } else {
                    peg$currPos = s8;
                    s8 = peg$FAILED;
                  }
                  if (s8 === peg$FAILED) {
                    s8 = null;
                  }
                  peg$savedPos = s4;
                  s4 = peg$f77(s7);
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 === peg$FAILED) {
                s4 = peg$currPos;
                s5 = peg$currPos;
                s6 = peg$parse_();
                if (input.charCodeAt(peg$currPos) === 60) {
                  s7 = peg$c10;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e14);
                  }
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
                if (s5 === peg$FAILED) {
                  s5 = null;
                }
                peg$savedPos = s4;
                s5 = peg$f78();
                s4 = s5;
              }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f79(s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseconstructor_call() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parsetemplate_typename();
        if (s1 === peg$FAILED) {
          s1 = peg$parseprimitive_typename();
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c18;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e22);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            s5 = peg$parseargument_list();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (input.charCodeAt(peg$currPos) === 41) {
              s6 = peg$c19;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
            if (s6 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f80(s1, s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseconstant() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 116) {
          s2 = peg$c46;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e51);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c54) {
            s2 = peg$c54;
            peg$currPos += 4;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e60);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            peg$silentFails++;
            s4 = peg$parseidentifier_char();
            peg$silentFails--;
            if (s4 === peg$FAILED) {
              s3 = void 0;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f81();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 102) {
            s2 = peg$c26;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e30);
            }
          }
          peg$silentFails--;
          if (s2 !== peg$FAILED) {
            peg$currPos = s1;
            s1 = void 0;
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c55) {
              s2 = peg$c55;
              peg$currPos += 5;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e61);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              peg$silentFails++;
              s4 = peg$parseidentifier_char();
              peg$silentFails--;
              if (s4 === peg$FAILED) {
                s3 = void 0;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f82();
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 110) {
              s2 = peg$c56;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e62);
              }
            }
            peg$silentFails--;
            if (s2 !== peg$FAILED) {
              peg$currPos = s1;
              s1 = void 0;
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.substr(peg$currPos, 7) === peg$c57) {
                s2 = peg$c57;
                peg$currPos += 7;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e63);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                peg$silentFails++;
                s4 = peg$parseidentifier_char();
                peg$silentFails--;
                if (s4 === peg$FAILED) {
                  s3 = void 0;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f83();
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              s2 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 48) {
                s3 = peg$c58;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e64);
                }
              }
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 120) {
                  s4 = peg$c59;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e65);
                  }
                }
                if (s4 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 98) {
                    s4 = peg$c36;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e41);
                    }
                  }
                  if (s4 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 111) {
                      s4 = peg$c44;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e49);
                      }
                    }
                  }
                }
                if (s4 !== peg$FAILED) {
                  s3 = [s3, s4];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = void 0;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsedecimal_literal();
                if (s2 !== peg$FAILED) {
                  s0 = s2;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parsename_literal();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsestring_literal();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parsefstring_literal();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsechar_literal();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parsehex_literal();
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseoctal_literal();
                          if (s0 === peg$FAILED) {
                            s0 = peg$parsebinary_literal();
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsestring_literal() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 34) {
          s1 = peg$c60;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e66);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c60;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e66);
            }
          }
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c60;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e66);
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parsemultiline_string_content();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parsemultiline_string_content();
              }
              if (input.charCodeAt(peg$currPos) === 34) {
                s5 = peg$c60;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e66);
                }
              }
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 34) {
                  s6 = peg$c60;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e66);
                  }
                }
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 34) {
                    s7 = peg$c60;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e66);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f84();
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c60;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e66);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsestring_content();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsestring_content();
            }
            if (input.charCodeAt(peg$currPos) === 34) {
              s3 = peg$c60;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e66);
              }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f85();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parsestring_content() {
        var s0, s1;
        s0 = [];
        if (peg$r5.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e67);
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            if (peg$r5.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e67);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseescape_sequence();
        }
        return s0;
      }
      function peg$parsemultiline_string_content() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 92) {
          s2 = peg$c61;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e68);
          }
        }
        if (s2 === peg$FAILED) {
          if (input.substr(peg$currPos, 3) === peg$c62) {
            s2 = peg$c62;
            peg$currPos += 3;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e69);
            }
          }
        }
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e2);
            }
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseescape_sequence();
        }
        return s0;
      }
      function peg$parseescape_sequence() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c61;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e68);
          }
        }
        if (s1 !== peg$FAILED) {
          if (peg$r6.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e70);
            }
          }
          if (s2 === peg$FAILED) {
            s2 = [];
            if (peg$r3.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e39);
              }
            }
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$r3.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e39);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsefstring_literal() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 102) {
          s1 = peg$c26;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e30);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c60;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e66);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsestring_content();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsestring_content();
            }
            if (input.charCodeAt(peg$currPos) === 34) {
              s4 = peg$c60;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e66);
              }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f86();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsename_literal() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 110) {
          s1 = peg$c56;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e62);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c60;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e66);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsestring_content();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsestring_content();
            }
            if (input.charCodeAt(peg$currPos) === 34) {
              s4 = peg$c60;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e66);
              }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f87();
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsechar_literal() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c63;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e71);
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parsechar_content();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsechar_content();
          }
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c63;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e71);
            }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f88(s2);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsechar_content() {
        var s0, s1;
        s0 = [];
        if (peg$r7.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e72);
          }
        }
        if (s1 !== peg$FAILED) {
          while (s1 !== peg$FAILED) {
            s0.push(s1);
            if (peg$r7.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e72);
              }
            }
          }
        } else {
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseescape_sequence();
        }
        return s0;
      }
      function peg$parsedecimal_literal() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = [];
        if (peg$r3.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e39);
          }
        }
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            if (peg$r3.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e39);
              }
            }
          }
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s4 = peg$c50;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e55);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            if (peg$r3.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e39);
              }
            }
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              if (peg$r3.test(input.charAt(peg$currPos))) {
                s6 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e39);
                }
              }
            }
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 46) {
            s2 = peg$c50;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e55);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            if (peg$r3.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e39);
              }
            }
            if (s4 !== peg$FAILED) {
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                if (peg$r3.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e39);
                  }
                }
              }
            } else {
              s3 = peg$FAILED;
            }
            if (s3 !== peg$FAILED) {
              s2 = [s2, s3];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 101) {
            s3 = peg$c22;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e26);
            }
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s4 = peg$c4;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e8);
              }
            }
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            s5 = [];
            if (peg$r3.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e39);
              }
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$r3.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e39);
                  }
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s3 = [s3, s4, s5];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          if (input.charCodeAt(peg$currPos) === 102) {
            s3 = peg$c26;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e30);
            }
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f89(s1, s2, s3);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsesigned_decimal_literal() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 45) {
          s2 = peg$c4;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e8);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s2 = peg$parsedecimal_literal();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f90(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsehex_literal() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 48) {
          s1 = peg$c58;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e64);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 120) {
            s2 = peg$c59;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e65);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            if (peg$r8.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e73);
              }
            }
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$r8.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e73);
                }
              }
            }
            peg$savedPos = s0;
            s0 = peg$f91();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsebinary_literal() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 48) {
          s1 = peg$c58;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e64);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 98) {
            s2 = peg$c36;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e41);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            if (peg$r9.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e74);
              }
            }
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$r9.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e74);
                }
              }
            }
            peg$savedPos = s0;
            s0 = peg$f92();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseoctal_literal() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 48) {
          s1 = peg$c58;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e64);
          }
        }
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 111) {
            s2 = peg$c44;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e49);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            if (peg$r10.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e75);
              }
            }
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$r10.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e75);
                }
              }
            }
            peg$savedPos = s0;
            s0 = peg$f93();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsekeyword() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 105) {
          s2 = peg$c16;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c17) {
            s2 = peg$c17;
            peg$currPos += 2;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e21);
            }
          }
          if (s2 !== peg$FAILED) {
            s0 = s2;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 114) {
            s2 = peg$c20;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e24);
            }
          }
          peg$silentFails--;
          if (s2 !== peg$FAILED) {
            peg$currPos = s1;
            s1 = void 0;
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c21) {
              s2 = peg$c21;
              peg$currPos += 6;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e25);
              }
            }
            if (s2 !== peg$FAILED) {
              s0 = s2;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 98) {
              s2 = peg$c36;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e41);
              }
            }
            peg$silentFails--;
            if (s2 !== peg$FAILED) {
              peg$currPos = s1;
              s1 = void 0;
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c37) {
                s2 = peg$c37;
                peg$currPos += 5;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e42);
                }
              }
              if (s2 !== peg$FAILED) {
                s0 = s2;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 119) {
                s2 = peg$c39;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e44);
                }
              }
              peg$silentFails--;
              if (s2 !== peg$FAILED) {
                peg$currPos = s1;
                s1 = void 0;
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c40) {
                  s2 = peg$c40;
                  peg$currPos += 5;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e45);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s0 = s2;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 99) {
                  s2 = peg$c31;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e35);
                  }
                }
                peg$silentFails--;
                if (s2 !== peg$FAILED) {
                  peg$currPos = s1;
                  s1 = void 0;
                } else {
                  s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 5) === peg$c64) {
                    s2 = peg$c64;
                    peg$currPos += 5;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e76);
                    }
                  }
                  if (s2 === peg$FAILED) {
                    if (input.substr(peg$currPos, 8) === peg$c35) {
                      s2 = peg$c35;
                      peg$currPos += 8;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e40);
                      }
                    }
                    if (s2 === peg$FAILED) {
                      if (input.substr(peg$currPos, 4) === peg$c32) {
                        s2 = peg$c32;
                        peg$currPos += 4;
                      } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e36);
                        }
                      }
                      if (s2 === peg$FAILED) {
                        if (input.substr(peg$currPos, 5) === peg$c41) {
                          s2 = peg$c41;
                          peg$currPos += 5;
                        } else {
                          s2 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e46);
                          }
                        }
                      }
                    }
                  }
                  if (s2 !== peg$FAILED) {
                    s0 = s2;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$currPos;
                  peg$silentFails++;
                  if (input.charCodeAt(peg$currPos) === 115) {
                    s2 = peg$c24;
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e28);
                    }
                  }
                  peg$silentFails--;
                  if (s2 !== peg$FAILED) {
                    peg$currPos = s1;
                    s1 = void 0;
                  } else {
                    s1 = peg$FAILED;
                  }
                  if (s1 !== peg$FAILED) {
                    if (input.substr(peg$currPos, 6) === peg$c65) {
                      s2 = peg$c65;
                      peg$currPos += 6;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e77);
                      }
                    }
                    if (s2 === peg$FAILED) {
                      if (input.substr(peg$currPos, 6) === peg$c25) {
                        s2 = peg$c25;
                        peg$currPos += 6;
                      } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e29);
                        }
                      }
                    }
                    if (s2 !== peg$FAILED) {
                      s0 = s2;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$currPos;
                    peg$silentFails++;
                    if (input.charCodeAt(peg$currPos) === 118) {
                      s2 = peg$c66;
                      peg$currPos++;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e78);
                      }
                    }
                    peg$silentFails--;
                    if (s2 !== peg$FAILED) {
                      peg$currPos = s1;
                      s1 = void 0;
                    } else {
                      s1 = peg$FAILED;
                    }
                    if (s1 !== peg$FAILED) {
                      if (input.substr(peg$currPos, 4) === peg$c67) {
                        s2 = peg$c67;
                        peg$currPos += 4;
                      } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e79);
                        }
                      }
                      if (s2 !== peg$FAILED) {
                        s0 = s2;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = peg$currPos;
                      peg$silentFails++;
                      if (input.charCodeAt(peg$currPos) === 111) {
                        s2 = peg$c44;
                        peg$currPos++;
                      } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e49);
                        }
                      }
                      peg$silentFails--;
                      if (s2 !== peg$FAILED) {
                        peg$currPos = s1;
                        s1 = void 0;
                      } else {
                        s1 = peg$FAILED;
                      }
                      if (s1 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 8) === peg$c68) {
                          s2 = peg$c68;
                          peg$currPos += 8;
                        } else {
                          s2 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e80);
                          }
                        }
                        if (s2 !== peg$FAILED) {
                          s0 = s2;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$currPos;
                        peg$silentFails++;
                        if (input.charCodeAt(peg$currPos) === 100) {
                          s2 = peg$c33;
                          peg$currPos++;
                        } else {
                          s2 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e37);
                          }
                        }
                        peg$silentFails--;
                        if (s2 !== peg$FAILED) {
                          peg$currPos = s1;
                          s1 = void 0;
                        } else {
                          s1 = peg$FAILED;
                        }
                        if (s1 !== peg$FAILED) {
                          if (input.substr(peg$currPos, 8) === peg$c69) {
                            s2 = peg$c69;
                            peg$currPos += 8;
                          } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e81);
                            }
                          }
                          if (s2 === peg$FAILED) {
                            if (input.substr(peg$currPos, 7) === peg$c34) {
                              s2 = peg$c34;
                              peg$currPos += 7;
                            } else {
                              s2 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e38);
                              }
                            }
                          }
                          if (s2 !== peg$FAILED) {
                            s0 = s2;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          s1 = peg$currPos;
                          peg$silentFails++;
                          if (input.charCodeAt(peg$currPos) === 112) {
                            s2 = peg$c70;
                            peg$currPos++;
                          } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e82);
                            }
                          }
                          peg$silentFails--;
                          if (s2 !== peg$FAILED) {
                            peg$currPos = s1;
                            s1 = void 0;
                          } else {
                            s1 = peg$FAILED;
                          }
                          if (s1 !== peg$FAILED) {
                            if (input.substr(peg$currPos, 8) === peg$c71) {
                              s2 = peg$c71;
                              peg$currPos += 8;
                            } else {
                              s2 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e83);
                              }
                            }
                            if (s2 !== peg$FAILED) {
                              s0 = s2;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$currPos;
                            peg$silentFails++;
                            if (input.charCodeAt(peg$currPos) === 101) {
                              s2 = peg$c22;
                              peg$currPos++;
                            } else {
                              s2 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e26);
                              }
                            }
                            peg$silentFails--;
                            if (s2 !== peg$FAILED) {
                              peg$currPos = s1;
                              s1 = void 0;
                            } else {
                              s1 = peg$FAILED;
                            }
                            if (s1 !== peg$FAILED) {
                              if (input.substr(peg$currPos, 5) === peg$c72) {
                                s2 = peg$c72;
                                peg$currPos += 5;
                              } else {
                                s2 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e84);
                                }
                              }
                              if (s2 === peg$FAILED) {
                                if (input.substr(peg$currPos, 4) === peg$c73) {
                                  s2 = peg$c73;
                                  peg$currPos += 4;
                                } else {
                                  s2 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e85);
                                  }
                                }
                                if (s2 === peg$FAILED) {
                                  if (input.substr(peg$currPos, 4) === peg$c23) {
                                    s2 = peg$c23;
                                    peg$currPos += 4;
                                  } else {
                                    s2 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e27);
                                    }
                                  }
                                }
                              }
                              if (s2 !== peg$FAILED) {
                                s0 = s2;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                            if (s0 === peg$FAILED) {
                              s0 = peg$currPos;
                              s1 = peg$currPos;
                              peg$silentFails++;
                              if (input.charCodeAt(peg$currPos) === 109) {
                                s2 = peg$c74;
                                peg$currPos++;
                              } else {
                                s2 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$e86);
                                }
                              }
                              peg$silentFails--;
                              if (s2 !== peg$FAILED) {
                                peg$currPos = s1;
                                s1 = void 0;
                              } else {
                                s1 = peg$FAILED;
                              }
                              if (s1 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 5) === peg$c14) {
                                  s2 = peg$c14;
                                  peg$currPos += 5;
                                } else {
                                  s2 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e18);
                                  }
                                }
                                if (s2 !== peg$FAILED) {
                                  s0 = s2;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                              if (s0 === peg$FAILED) {
                                s0 = peg$currPos;
                                s1 = peg$currPos;
                                peg$silentFails++;
                                if (input.charCodeAt(peg$currPos) === 108) {
                                  s2 = peg$c75;
                                  peg$currPos++;
                                } else {
                                  s2 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$e87);
                                  }
                                }
                                peg$silentFails--;
                                if (s2 !== peg$FAILED) {
                                  peg$currPos = s1;
                                  s1 = void 0;
                                } else {
                                  s1 = peg$FAILED;
                                }
                                if (s1 !== peg$FAILED) {
                                  if (input.substr(peg$currPos, 5) === peg$c15) {
                                    s2 = peg$c15;
                                    peg$currPos += 5;
                                  } else {
                                    s2 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e19);
                                    }
                                  }
                                  if (s2 !== peg$FAILED) {
                                    s0 = s2;
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                                if (s0 === peg$FAILED) {
                                  s0 = peg$currPos;
                                  s1 = peg$currPos;
                                  peg$silentFails++;
                                  if (input.charCodeAt(peg$currPos) === 67) {
                                    s2 = peg$c52;
                                    peg$currPos++;
                                  } else {
                                    s2 = peg$FAILED;
                                    if (peg$silentFails === 0) {
                                      peg$fail(peg$e58);
                                    }
                                  }
                                  peg$silentFails--;
                                  if (s2 !== peg$FAILED) {
                                    peg$currPos = s1;
                                    s1 = void 0;
                                  } else {
                                    s1 = peg$FAILED;
                                  }
                                  if (s1 !== peg$FAILED) {
                                    if (input.substr(peg$currPos, 4) === peg$c53) {
                                      s2 = peg$c53;
                                      peg$currPos += 4;
                                    } else {
                                      s2 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$e59);
                                      }
                                    }
                                    if (s2 !== peg$FAILED) {
                                      s0 = s2;
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                  }
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    s1 = peg$currPos;
                                    peg$silentFails++;
                                    if (input.charCodeAt(peg$currPos) === 116) {
                                      s2 = peg$c46;
                                      peg$currPos++;
                                    } else {
                                      s2 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$e51);
                                      }
                                    }
                                    peg$silentFails--;
                                    if (s2 !== peg$FAILED) {
                                      peg$currPos = s1;
                                      s1 = void 0;
                                    } else {
                                      s1 = peg$FAILED;
                                    }
                                    if (s1 !== peg$FAILED) {
                                      if (input.substr(peg$currPos, 4) === peg$c54) {
                                        s2 = peg$c54;
                                        peg$currPos += 4;
                                      } else {
                                        s2 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$e60);
                                        }
                                      }
                                      if (s2 === peg$FAILED) {
                                        if (input.substr(peg$currPos, 4) === peg$c47) {
                                          s2 = peg$c47;
                                          peg$currPos += 4;
                                        } else {
                                          s2 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$e52);
                                          }
                                        }
                                      }
                                      if (s2 !== peg$FAILED) {
                                        s0 = s2;
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$FAILED;
                                    }
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$currPos;
                                      s1 = peg$currPos;
                                      peg$silentFails++;
                                      if (input.charCodeAt(peg$currPos) === 102) {
                                        s2 = peg$c26;
                                        peg$currPos++;
                                      } else {
                                        s2 = peg$FAILED;
                                        if (peg$silentFails === 0) {
                                          peg$fail(peg$e30);
                                        }
                                      }
                                      peg$silentFails--;
                                      if (s2 !== peg$FAILED) {
                                        peg$currPos = s1;
                                        s1 = void 0;
                                      } else {
                                        s1 = peg$FAILED;
                                      }
                                      if (s1 !== peg$FAILED) {
                                        if (input.substr(peg$currPos, 5) === peg$c55) {
                                          s2 = peg$c55;
                                          peg$currPos += 5;
                                        } else {
                                          s2 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$e61);
                                          }
                                        }
                                        if (s2 === peg$FAILED) {
                                          if (input.substr(peg$currPos, 5) === peg$c76) {
                                            s2 = peg$c76;
                                            peg$currPos += 5;
                                          } else {
                                            s2 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                              peg$fail(peg$e88);
                                            }
                                          }
                                          if (s2 === peg$FAILED) {
                                            if (input.substr(peg$currPos, 3) === peg$c27) {
                                              s2 = peg$c27;
                                              peg$currPos += 3;
                                            } else {
                                              s2 = peg$FAILED;
                                              if (peg$silentFails === 0) {
                                                peg$fail(peg$e31);
                                              }
                                            }
                                            if (s2 === peg$FAILED) {
                                              if (input.substr(peg$currPos, 11) === peg$c38) {
                                                s2 = peg$c38;
                                                peg$currPos += 11;
                                              } else {
                                                s2 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                  peg$fail(peg$e43);
                                                }
                                              }
                                            }
                                          }
                                        }
                                        if (s2 !== peg$FAILED) {
                                          s0 = s2;
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                      }
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        s1 = peg$currPos;
                                        peg$silentFails++;
                                        if (input.charCodeAt(peg$currPos) === 97) {
                                          s2 = peg$c77;
                                          peg$currPos++;
                                        } else {
                                          s2 = peg$FAILED;
                                          if (peg$silentFails === 0) {
                                            peg$fail(peg$e89);
                                          }
                                        }
                                        peg$silentFails--;
                                        if (s2 !== peg$FAILED) {
                                          peg$currPos = s1;
                                          s1 = void 0;
                                        } else {
                                          s1 = peg$FAILED;
                                        }
                                        if (s1 !== peg$FAILED) {
                                          if (input.substr(peg$currPos, 6) === peg$c78) {
                                            s2 = peg$c78;
                                            peg$currPos += 6;
                                          } else {
                                            s2 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                              peg$fail(peg$e90);
                                            }
                                          }
                                          if (s2 !== peg$FAILED) {
                                            s0 = s2;
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$FAILED;
                                        }
                                        if (s0 === peg$FAILED) {
                                          s0 = peg$currPos;
                                          s1 = peg$currPos;
                                          peg$silentFails++;
                                          if (input.charCodeAt(peg$currPos) === 110) {
                                            s2 = peg$c56;
                                            peg$currPos++;
                                          } else {
                                            s2 = peg$FAILED;
                                            if (peg$silentFails === 0) {
                                              peg$fail(peg$e62);
                                            }
                                          }
                                          peg$silentFails--;
                                          if (s2 !== peg$FAILED) {
                                            peg$currPos = s1;
                                            s1 = void 0;
                                          } else {
                                            s1 = peg$FAILED;
                                          }
                                          if (s1 !== peg$FAILED) {
                                            if (input.substr(peg$currPos, 7) === peg$c57) {
                                              s2 = peg$c57;
                                              peg$currPos += 7;
                                            } else {
                                              s2 = peg$FAILED;
                                              if (peg$silentFails === 0) {
                                                peg$fail(peg$e63);
                                              }
                                            }
                                            if (s2 === peg$FAILED) {
                                              if (input.substr(peg$currPos, 9) === peg$c79) {
                                                s2 = peg$c79;
                                                peg$currPos += 9;
                                              } else {
                                                s2 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                  peg$fail(peg$e91);
                                                }
                                              }
                                            }
                                            if (s2 !== peg$FAILED) {
                                              s0 = s2;
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                          }
                                          if (s0 === peg$FAILED) {
                                            s0 = peg$currPos;
                                            s1 = peg$currPos;
                                            peg$silentFails++;
                                            if (input.charCodeAt(peg$currPos) === 85) {
                                              s2 = peg$c80;
                                              peg$currPos++;
                                            } else {
                                              s2 = peg$FAILED;
                                              if (peg$silentFails === 0) {
                                                peg$fail(peg$e92);
                                              }
                                            }
                                            peg$silentFails--;
                                            if (s2 !== peg$FAILED) {
                                              peg$currPos = s1;
                                              s1 = void 0;
                                            } else {
                                              s1 = peg$FAILED;
                                            }
                                            if (s1 !== peg$FAILED) {
                                              if (input.substr(peg$currPos, 9) === peg$c81) {
                                                s2 = peg$c81;
                                                peg$currPos += 9;
                                              } else {
                                                s2 = peg$FAILED;
                                                if (peg$silentFails === 0) {
                                                  peg$fail(peg$e93);
                                                }
                                              }
                                              if (s2 === peg$FAILED) {
                                                if (input.substr(peg$currPos, 9) === peg$c82) {
                                                  s2 = peg$c82;
                                                  peg$currPos += 9;
                                                } else {
                                                  s2 = peg$FAILED;
                                                  if (peg$silentFails === 0) {
                                                    peg$fail(peg$e94);
                                                  }
                                                }
                                                if (s2 === peg$FAILED) {
                                                  if (input.substr(peg$currPos, 6) === peg$c83) {
                                                    s2 = peg$c83;
                                                    peg$currPos += 6;
                                                  } else {
                                                    s2 = peg$FAILED;
                                                    if (peg$silentFails === 0) {
                                                      peg$fail(peg$e95);
                                                    }
                                                  }
                                                  if (s2 === peg$FAILED) {
                                                    if (input.substr(peg$currPos, 5) === peg$c84) {
                                                      s2 = peg$c84;
                                                      peg$currPos += 5;
                                                    } else {
                                                      s2 = peg$FAILED;
                                                      if (peg$silentFails === 0) {
                                                        peg$fail(peg$e96);
                                                      }
                                                    }
                                                    if (s2 === peg$FAILED) {
                                                      if (input.substr(peg$currPos, 5) === peg$c85) {
                                                        s2 = peg$c85;
                                                        peg$currPos += 5;
                                                      } else {
                                                        s2 = peg$FAILED;
                                                        if (peg$silentFails === 0) {
                                                          peg$fail(peg$e97);
                                                        }
                                                      }
                                                      if (s2 === peg$FAILED) {
                                                        if (input.substr(peg$currPos, 7) === peg$c86) {
                                                          s2 = peg$c86;
                                                          peg$currPos += 7;
                                                        } else {
                                                          s2 = peg$FAILED;
                                                          if (peg$silentFails === 0) {
                                                            peg$fail(peg$e98);
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                              if (s2 !== peg$FAILED) {
                                                s0 = s2;
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$FAILED;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return s0;
      }
      function peg$parsestandard_template_basetype() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 84) {
          s2 = peg$c87;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e99);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 11) === peg$c88) {
            s2 = peg$c88;
            peg$currPos += 11;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e100);
            }
          }
          if (s2 === peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c89) {
              s2 = peg$c89;
              peg$currPos += 6;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e101);
              }
            }
            if (s2 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c90) {
                s2 = peg$c90;
                peg$currPos += 4;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e102);
                }
              }
              if (s2 === peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c91) {
                  s2 = peg$c91;
                  peg$currPos += 4;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e103);
                  }
                }
                if (s2 === peg$FAILED) {
                  if (input.substr(peg$currPos, 9) === peg$c92) {
                    s2 = peg$c92;
                    peg$currPos += 9;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e104);
                    }
                  }
                  if (s2 === peg$FAILED) {
                    if (input.substr(peg$currPos, 14) === peg$c93) {
                      s2 = peg$c93;
                      peg$currPos += 14;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e105);
                      }
                    }
                    if (s2 === peg$FAILED) {
                      if (input.substr(peg$currPos, 14) === peg$c94) {
                        s2 = peg$c94;
                        peg$currPos += 14;
                      } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e106);
                        }
                      }
                      if (s2 === peg$FAILED) {
                        if (input.substr(peg$currPos, 13) === peg$c95) {
                          s2 = peg$c95;
                          peg$currPos += 13;
                        } else {
                          s2 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$e107);
                          }
                        }
                        if (s2 === peg$FAILED) {
                          if (input.substr(peg$currPos, 11) === peg$c96) {
                            s2 = peg$c96;
                            peg$currPos += 11;
                          } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$e108);
                            }
                          }
                          if (s2 === peg$FAILED) {
                            if (input.substr(peg$currPos, 10) === peg$c97) {
                              s2 = peg$c97;
                              peg$currPos += 10;
                            } else {
                              s2 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$e109);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (s2 !== peg$FAILED) {
            s0 = s2;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseprimitive_types() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 102) {
          s2 = peg$c26;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e30);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 7) === peg$c98) {
            s2 = peg$c98;
            peg$currPos += 7;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e110);
            }
          }
          if (s2 === peg$FAILED) {
            if (input.substr(peg$currPos, 7) === peg$c99) {
              s2 = peg$c99;
              peg$currPos += 7;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e111);
              }
            }
            if (s2 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c100) {
                s2 = peg$c100;
                peg$currPos += 5;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e112);
                }
              }
            }
          }
          if (s2 !== peg$FAILED) {
            s0 = s2;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 105) {
            s2 = peg$c16;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e20);
            }
          }
          peg$silentFails--;
          if (s2 !== peg$FAILED) {
            peg$currPos = s1;
            s1 = void 0;
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c101) {
              s2 = peg$c101;
              peg$currPos += 5;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e113);
              }
            }
            if (s2 === peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c102) {
                s2 = peg$c102;
                peg$currPos += 5;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e114);
                }
              }
              if (s2 === peg$FAILED) {
                if (input.substr(peg$currPos, 5) === peg$c103) {
                  s2 = peg$c103;
                  peg$currPos += 5;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e115);
                  }
                }
                if (s2 === peg$FAILED) {
                  if (input.substr(peg$currPos, 4) === peg$c104) {
                    s2 = peg$c104;
                    peg$currPos += 4;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e116);
                    }
                  }
                  if (s2 === peg$FAILED) {
                    if (input.substr(peg$currPos, 3) === peg$c105) {
                      s2 = peg$c105;
                      peg$currPos += 3;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e117);
                      }
                    }
                  }
                }
              }
            }
            if (s2 !== peg$FAILED) {
              s0 = s2;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 117) {
              s2 = peg$c106;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e118);
              }
            }
            peg$silentFails--;
            if (s2 !== peg$FAILED) {
              peg$currPos = s1;
              s1 = void 0;
            } else {
              s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
              if (input.substr(peg$currPos, 6) === peg$c107) {
                s2 = peg$c107;
                peg$currPos += 6;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e119);
                }
              }
              if (s2 === peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c108) {
                  s2 = peg$c108;
                  peg$currPos += 6;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e120);
                  }
                }
                if (s2 === peg$FAILED) {
                  if (input.substr(peg$currPos, 6) === peg$c109) {
                    s2 = peg$c109;
                    peg$currPos += 6;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e121);
                    }
                  }
                  if (s2 === peg$FAILED) {
                    if (input.substr(peg$currPos, 5) === peg$c110) {
                      s2 = peg$c110;
                      peg$currPos += 5;
                    } else {
                      s2 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e122);
                      }
                    }
                    if (s2 === peg$FAILED) {
                      if (input.substr(peg$currPos, 4) === peg$c111) {
                        s2 = peg$c111;
                        peg$currPos += 4;
                      } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e123);
                        }
                      }
                    }
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                s0 = s2;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 98) {
                s2 = peg$c36;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e41);
                }
              }
              peg$silentFails--;
              if (s2 !== peg$FAILED) {
                peg$currPos = s1;
                s1 = void 0;
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c112) {
                  s2 = peg$c112;
                  peg$currPos += 4;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e124);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s0 = s2;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }
        return s0;
      }
      function peg$parseidentifier() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = peg$currPos;
        s3 = peg$parsekeyword();
        if (s3 === peg$FAILED) {
          s3 = peg$parsestandard_template_basetype();
          if (s3 === peg$FAILED) {
            s3 = peg$parseprimitive_types();
          }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseidentifier_char();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = void 0;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        peg$silentFails--;
        if (s2 === peg$FAILED) {
          s1 = void 0;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseidentifier_start();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseidentifier_rest();
            s4 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 34) {
              s5 = peg$c60;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e66);
              }
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f94(s2, s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseidentifier_name() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$currPos;
        s4 = peg$parsekeyword();
        if (s4 === peg$FAILED) {
          s4 = peg$parsestandard_template_basetype();
          if (s4 === peg$FAILED) {
            s4 = peg$parseprimitive_types();
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parseidentifier_char();
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseidentifier_start();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseidentifier_rest();
            s5 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 34) {
              s6 = peg$c60;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e66);
              }
            }
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s2 = [s2, s3, s4, s5];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parsetypename_name() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$currPos;
        s4 = peg$parsekeyword();
        if (s4 !== peg$FAILED) {
          s5 = peg$currPos;
          peg$silentFails++;
          s6 = peg$parseidentifier_char();
          peg$silentFails--;
          if (s6 === peg$FAILED) {
            s5 = void 0;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = void 0;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseidentifier_start();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseidentifier_rest();
            s5 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 34) {
              s6 = peg$c60;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e66);
              }
            }
            peg$silentFails--;
            if (s6 === peg$FAILED) {
              s5 = void 0;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s2 = [s2, s3, s4, s5];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s0 = input.substring(s0, peg$currPos);
        } else {
          s0 = s1;
        }
        return s0;
      }
      function peg$parseidentifier_start() {
        var s0;
        if (peg$r11.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e125);
          }
        }
        return s0;
      }
      function peg$parseidentifier_rest() {
        var s0, s1;
        s0 = [];
        if (peg$r12.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e126);
          }
        }
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$r12.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e126);
            }
          }
        }
        return s0;
      }
      function peg$parseidentifier_char() {
        var s0;
        if (peg$r12.test(input.charAt(peg$currPos))) {
          s0 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e126);
          }
        }
        return s0;
      }
      function peg$parseimport_statement() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 105) {
          s2 = peg$c16;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c113) {
            s2 = peg$c113;
            peg$currPos += 6;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e127);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            s4 = peg$parseidentifier();
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 46) {
                s7 = peg$c50;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e55);
                }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parseidentifier();
                if (s8 !== peg$FAILED) {
                  s6 = s8;
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 46) {
                  s7 = peg$c50;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e55);
                  }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseidentifier();
                  if (s8 !== peg$FAILED) {
                    s6 = s8;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              }
              peg$savedPos = s0;
              s0 = peg$f95(s4, s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseimport_function_statement() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 105) {
          s2 = peg$c16;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e20);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c113) {
            s2 = peg$c113;
            peg$currPos += 6;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e127);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            s4 = peg$parsefunction_signature();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (input.substr(peg$currPos, 4) === peg$c114) {
                s6 = peg$c114;
                peg$currPos += 4;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e128);
                }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                s8 = peg$currPos;
                s9 = peg$parsestring_literal();
                if (s9 === peg$FAILED) {
                  s9 = peg$parsechar_literal();
                }
                if (s9 !== peg$FAILED) {
                  peg$savedPos = s8;
                  s9 = peg$f96(s4);
                }
                s8 = s9;
                if (s8 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f97(s4, s8);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsecomment_documentation() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = [];
        if (peg$r1.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e5);
          }
        }
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$r1.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e5);
            }
          }
        }
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (peg$r2.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e6);
          }
        }
        peg$silentFails--;
        if (s5 !== peg$FAILED) {
          peg$currPos = s4;
          s4 = void 0;
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$currPos;
          s6 = peg$parsecomment();
          if (s6 !== peg$FAILED) {
            s5 = input.substring(s5, peg$currPos);
          } else {
            s5 = s6;
          }
          if (s5 !== peg$FAILED) {
            s6 = [];
            if (peg$r1.test(input.charAt(peg$currPos))) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e5);
              }
            }
            while (s7 !== peg$FAILED) {
              s6.push(s7);
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
            }
            s3 = s5;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (peg$r2.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e6);
            }
          }
          peg$silentFails--;
          if (s5 !== peg$FAILED) {
            peg$currPos = s4;
            s4 = void 0;
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            s6 = peg$parsecomment();
            if (s6 !== peg$FAILED) {
              s5 = input.substring(s5, peg$currPos);
            } else {
              s5 = s6;
            }
            if (s5 !== peg$FAILED) {
              s6 = [];
              if (peg$r1.test(input.charAt(peg$currPos))) {
                s7 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e5);
                }
              }
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                if (peg$r1.test(input.charAt(peg$currPos))) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e5);
                  }
                }
              }
              s3 = s5;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        peg$savedPos = s0;
        s0 = peg$f98(s2);
        return s0;
      }
      function peg$parsefunction_signature() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$parsefunction_return();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseidentifier();
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c18;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              peg$savedPos = peg$currPos;
              s6 = peg$f99(s1, s2);
              if (s6) {
                s6 = void 0;
              } else {
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parseparameter_list_incomplete();
                s5 = s7;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 === peg$FAILED) {
                s5 = peg$currPos;
                peg$savedPos = peg$currPos;
                s6 = peg$f100(s1, s2);
                if (s6) {
                  s6 = void 0;
                } else {
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseparameter_list();
                  s5 = s7;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                if (input.charCodeAt(peg$currPos) === 41) {
                  s7 = peg$c19;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e23);
                  }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parsefunc_qualifiers();
                  peg$savedPos = s0;
                  s0 = peg$f101(s1, s2, s5, s8);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsevoid_type();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse__();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseidentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$currPos;
                s5 = peg$parse_();
                if (input.charCodeAt(peg$currPos) === 40) {
                  s6 = peg$c18;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e22);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseparameter_list_incomplete();
                  s8 = peg$parse_();
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s9 = peg$c19;
                    peg$currPos++;
                  } else {
                    s9 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e23);
                    }
                  }
                  if (s9 !== peg$FAILED) {
                    s4 = s7;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 === peg$FAILED) {
                  s4 = null;
                }
                peg$savedPos = s0;
                s0 = peg$f102(s3, s4);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parsefunction_signature_incomplete() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$parsefunction_return();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseidentifier();
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c18;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parseparameter_list_incomplete();
              s6 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 41) {
                s7 = peg$c19;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parsefunc_qualifiers();
                peg$savedPos = s0;
                s0 = peg$f103(s1, s2, s5, s8);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsevoid_type();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse__();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseidentifier();
              if (s3 !== peg$FAILED) {
                s4 = peg$currPos;
                s5 = peg$parse_();
                if (input.charCodeAt(peg$currPos) === 40) {
                  s6 = peg$c18;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e22);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseparameter_list_incomplete();
                  s8 = peg$parse_();
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s9 = peg$c19;
                    peg$currPos++;
                  } else {
                    s9 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e23);
                    }
                  }
                  if (s9 !== peg$FAILED) {
                    s4 = s7;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 === peg$FAILED) {
                  s4 = null;
                }
                peg$savedPos = s0;
                s0 = peg$f104(s3, s4);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parsefunction_return() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parsevoid_type();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse__();
          if (s2 !== peg$FAILED) {
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsetypename();
          if (s1 !== peg$FAILED) {
            s2 = peg$parse_();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parsevoid_type() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 118) {
          s2 = peg$c66;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e78);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c67) {
            s2 = peg$c67;
            peg$currPos += 4;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e79);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f105();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsefunc_qualifiers() {
        var s0, s1, s2, s3, s4, s5;
        s0 = [];
        s1 = peg$currPos;
        s2 = peg$parse_();
        if (input.substr(peg$currPos, 5) === peg$c41) {
          s3 = peg$c41;
          peg$currPos += 5;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e46);
          }
        }
        if (s3 === peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c76) {
            s3 = peg$c76;
            peg$currPos += 5;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e88);
            }
          }
          if (s3 === peg$FAILED) {
            if (input.substr(peg$currPos, 8) === peg$c68) {
              s3 = peg$c68;
              peg$currPos += 8;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e80);
              }
            }
            if (s3 === peg$FAILED) {
              if (input.substr(peg$currPos, 8) === peg$c71) {
                s3 = peg$c71;
                peg$currPos += 8;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e83);
                }
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                if (input.substr(peg$currPos, 4) === peg$c114) {
                  s5 = peg$c114;
                  peg$currPos += 4;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e128);
                  }
                }
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = void 0;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseidentifier_name();
                  if (s5 !== peg$FAILED) {
                    s3 = s5;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              }
            }
          }
        }
        if (s3 !== peg$FAILED) {
          s1 = s3;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$currPos;
          s2 = peg$parse_();
          if (input.substr(peg$currPos, 5) === peg$c41) {
            s3 = peg$c41;
            peg$currPos += 5;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e46);
            }
          }
          if (s3 === peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c76) {
              s3 = peg$c76;
              peg$currPos += 5;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e88);
              }
            }
            if (s3 === peg$FAILED) {
              if (input.substr(peg$currPos, 8) === peg$c68) {
                s3 = peg$c68;
                peg$currPos += 8;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e80);
                }
              }
              if (s3 === peg$FAILED) {
                if (input.substr(peg$currPos, 8) === peg$c71) {
                  s3 = peg$c71;
                  peg$currPos += 8;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e83);
                  }
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  s4 = peg$currPos;
                  peg$silentFails++;
                  if (input.substr(peg$currPos, 4) === peg$c114) {
                    s5 = peg$c114;
                    peg$currPos += 4;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e128);
                    }
                  }
                  peg$silentFails--;
                  if (s5 === peg$FAILED) {
                    s4 = void 0;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseidentifier_name();
                    if (s5 !== peg$FAILED) {
                      s3 = s5;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
              }
            }
          }
          if (s3 !== peg$FAILED) {
            s1 = s3;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseparameter_list() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parse_();
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 44) {
          s4 = peg$c30;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e34);
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_();
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        s4 = peg$parseparameter();
        if (s4 !== peg$FAILED) {
          s5 = [];
          s6 = peg$currPos;
          s7 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 44) {
            s8 = peg$c30;
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s8 !== peg$FAILED) {
            s9 = peg$parse_();
            s10 = peg$parseparameter_incomplete();
            if (s10 !== peg$FAILED) {
              s6 = s10;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$currPos;
            s7 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 44) {
              s8 = peg$c30;
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s8 !== peg$FAILED) {
              s9 = peg$parse_();
              s10 = peg$parseparameter_incomplete();
              if (s10 !== peg$FAILED) {
                s6 = s10;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
          }
          s6 = peg$currPos;
          s7 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 44) {
            s8 = peg$c30;
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s8 !== peg$FAILED) {
            s7 = [s7, s8];
            s6 = s7;
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          peg$savedPos = s1;
          s1 = peg$f106(s4, s5);
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        peg$savedPos = s0;
        s1 = peg$f107(s1);
        s0 = s1;
        return s0;
      }
      function peg$parseparameter_list_incomplete() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parse_();
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 44) {
          s4 = peg$c30;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e34);
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_();
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        s4 = peg$parseparameter_incomplete();
        if (s4 !== peg$FAILED) {
          s5 = [];
          s6 = peg$currPos;
          s7 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 44) {
            s8 = peg$c30;
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s8 !== peg$FAILED) {
            s9 = peg$parse_();
            s10 = peg$parseparameter_incomplete();
            if (s10 !== peg$FAILED) {
              s6 = s10;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$currPos;
            s7 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 44) {
              s8 = peg$c30;
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s8 !== peg$FAILED) {
              s9 = peg$parse_();
              s10 = peg$parseparameter_incomplete();
              if (s10 !== peg$FAILED) {
                s6 = s10;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
          }
          s6 = peg$currPos;
          s7 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 44) {
            s8 = peg$c30;
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s8 !== peg$FAILED) {
            s7 = [s7, s8];
            s6 = s7;
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          peg$savedPos = s1;
          s1 = peg$f108(s4, s5);
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        peg$savedPos = s0;
        s1 = peg$f109(s1);
        s0 = s1;
        return s0;
      }
      function peg$parseparameter() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parsetypename();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          s3 = peg$parseidentifier();
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            s5 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 61) {
              s6 = peg$c7;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e11);
              }
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parse_();
              s8 = peg$parseoptional_expression();
              s4 = s8;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            peg$savedPos = s0;
            s0 = peg$f110(s1, s3, s4);
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c41) {
            s1 = peg$c41;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e46);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f111();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsestandard_template_basetype();
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              peg$silentFails++;
              s3 = peg$parseidentifier_char();
              peg$silentFails--;
              if (s3 === peg$FAILED) {
                s2 = void 0;
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f112();
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseprimitive_types();
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                peg$silentFails++;
                s3 = peg$parseidentifier_char();
                peg$silentFails--;
                if (s3 === peg$FAILED) {
                  s2 = void 0;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f113();
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
        }
        return s0;
      }
      function peg$parseparameter_incomplete() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
        s0 = peg$currPos;
        s1 = peg$parsetypename();
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parse_();
          s4 = peg$parseidentifier();
          if (s4 !== peg$FAILED) {
            s5 = peg$currPos;
            s6 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 61) {
              s7 = peg$c7;
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e11);
              }
            }
            if (s7 !== peg$FAILED) {
              s8 = peg$parse_();
              s9 = peg$parseoptional_expression();
              s5 = s9;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            peg$savedPos = s2;
            s2 = peg$f114(s1, s4, s5);
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f115(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 5) === peg$c41) {
            s1 = peg$c41;
            peg$currPos += 5;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e46);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f116();
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parseufunction_macro() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 85) {
          s2 = peg$c80;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e92);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 9) === peg$c81) {
            s2 = peg$c81;
            peg$currPos += 9;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e93);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c18;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsemacro_list();
              s6 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 41) {
                s7 = peg$c19;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s7 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f117(s5);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseuproperty_macro() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 85) {
          s2 = peg$c80;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e92);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 9) === peg$c82) {
            s2 = peg$c82;
            peg$currPos += 9;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e94);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c18;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsemacro_list();
              s6 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 41) {
                s7 = peg$c19;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s7 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f118(s5);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseustruct_macro() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 85) {
          s2 = peg$c80;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e92);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 7) === peg$c86) {
            s2 = peg$c86;
            peg$currPos += 7;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e98);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c18;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsemacro_list();
              s6 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 41) {
                s7 = peg$c19;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s7 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f119(s5);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseuclass_macro() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 85) {
          s2 = peg$c80;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e92);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c83) {
            s2 = peg$c83;
            peg$currPos += 6;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e95);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c18;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsemacro_list();
              s6 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 41) {
                s7 = peg$c19;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s7 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f120(s5);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseuenum_macro() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 85) {
          s2 = peg$c80;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e92);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c84) {
            s2 = peg$c84;
            peg$currPos += 5;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e96);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c18;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsemacro_list();
              s6 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 41) {
                s7 = peg$c19;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s7 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f121(s5);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseumeta_macro() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 85) {
          s2 = peg$c80;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e92);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c85) {
            s2 = peg$c85;
            peg$currPos += 5;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e97);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 40) {
              s4 = peg$c18;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e22);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsemacro_list();
              s6 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 41) {
                s7 = peg$c19;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e23);
                }
              }
              if (s7 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f122(s5);
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemacro_list() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parse_();
        s3 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 44) {
          s4 = peg$c30;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e34);
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_();
          s4 = [s4, s5];
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        s4 = peg$parsemacro_argument();
        if (s4 !== peg$FAILED) {
          s5 = [];
          s6 = peg$currPos;
          s7 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 44) {
            s8 = peg$c30;
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s8 !== peg$FAILED) {
            s9 = peg$parse_();
            s10 = peg$parsemacro_argument();
            if (s10 !== peg$FAILED) {
              s6 = s10;
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            s6 = peg$currPos;
            s7 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 44) {
              s8 = peg$c30;
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s8 !== peg$FAILED) {
              s9 = peg$parse_();
              s10 = peg$parsemacro_argument();
              if (s10 !== peg$FAILED) {
                s6 = s10;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            } else {
              peg$currPos = s6;
              s6 = peg$FAILED;
            }
          }
          s6 = peg$currPos;
          s7 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 44) {
            s8 = peg$c30;
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s8 !== peg$FAILED) {
            s7 = [s7, s8];
            s6 = s7;
          } else {
            peg$currPos = s6;
            s6 = peg$FAILED;
          }
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          peg$savedPos = s1;
          s1 = peg$f123(s4, s5);
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        peg$savedPos = s0;
        s1 = peg$f124(s1);
        s0 = s1;
        return s0;
      }
      function peg$parsemacro_argument() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
        s0 = peg$currPos;
        s1 = peg$parsemacro_identifier();
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 61) {
            s4 = peg$c7;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            s6 = peg$currPos;
            s7 = peg$parsemacro_value();
            if (s7 !== peg$FAILED) {
              peg$savedPos = s6;
              s7 = peg$f125(s1, s7);
            }
            s6 = s7;
            if (s6 === peg$FAILED) {
              s6 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 40) {
                s7 = peg$c18;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e22);
                }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parsemacro_list();
                if (s8 !== peg$FAILED) {
                  s9 = peg$parse_();
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s10 = peg$c19;
                    peg$currPos++;
                  } else {
                    s10 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e23);
                    }
                  }
                  if (s10 !== peg$FAILED) {
                    peg$savedPos = s6;
                    s6 = peg$f126(s1, s8);
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
            }
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            s2 = s6;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f127(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsemacro_identifier() {
        var s0, s1;
        s0 = peg$parseidentifier();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsestring_literal();
          if (s1 === peg$FAILED) {
            s1 = peg$parsechar_literal();
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f128(s1);
          }
          s0 = s1;
        }
        return s0;
      }
      function peg$parsemacro_value() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 33) {
          s2 = peg$c9;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e13);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s2 = peg$currPos;
        s3 = [];
        s4 = peg$parseidentifier_name();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$currPos;
          s5 = peg$currPos;
          s6 = peg$parse_();
          s7 = [];
          if (peg$r13.test(input.charAt(peg$currPos))) {
            s8 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s8 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e129);
            }
          }
          if (s8 !== peg$FAILED) {
            while (s8 !== peg$FAILED) {
              s7.push(s8);
              if (peg$r13.test(input.charAt(peg$currPos))) {
                s8 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e129);
                }
              }
            }
          } else {
            s7 = peg$FAILED;
          }
          if (s7 !== peg$FAILED) {
            s8 = peg$parse_();
            s6 = [s6, s7, s8];
            s5 = s6;
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          if (s5 !== peg$FAILED) {
            s5 = peg$parseidentifier_name();
            if (s5 === peg$FAILED) {
              peg$currPos = s4;
              s4 = peg$FAILED;
            } else {
              s4 = s5;
            }
          } else {
            s4 = s5;
          }
        }
        if (s3.length < 1) {
          peg$currPos = s2;
          s2 = peg$FAILED;
        } else {
          s2 = s3;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f129();
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsekeyword();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f130();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$parsesigned_decimal_literal();
            if (s0 === peg$FAILED) {
              s0 = peg$parsemacro_identifier();
            }
          }
        }
        return s0;
      }
      function peg$parsedelegate_decl() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 100) {
          s2 = peg$c33;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e37);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c69) {
            s2 = peg$c69;
            peg$currPos += 8;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e81);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            s4 = peg$parsefunction_signature_incomplete();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f131(s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseevent_decl() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 101) {
          s2 = peg$c22;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e26);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c72) {
            s2 = peg$c72;
            peg$currPos += 5;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e84);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            s4 = peg$parsefunction_signature_incomplete();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f132(s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsestruct_decl() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseustruct_macro();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s2 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 115) {
          s3 = peg$c24;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e28);
          }
        }
        peg$silentFails--;
        if (s3 !== peg$FAILED) {
          peg$currPos = s2;
          s2 = void 0;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c65) {
            s3 = peg$c65;
            peg$currPos += 6;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e77);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            s5 = peg$parseidentifier();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f133(s1, s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclass_decl() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseuclass_macro();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s2 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 99) {
          s3 = peg$c31;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e35);
          }
        }
        peg$silentFails--;
        if (s3 !== peg$FAILED) {
          peg$currPos = s2;
          s2 = void 0;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c64) {
            s3 = peg$c64;
            peg$currPos += 5;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e76);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            s5 = peg$parseidentifier();
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              s7 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 58) {
                s8 = peg$c29;
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e33);
                }
              }
              if (s8 !== peg$FAILED) {
                s9 = peg$currPos;
                s10 = peg$parse_();
                s11 = peg$currPos;
                s12 = peg$parseidentifier_name();
                if (s12 !== peg$FAILED) {
                  s13 = [];
                  s14 = peg$currPos;
                  s15 = peg$parse_();
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s16 = peg$c29;
                    peg$currPos++;
                  } else {
                    s16 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e33);
                    }
                  }
                  if (s16 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s17 = peg$c29;
                      peg$currPos++;
                    } else {
                      s17 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e33);
                      }
                    }
                    if (s17 !== peg$FAILED) {
                      s18 = peg$parse_();
                      s19 = peg$parseidentifier_name();
                      if (s19 !== peg$FAILED) {
                        s15 = [s15, s16, s17, s18, s19];
                        s14 = s15;
                      } else {
                        peg$currPos = s14;
                        s14 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s14;
                      s14 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s14;
                    s14 = peg$FAILED;
                  }
                  while (s14 !== peg$FAILED) {
                    s13.push(s14);
                    s14 = peg$currPos;
                    s15 = peg$parse_();
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s16 = peg$c29;
                      peg$currPos++;
                    } else {
                      s16 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$e33);
                      }
                    }
                    if (s16 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 58) {
                        s17 = peg$c29;
                        peg$currPos++;
                      } else {
                        s17 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$e33);
                        }
                      }
                      if (s17 !== peg$FAILED) {
                        s18 = peg$parse_();
                        s19 = peg$parseidentifier_name();
                        if (s19 !== peg$FAILED) {
                          s15 = [s15, s16, s17, s18, s19];
                          s14 = s15;
                        } else {
                          peg$currPos = s14;
                          s14 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s14;
                        s14 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s14;
                      s14 = peg$FAILED;
                    }
                  }
                  peg$savedPos = s11;
                  s11 = peg$f134(s1, s5);
                } else {
                  peg$currPos = s11;
                  s11 = peg$FAILED;
                }
                if (s11 !== peg$FAILED) {
                  s9 = s11;
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
                if (s9 === peg$FAILED) {
                  s9 = null;
                }
                s6 = s9;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              peg$savedPos = s0;
              s0 = peg$f135(s1, s5, s6);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseenum_decl() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseuenum_macro();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s2 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 101) {
          s3 = peg$c22;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e26);
          }
        }
        peg$silentFails--;
        if (s3 !== peg$FAILED) {
          peg$currPos = s2;
          s2 = void 0;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 4) === peg$c73) {
            s3 = peg$c73;
            peg$currPos += 4;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e85);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            s5 = peg$parseidentifier();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f136(s1, s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsenamespace_decl() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 110) {
          s2 = peg$c56;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e62);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 9) === peg$c79) {
            s2 = peg$c79;
            peg$currPos += 9;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e91);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            s4 = peg$currPos;
            s5 = peg$parseidentifier_name();
            if (s5 !== peg$FAILED) {
              s6 = [];
              s7 = peg$currPos;
              s8 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 58) {
                s9 = peg$c29;
                peg$currPos++;
              } else {
                s9 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e33);
                }
              }
              if (s9 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s10 = peg$c29;
                  peg$currPos++;
                } else {
                  s10 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e33);
                  }
                }
                if (s10 !== peg$FAILED) {
                  s11 = peg$parse_();
                  s12 = peg$parseidentifier_name();
                  if (s12 !== peg$FAILED) {
                    s8 = [s8, s9, s10, s11, s12];
                    s7 = s8;
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              } else {
                peg$currPos = s7;
                s7 = peg$FAILED;
              }
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                s7 = peg$currPos;
                s8 = peg$parse_();
                if (input.charCodeAt(peg$currPos) === 58) {
                  s9 = peg$c29;
                  peg$currPos++;
                } else {
                  s9 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$e33);
                  }
                }
                if (s9 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s10 = peg$c29;
                    peg$currPos++;
                  } else {
                    s10 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$e33);
                    }
                  }
                  if (s10 !== peg$FAILED) {
                    s11 = peg$parse_();
                    s12 = peg$parseidentifier_name();
                    if (s12 !== peg$FAILED) {
                      s8 = [s8, s9, s10, s11, s12];
                      s7 = s8;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s7;
                  s7 = peg$FAILED;
                }
              }
              peg$savedPos = s4;
              s4 = peg$f137();
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f138(s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseasset_decl() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 97) {
          s2 = peg$c77;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e89);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 5) === peg$c115) {
            s2 = peg$c115;
            peg$currPos += 5;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e130);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            s4 = peg$parseidentifier();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (input.substr(peg$currPos, 2) === peg$c116) {
                s6 = peg$c116;
                peg$currPos += 2;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e131);
                }
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                s8 = peg$parsetypename();
                if (s8 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s0 = peg$f139(s4, s8);
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclass_method_decl() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseaccess_specifier();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s2 = peg$currPos;
        s3 = peg$parseufunction_macro();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        s3 = peg$currPos;
        s4 = peg$parseaccess_specifier();
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_();
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        s4 = peg$parsefunction_signature();
        if (s4 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f140(s1, s2, s3, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseconstructor_decl() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseidentifier();
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c18;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e22);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseparameter_list();
            s5 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 41) {
              s6 = peg$c19;
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
            if (s6 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f141(s1, s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parsedestructor_decl() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 126) {
          s2 = peg$c13;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e17);
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseidentifier_name();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s1;
            s1 = peg$f142();
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 40) {
            s3 = peg$c18;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e22);
            }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 41) {
              s5 = peg$c19;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f143(s1);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclass_property_decl() {
        var s0, s1, s2, s3, s4, s5;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parseaccess_specifier();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          s1 = null;
        }
        s2 = peg$currPos;
        s3 = peg$parseuproperty_macro();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        s3 = peg$currPos;
        s4 = peg$parseaccess_specifier();
        if (s4 !== peg$FAILED) {
          s5 = peg$parse_();
          s3 = s4;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        s4 = peg$parsevar_decl();
        if (s4 === peg$FAILED) {
          s4 = peg$parseincomplete_var_decl();
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = s0;
          s0 = peg$f144(s1, s2, s3, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseaccess_specifier() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 112) {
          s2 = peg$c70;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e82);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 7) === peg$c117) {
            s2 = peg$c117;
            peg$currPos += 7;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e132);
            }
          }
          if (s2 === peg$FAILED) {
            if (input.substr(peg$currPos, 9) === peg$c118) {
              s2 = peg$c118;
              peg$currPos += 9;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e133);
              }
            }
            if (s2 === peg$FAILED) {
              if (input.substr(peg$currPos, 6) === peg$c119) {
                s2 = peg$c119;
                peg$currPos += 6;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e134);
                }
              }
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s0 = peg$f145();
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 97) {
            s2 = peg$c77;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e89);
            }
          }
          peg$silentFails--;
          if (s2 !== peg$FAILED) {
            peg$currPos = s1;
            s1 = void 0;
          } else {
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c78) {
              s2 = peg$c78;
              peg$currPos += 6;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e90);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$currPos;
              s4 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 58) {
                s5 = peg$c29;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e33);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse_();
                s7 = peg$parseidentifier();
                if (s7 !== peg$FAILED) {
                  s3 = s7;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = null;
              }
              s0 = s3;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
        return s0;
      }
      function peg$parseaccess_decl() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 97) {
          s2 = peg$c77;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e89);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c78) {
            s2 = peg$c78;
            peg$currPos += 6;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e90);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$currPos;
            s4 = peg$parse_();
            s5 = peg$parseidentifier();
            if (s5 !== peg$FAILED) {
              s6 = peg$currPos;
              s7 = peg$parse_();
              if (input.charCodeAt(peg$currPos) === 61) {
                s8 = peg$c7;
                peg$currPos++;
              } else {
                s8 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$e11);
                }
              }
              if (s8 !== peg$FAILED) {
                s9 = peg$currPos;
                s10 = peg$parse_();
                s11 = peg$parseaccess_list();
                if (s11 !== peg$FAILED) {
                  s9 = s11;
                } else {
                  peg$currPos = s9;
                  s9 = peg$FAILED;
                }
                if (s9 === peg$FAILED) {
                  s9 = null;
                }
                s6 = s9;
              } else {
                peg$currPos = s6;
                s6 = peg$FAILED;
              }
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              peg$savedPos = s3;
              s3 = peg$f146(s5, s6);
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            s4 = peg$currPos;
            peg$silentFails++;
            s5 = peg$currPos;
            s6 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 58) {
              s7 = peg$c29;
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e33);
              }
            }
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            peg$silentFails--;
            if (s5 === peg$FAILED) {
              s4 = void 0;
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f147(s3);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseaccess_list() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseaccess_class();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c30;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            s7 = peg$parseaccess_class();
            if (s7 !== peg$FAILED) {
              s3 = s7;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c30;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              s7 = peg$parseaccess_class();
              if (s7 !== peg$FAILED) {
                s3 = s7;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c30;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f148(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseaccess_class() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        s1 = peg$parseidentifier();
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 42) {
            s2 = peg$c1;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e1);
            }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$f149();
          }
          s1 = s2;
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$currPos;
          s3 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 40) {
            s4 = peg$c18;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e22);
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            s6 = peg$parseaccess_mod_list();
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            s7 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 41) {
              s8 = peg$c19;
              peg$currPos++;
            } else {
              s8 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e23);
              }
            }
            if (s8 !== peg$FAILED) {
              s2 = s6;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 === peg$FAILED) {
            s2 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f150(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseaccess_mod_list() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parseidentifier();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c30;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            s7 = peg$parseidentifier();
            if (s7 !== peg$FAILED) {
              s3 = s7;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c30;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              s7 = peg$parseidentifier();
              if (s7 !== peg$FAILED) {
                s3 = s7;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c30;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f151(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseincomplete_access_specifier() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 97) {
          s2 = peg$c77;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e89);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 6) === peg$c78) {
            s2 = peg$c78;
            peg$currPos += 6;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e90);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c29;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e33);
              }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$currPos;
              s6 = peg$parse_();
              s7 = peg$parseidentifier();
              if (s7 !== peg$FAILED) {
                s5 = s7;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              peg$savedPos = s0;
              s0 = peg$f152(s5);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseclass_default_statement() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 100) {
          s2 = peg$c33;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$e37);
          }
        }
        peg$silentFails--;
        if (s2 !== peg$FAILED) {
          peg$currPos = s1;
          s1 = void 0;
        } else {
          s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 7) === peg$c34) {
            s2 = peg$c34;
            peg$currPos += 7;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e38);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            s4 = peg$parseassignment();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s0 = peg$f153(s4);
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseenum_statement() {
        var s0, s1, s2, s3, s4, s5, s6;
        s0 = peg$currPos;
        s1 = peg$parseenum_value_decl();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c30;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parseenum_value_decl();
            if (s6 !== peg$FAILED) {
              s3 = s6;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$currPos;
            s4 = peg$parse_();
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c30;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$e34);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseenum_value_decl();
              if (s6 !== peg$FAILED) {
                s3 = s6;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          }
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 44) {
            s5 = peg$c30;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e34);
            }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f154(s1, s2);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      function peg$parseenum_value_decl() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        s1 = peg$parsecomment_documentation();
        s2 = peg$parseidentifier();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = peg$parse_();
          if (input.charCodeAt(peg$currPos) === 61) {
            s5 = peg$c7;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$e11);
            }
          }
          if (s5 !== peg$FAILED) {
            s6 = peg$parse_();
            s7 = peg$parseoptional_expression();
            s3 = s7;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          s4 = peg$currPos;
          s5 = peg$parse_();
          s6 = peg$parseumeta_macro();
          if (s6 !== peg$FAILED) {
            s4 = s6;
          } else {
            peg$currPos = s4;
            s4 = peg$FAILED;
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          peg$savedPos = s0;
          s0 = peg$f155(s1, s2, s3, s4);
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        return s0;
      }
      peg$result = peg$startRuleFunction();
      if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
      } else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
          peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(
          peg$maxFailExpected,
          peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
          peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
      }
    }
    module2.exports = {
      SyntaxError: peg$SyntaxError,
      parse: peg$parse
    };
  }
});

// unreal-angelscript-lsp/language-server/out/as_parser.js
var require_as_parser = __commonJS({
  "unreal-angelscript-lsp/language-server/out/as_parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParseStatement = exports2.GetConstantNumberFromNode = exports2.ResolveFunctionOverloadsFromIdentifier = exports2.ResolveFunctionOverloadsFromExpression = exports2.DisambiguateFunctionOverloadsFromOverriddenFunctions = exports2.ResolveFunctionFromExpression = exports2.CollapseNamespaceFromNode = exports2.GetOverloadMethodForOperator = exports2.ResolveTypeFromExpression = exports2.IsPrimitiveLiteralNode = exports2.GetTypeSymbolLocation = exports2.GetSymbolLocationInScope = exports2.GetSymbolLocation = exports2.RecursiveMarkDependentModules = exports2.GetModulesPotentiallyImportingNamespace = exports2.GetModulesPotentiallyImportingMultiple = exports2.GetModulesPotentiallyImporting = exports2.GetModulesPotentiallyImportingSymbol = exports2.ClearAllResolvedModules = exports2.UpdateModuleFromDisk = exports2.UpdateModuleFromContentChanges = exports2.UpdateModuleFromContent = exports2.ResolveModule = exports2.PostProcessModuleTypesAndDependencies = exports2.PostProcessModuleTypes = exports2.ParseModuleAndDependencies = exports2.ParseModule = exports2.NormalizeUri = exports2.GetOrCreateModule = exports2.GetModuleByUri = exports2.GetModule = exports2.GetAllParsedModules = exports2.GetAllLoadedModules = exports2.ScriptLiteralAssetsByName = exports2.ModuleDatabase = exports2.ASLiteralAsset = exports2.ASAnnotatedCall = exports2.ASDelegateBind = exports2.ASStatement = exports2.ASScope = exports2.ASSemanticSymbol = exports2.ASSymbolType = exports2.ASVariable = exports2.ASElement = exports2.ASModule = exports2.ASScopeType = exports2.ASKeywords = exports2.node_types = exports2.SetInitialParseDone = exports2.GetScriptSettings = void 0;
    var vscode_languageserver_textdocument_1 = require_main5();
    var vscode_languageserver_1 = require_main4();
    var fs = require("fs");
    var typedb2 = require_database();
    var generated_code_1 = require_generated_code();
    var PEGGY_GRAMMAR = require_angelscript();
    var ScriptSettings = {
      automaticImports: false,
      floatIsFloat64: false,
      useAngelscriptHaze: false,
      deprecateStaticClass: false,
      disallowStaticClass: false,
      exposeGlobalFunctions: true,
      deprecateActorGenerics: false,
      disallowActorGenerics: false
    };
    var PreParsedIdentifiersInModules = /* @__PURE__ */ new Map();
    var InitialParseDone = false;
    function GetScriptSettings() {
      return ScriptSettings;
    }
    exports2.GetScriptSettings = GetScriptSettings;
    function SetInitialParseDone() {
      InitialParseDone = true;
    }
    exports2.SetInitialParseDone = SetInitialParseDone;
    exports2.node_types = require_node_types();
    exports2.ASKeywords = [
      "for",
      "if",
      "enum",
      "return",
      "continue",
      "break",
      "import",
      "class",
      "struct",
      "default",
      "void",
      "const",
      "delegate",
      "event",
      "else",
      "while",
      "case",
      "Cast",
      "namespace",
      "UFUNCTION",
      "UPROPERTY",
      "UCLASS",
      "USTRUCT",
      "nullptr",
      "true",
      "false",
      "this",
      "auto",
      "final",
      "property",
      "override",
      "mixin",
      "switch",
      "fallthrough"
    ];
    var ASScopeType;
    (function(ASScopeType2) {
      ASScopeType2[ASScopeType2["Global"] = 0] = "Global";
      ASScopeType2[ASScopeType2["Class"] = 1] = "Class";
      ASScopeType2[ASScopeType2["Function"] = 2] = "Function";
      ASScopeType2[ASScopeType2["Enum"] = 3] = "Enum";
      ASScopeType2[ASScopeType2["Code"] = 4] = "Code";
      ASScopeType2[ASScopeType2["Namespace"] = 5] = "Namespace";
      ASScopeType2[ASScopeType2["LiteralAsset"] = 6] = "LiteralAsset";
    })(ASScopeType = exports2.ASScopeType || (exports2.ASScopeType = {}));
    var ASModule = class {
      constructor() {
        this.created = false;
        this.content = null;
        this.lastEditStart = -1;
        this.lastEditEnd = -1;
        this.isOpened = false;
        this.exists = true;
        this.loaded = false;
        this.textDocument = null;
        this.parsed = false;
        this.resolved = false;
        this.typesPostProcessed = false;
        this.resolveCallbacks = null;
        this.rootscope = null;
        this.namespaces = [];
        this.types = [];
        this.globalSymbols = [];
        this.semanticSymbols = [];
        this.literalAssets = [];
        this.importedModules = [];
        this.delegateBinds = [];
        this.annotatedFunctionCalls = [];
        this.moduleDependencies = /* @__PURE__ */ new Set();
        this.flatImportList = /* @__PURE__ */ new Set();
        this.preParsedImports = new Array();
        this.preParsedIdentifiers = new Array();
        this.queuedParse = null;
        this.rawStatements = [];
        this.cachedStatements = null;
        this.loadedFromCacheCount = 0;
        this.parsedStatementCount = 0;
      }
      getOffset(position) {
        if (!this.textDocument)
          return -1;
        return this.textDocument.offsetAt(position);
      }
      getPosition(offset) {
        if (!this.textDocument)
          return vscode_languageserver_1.Position.create(-1, -1);
        return this.textDocument.positionAt(offset);
      }
      getRange(start_offset, end_offset) {
        return vscode_languageserver_1.Range.create(this.getPosition(start_offset), this.getPosition(end_offset));
      }
      getScopeAt(offset) {
        if (!this.parsed)
          return null;
        return this.rootscope.getScopeAt(offset);
      }
      getStatementAt(offset) {
        if (!this.parsed)
          return null;
        return this.rootscope.getStatementAt(offset);
      }
      getLocation(offset) {
        return vscode_languageserver_1.Location.create(this.displayUri, vscode_languageserver_1.Range.create(this.getPosition(offset), this.getPosition(offset)));
      }
      getLineText(line) {
        return this.content.substring(this.getOffset(vscode_languageserver_1.Position.create(line, 0)), this.getOffset(vscode_languageserver_1.Position.create(line, 1e4)));
      }
      isLineEmpty(line) {
        return /^\s*$/.test(this.content.substring(this.getOffset(vscode_languageserver_1.Position.create(line, 0)), this.getOffset(vscode_languageserver_1.Position.create(line, 1e4))));
      }
      getLocationRange(start_offset, end_offset) {
        return vscode_languageserver_1.Location.create(this.displayUri, this.getRange(start_offset, end_offset));
      }
      getSymbolAt(offset) {
        for (let symbol of this.semanticSymbols) {
          if (offset >= symbol.start && offset < symbol.end)
            return symbol;
        }
        return null;
      }
      getSymbolAtOrBefore(offset) {
        let symbolBefore = null;
        for (let symbol of this.semanticSymbols) {
          if (offset >= symbol.start && offset < symbol.end)
            return symbol;
          if (offset == symbol.end)
            symbolBefore = symbol;
        }
        return symbolBefore;
      }
      isEditingInside(start, end) {
        if (this.lastEditStart == -1)
          return false;
        return start < this.lastEditEnd && end > this.lastEditStart;
      }
      isEditingNode(statement, node) {
        if (!node || !statement)
          return false;
        return this.isEditingInside(statement.start_offset + node.start, statement.start_offset + node.end);
      }
      getScopeDeclaringLocalSymbol(symbol) {
        if (symbol.type != ASSymbolType.Parameter && symbol.type != ASSymbolType.LocalVariable)
          return null;
        let checkscope = this.getScopeAt(symbol.start);
        while (checkscope) {
          for (let scopevar of checkscope.variables) {
            if (scopevar.name == symbol.symbol_name)
              return checkscope;
          }
          if (!checkscope.isInFunctionBody())
            break;
          checkscope = checkscope.parentscope;
        }
        return null;
      }
      isModuleImported(modulename) {
        return this.flatImportList.has(modulename);
      }
      markDependencyModule(dependency) {
        if (dependency)
          this.moduleDependencies.add(dependency);
      }
      markDependencySymbol(dependency) {
        if (dependency instanceof typedb2.DBMethod)
          this.markDependencyFunction(dependency);
        else if (dependency instanceof typedb2.DBProperty)
          this.markDependencyProperty(dependency);
      }
      markDependencyType(dependency) {
        if (dependency && dependency.declaredModule)
          this.moduleDependencies.add(GetModule(dependency.declaredModule));
      }
      markDependencyNamespace(namespace) {
        for (let decl of namespace.declarations) {
          if (decl.declaredModule)
            this.moduleDependencies.add(GetModule(decl.declaredModule));
        }
      }
      markDependencyFunction(dependency) {
        if (!dependency.declaredModule)
          return;
        this.moduleDependencies.add(GetModule(dependency.declaredModule));
        if (dependency.args) {
          for (let arg of dependency.args)
            this.markDependencyTypename(dependency.namespace, arg.typename);
        }
        if (dependency.returnType && dependency.returnType != "void")
          this.markDependencyTypename(dependency.namespace, dependency.returnType);
      }
      markDependencyProperty(dependency) {
        if (!dependency.declaredModule)
          return;
        this.moduleDependencies.add(GetModule(dependency.declaredModule));
        this.markDependencyTypename(dependency.namespace, dependency.typename);
      }
      markDependencyTypename(namespace, typename) {
        let dependencyType = typedb2.LookupType(namespace, typename);
        if (dependencyType)
          this.markDependencyType(dependencyType);
        else
          this.markDependencyIdentifier(typename);
      }
      markDependencyIdentifier(identifier) {
        let moduleList = PreParsedIdentifiersInModules.get(identifier);
        if (!moduleList)
          return;
        for (let dependency of moduleList)
          this.moduleDependencies.add(dependency);
      }
      onResolved(callback) {
        if (this.resolved) {
          callback();
          return;
        }
        if (!this.resolveCallbacks)
          this.resolveCallbacks = [];
        this.resolveCallbacks.push(callback);
      }
    };
    exports2.ASModule = ASModule;
    var ASElement = class {
      constructor() {
        this.previous = null;
        this.next = null;
      }
    };
    exports2.ASElement = ASElement;
    var ASVariable = class {
      constructor() {
        this.isArgument = false;
        this.isMember = false;
        this.isGlobal = false;
        this.isPrivate = false;
        this.isProtected = false;
        this.isAuto = false;
        this.isLoopVariable = false;
        this.isIterator = false;
        this.in_statement = false;
        this.node_typename = null;
        this.node_expression = null;
        this.potentiallyWrong = false;
        this.accessSpecifier = null;
        this.isUnused = true;
        this.hasAnyUsages = false;
        this.usages = null;
        this.start_offset_type = -1;
        this.end_offset_type = -1;
        this.start_offset_name = -1;
        this.end_offset_name = -1;
        this.start_offset_expression = -1;
        this.end_offset_expression = -1;
      }
      isReference() {
        return this.typename.indexOf("&") != -1;
      }
      isValueType(scope) {
        let dbType = typedb2.LookupType(scope.getNamespace(), this.typename);
        if (dbType)
          return dbType.isValueType();
        return false;
      }
    };
    exports2.ASVariable = ASVariable;
    var ASSymbolType;
    (function(ASSymbolType2) {
      ASSymbolType2[ASSymbolType2["Typename"] = 0] = "Typename";
      ASSymbolType2[ASSymbolType2["Namespace"] = 1] = "Namespace";
      ASSymbolType2[ASSymbolType2["TemplateBaseType"] = 2] = "TemplateBaseType";
      ASSymbolType2[ASSymbolType2["Parameter"] = 3] = "Parameter";
      ASSymbolType2[ASSymbolType2["LocalVariable"] = 4] = "LocalVariable";
      ASSymbolType2[ASSymbolType2["MemberVariable"] = 5] = "MemberVariable";
      ASSymbolType2[ASSymbolType2["MemberAccessor"] = 6] = "MemberAccessor";
      ASSymbolType2[ASSymbolType2["GlobalVariable"] = 7] = "GlobalVariable";
      ASSymbolType2[ASSymbolType2["GlobalAccessor"] = 8] = "GlobalAccessor";
      ASSymbolType2[ASSymbolType2["MemberFunction"] = 9] = "MemberFunction";
      ASSymbolType2[ASSymbolType2["GlobalFunction"] = 10] = "GlobalFunction";
      ASSymbolType2[ASSymbolType2["AccessSpecifier"] = 11] = "AccessSpecifier";
      ASSymbolType2[ASSymbolType2["UnknownError"] = 12] = "UnknownError";
      ASSymbolType2[ASSymbolType2["NoSymbol"] = 13] = "NoSymbol";
    })(ASSymbolType = exports2.ASSymbolType || (exports2.ASSymbolType = {}));
    var ASSemanticSymbol = class {
      constructor() {
        this.start = -1;
        this.end = -1;
        this.container_type = null;
        this.symbol_name = null;
        this.isWriteAccess = false;
        this.isUnimported = false;
        this.isAuto = false;
        this.noColor = false;
      }
      overlapsRange(range_start, range_end) {
        return range_start < this.end && range_end > this.start;
      }
    };
    exports2.ASSemanticSymbol = ASSemanticSymbol;
    var ASScope = class _ASScope extends ASElement {
      constructor() {
        super(...arguments);
        this.start_offset = -1;
        this.end_offset = -1;
        this.parsed = false;
        this.statements = [];
        this.scopes = [];
        this.declaration = null;
        this.element_head = null;
        this.scopetype = null;
        this.parentscope = null;
        this.variables = [];
        this.variablesByName = /* @__PURE__ */ new Map();
        this.dbnamespace = null;
        this.dbtype = null;
        this.dbfunc = null;
        this.assettype = null;
        this.resolvedNamespace = null;
        this.available_global_types = null;
      }
      isInFunctionBody() {
        switch (this.scopetype) {
          case ASScopeType.Function:
          case ASScopeType.Code:
          case ASScopeType.LiteralAsset:
            return true;
        }
        return false;
      }
      getScopeAt(offset) {
        if (!this.parsed)
          return null;
        for (let subscope of this.scopes) {
          if (offset >= subscope.start_offset && offset < subscope.end_offset)
            return subscope.getScopeAt(offset);
        }
        return this;
      }
      getStatementAt(offset) {
        if (!this.parsed)
          return null;
        let element = this.element_head;
        while (element) {
          if (element instanceof _ASScope) {
            if (offset >= element.start_offset && offset < element.end_offset) {
              let substatement = element.getStatementAt(offset);
              if (substatement)
                return substatement;
            }
          } else if (element instanceof ASStatement) {
            if (offset >= element.start_offset && offset < element.end_offset) {
              return element;
            }
          }
          element = element.next;
        }
        return null;
      }
      getParentFunctionScope() {
        let checkscope = this;
        while (checkscope != null) {
          let dbFunc = checkscope.getDatabaseFunction();
          if (dbFunc)
            return checkscope;
          checkscope = checkscope.parentscope;
        }
        return null;
      }
      getParentFunction() {
        let checkscope = this;
        while (checkscope != null) {
          if (checkscope.scopetype != ASScopeType.Function && checkscope.scopetype != ASScopeType.Code)
            break;
          if (checkscope.dbfunc)
            return checkscope.dbfunc;
          checkscope = checkscope.parentscope;
        }
        return null;
      }
      getParentTypeScope() {
        let checkscope = this;
        while (checkscope != null) {
          if (checkscope.scopetype == ASScopeType.Global)
            break;
          if (checkscope.scopetype == ASScopeType.LiteralAsset)
            return checkscope;
          let dbType = checkscope.getDatabaseType();
          if (dbType)
            return checkscope;
          checkscope = checkscope.parentscope;
        }
        return null;
      }
      getParentType() {
        if (this.dbtype)
          return this.dbtype;
        if (this.scopetype == ASScopeType.LiteralAsset)
          return typedb2.GetTypeByName(this.assettype);
        if (this.parentscope) {
          if (this.parentscope.dbtype)
            return this.parentscope.dbtype;
          if (this.parentscope.scopetype == ASScopeType.LiteralAsset)
            return typedb2.GetTypeByName(this.parentscope.assettype);
          let checkscope = this.parentscope.parentscope;
          while (checkscope != null) {
            if (checkscope.scopetype == ASScopeType.Namespace)
              break;
            if (checkscope.scopetype == ASScopeType.Global)
              break;
            if (checkscope.scopetype == ASScopeType.LiteralAsset)
              return typedb2.GetTypeByName(checkscope.assettype);
            if (checkscope.dbtype)
              return checkscope.dbtype;
            checkscope = checkscope.parentscope;
          }
          return null;
        } else {
          return null;
        }
      }
      getNamespace() {
        return this.resolvedNamespace;
      }
      getDatabaseType() {
        return this.dbtype;
      }
      getDatabaseFunction() {
        return this.dbfunc;
      }
      findScopeForType(typename) {
        let dbtype = this.getDatabaseType();
        if (dbtype && dbtype.name == typename)
          return this;
        for (let subscope of this.scopes) {
          let found = subscope.findScopeForType(typename);
          if (found)
            return found;
        }
        return null;
      }
      isNamespaceOrGlobalScope() {
        if (this.scopetype == ASScopeType.Global)
          return true;
        if (this.scopetype == ASScopeType.Namespace)
          return true;
        return false;
      }
    };
    exports2.ASScope = ASScope;
    var ASStatement = class extends ASElement {
      constructor() {
        super(...arguments);
        this.rawIndex = -1;
        this.start_offset = -1;
        this.end_offset = -1;
        this.ast = null;
        this.parsed = false;
        this.endsWithSemicolon = false;
        this.parseError = false;
        this.parsedType = ASScopeType.Code;
        this.generatedTypes = false;
      }
    };
    exports2.ASStatement = ASStatement;
    var ASDelegateBind = class {
      constructor() {
        this.statement = null;
        this.scope = null;
        this.delegateType = null;
        this.node_expression = null;
        this.node_object = null;
        this.node_name = null;
        this.node_wildcard = null;
        this.wildcard_name = null;
      }
      getFunctionName() {
        if (!this.node_name)
          return null;
        else if (this.node_name.type == exports2.node_types.ConstName)
          return this.node_name.value.substring(2, this.node_name.value.length - 1);
        else if (this.node_name.type == exports2.node_types.ConstString)
          return this.node_name.value.substring(1, this.node_name.value.length - 1);
        else
          return null;
      }
      resolveObjectType() {
        if (!this.node_object)
          return null;
        else
          return ResolveTypeFromExpression(this.scope, this.node_object);
      }
      resolveBoundFunction() {
        let funcName = this.getFunctionName();
        if (!funcName)
          return null;
        let objType = this.resolveObjectType();
        if (!objType)
          return null;
        let foundFunc = objType.findFirstSymbol(funcName, typedb2.DBAllowSymbol.Functions);
        if (!foundFunc)
          foundFunc = objType.findMethodByUnrealName(funcName);
        if (foundFunc && foundFunc instanceof typedb2.DBMethod)
          return foundFunc;
        return null;
      }
    };
    exports2.ASDelegateBind = ASDelegateBind;
    var ASAnnotatedCall = class {
      constructor() {
        this.statement = null;
        this.scope = null;
        this.method = null;
        this.node_call = null;
      }
    };
    exports2.ASAnnotatedCall = ASAnnotatedCall;
    var ASLiteralAsset = class {
      constructor() {
        this.module = null;
        this.statement = null;
        this.content_scope = null;
      }
    };
    exports2.ASLiteralAsset = ASLiteralAsset;
    exports2.ModuleDatabase = /* @__PURE__ */ new Map();
    var ModulesByUri = /* @__PURE__ */ new Map();
    exports2.ScriptLiteralAssetsByName = /* @__PURE__ */ new Map();
    function GetAllLoadedModules() {
      let files = [];
      for (let module3 of exports2.ModuleDatabase) {
        if (module3[1].loaded && module3[1].exists)
          files.push(module3[1]);
      }
      return files;
    }
    exports2.GetAllLoadedModules = GetAllLoadedModules;
    function GetAllParsedModules() {
      let files = [];
      for (let module3 of exports2.ModuleDatabase) {
        if (module3[1].parsed)
          files.push(module3[1]);
      }
      return files;
    }
    exports2.GetAllParsedModules = GetAllParsedModules;
    function GetModule(modulename) {
      let module3 = exports2.ModuleDatabase.get(modulename.toLowerCase());
      if (!module3) {
        module3 = new ASModule();
        module3.modulename = modulename;
        exports2.ModuleDatabase.set(modulename.toLowerCase(), module3);
      }
      return module3;
    }
    exports2.GetModule = GetModule;
    function GetModuleByUri(uri) {
      return ModulesByUri.get(NormalizeUri(uri));
    }
    exports2.GetModuleByUri = GetModuleByUri;
    function GetOrCreateModule(modulename, filename, uri) {
      let module3 = GetModule(modulename);
      if (!module3.created) {
        module3.modulename = modulename;
        module3.uri = NormalizeUri(uri);
        module3.displayUri = decodeURIComponent(uri);
        module3.filename = filename;
        module3.created = true;
        ModulesByUri.set(module3.uri, module3);
      }
      return module3;
    }
    exports2.GetOrCreateModule = GetOrCreateModule;
    function NormalizeUri(uri) {
      let result = decodeURIComponent(uri).toLowerCase();
      return result;
    }
    exports2.NormalizeUri = NormalizeUri;
    function ParseModule(module3, debug = false) {
      if (module3.parsed)
        return;
      typedb2.OnDirtyTypeCaches();
      module3.parsed = true;
      module3.rootscope = new ASScope();
      module3.rootscope.module = module3;
      module3.rootscope.start_offset = 0;
      module3.rootscope.end_offset = module3.textDocument.getText().length;
      ParseScopeIntoStatements(module3.rootscope);
      ParseAllStatements(module3.rootscope, debug);
      GenerateTypeInformation(module3.rootscope);
    }
    exports2.ParseModule = ParseModule;
    function ParseModuleAndDependencies(module3, visited = null) {
      let visitList = visited;
      if (visitList == null)
        visitList = /* @__PURE__ */ new Set();
      else if (visitList.has(module3))
        return;
      if (!module3.loaded)
        UpdateModuleFromDisk(module3);
      if (!module3.loaded)
        return;
      if (!module3.parsed)
        ParseModule(module3);
      visitList.add(module3);
      for (let importedModule of module3.importedModules)
        ParseModuleAndDependencies(importedModule, visitList);
    }
    exports2.ParseModuleAndDependencies = ParseModuleAndDependencies;
    function PostProcessModuleTypes(module3) {
      if (module3.typesPostProcessed)
        return;
      if (!module3.parsed)
        return;
      module3.typesPostProcessed = true;
      for (let dbtype of module3.types)
        (0, generated_code_1.ProcessScriptTypeGeneratedCode)(dbtype, module3);
    }
    exports2.PostProcessModuleTypes = PostProcessModuleTypes;
    function PostProcessModuleTypesAndDependencies(module3, visited = null) {
      let visitList = visited;
      if (visitList == null)
        visitList = /* @__PURE__ */ new Set();
      else if (visitList.has(module3))
        return;
      if (!module3.parsed)
        return;
      if (!module3.typesPostProcessed)
        PostProcessModuleTypes(module3);
      visitList.add(module3);
      for (let importedModule of module3.importedModules)
        PostProcessModuleTypesAndDependencies(importedModule, visitList);
    }
    exports2.PostProcessModuleTypesAndDependencies = PostProcessModuleTypesAndDependencies;
    function ResolveModule(module3) {
      if (!module3.parsed)
        return;
      if (module3.resolved)
        return;
      while (!module3.resolved) {
        module3.resolved = true;
        module3.flatImportList.clear();
        let importList = new Array();
        importList.push(module3);
        for (let i = 0; i < importList.length; ++i) {
          if (!importList[i].parsed)
            continue;
          if (module3.flatImportList.has(importList[i].modulename))
            continue;
          module3.flatImportList.add(importList[i].modulename);
          for (let importMod of importList[i].importedModules)
            importList.push(importMod);
        }
        ResolveAutos(module3.rootscope);
        DetectScopeSymbols(module3.rootscope);
        if (ScriptSettings.automaticImports) {
          for (let dependencyModule of module3.moduleDependencies) {
            if (!dependencyModule.parsed) {
              ParseModuleAndDependencies(dependencyModule);
              module3.resolved = false;
            }
            if (!dependencyModule.resolved) {
              for (let dependencyClass of dependencyModule.types) {
                let newTypesLoaded = EnsureTypeHierarchyFullyParsed(dependencyClass);
                if (newTypesLoaded)
                  module3.resolved = false;
              }
            }
            if (!dependencyModule.typesPostProcessed) {
              PostProcessModuleTypesAndDependencies(dependencyModule);
              module3.resolved = false;
            }
          }
          if (!module3.resolved) {
            module3.semanticSymbols = [];
            module3.moduleDependencies.clear();
          }
        }
      }
      if (module3.resolveCallbacks) {
        let callbacks = module3.resolveCallbacks;
        module3.resolveCallbacks = null;
        for (let callback of callbacks)
          callback();
      }
      module3.cachedStatements = null;
    }
    exports2.ResolveModule = ResolveModule;
    function EnsureTypeHierarchyFullyParsed(dbtype) {
      let newTypesLoaded = false;
      let superTypeName = dbtype.supertype;
      let superNamespace = dbtype.namespace;
      while (superTypeName) {
        let superType = typedb2.LookupType(superNamespace, superTypeName);
        if (superType) {
          if (superType.declaredModule) {
            let superModule = GetModule(superType.declaredModule);
            if (superModule.resolved) {
              break;
            } else {
              superTypeName = superType.supertype;
              superNamespace = superType.namespace;
              continue;
            }
          } else {
            break;
          }
        } else {
          let potentialModules = PreParsedIdentifiersInModules.get(superTypeName);
          if (potentialModules) {
            for (let moduleWithSuper of potentialModules)
              ParseModuleAndDependencies(moduleWithSuper);
            let superType2 = typedb2.LookupType(superNamespace, superTypeName);
            if (superType2) {
              newTypesLoaded = true;
              continue;
            } else {
              break;
            }
          } else {
            break;
          }
        }
      }
      return newTypesLoaded;
    }
    function UpdateModuleFromContent(module3, content) {
      if (module3.content) {
        let previousEditStart = module3.lastEditStart;
        let previousEditEnd = module3.lastEditEnd;
        module3.lastEditStart = -1;
        module3.lastEditEnd = -1;
        let shortestLength = Math.min(module3.content.length, content.length);
        for (let i = 0; i < shortestLength; ++i) {
          if (module3.content[i] != content[i]) {
            module3.lastEditStart = i;
            break;
          }
        }
        if (module3.lastEditStart == -1) {
          if (content.length != module3.content.length) {
            module3.lastEditStart = content.length - 1;
            module3.lastEditEnd = content.length;
          } else {
            module3.lastEditStart = previousEditStart;
            module3.lastEditEnd = previousEditEnd;
          }
        } else {
          let isDelete = module3.content.length > content.length;
          if (isDelete) {
            let deleteLength = module3.content.length - content.length;
            let oldIndex = module3.lastEditStart + deleteLength;
            let newIndex = module3.lastEditStart;
            let remainderMatches = true;
            while (oldIndex < module3.content.length) {
              if (module3.content[oldIndex] != content[newIndex]) {
                remainderMatches = false;
                break;
              }
              ++oldIndex;
              ++newIndex;
            }
            if (remainderMatches) {
              let containsNewline = false;
              for (let i = 0; i < deleteLength; ++i) {
                if (module3.content[module3.lastEditStart + i] == "\n") {
                  containsNewline = true;
                  break;
                }
              }
              if (containsNewline)
                module3.lastEditStart = -1;
              else
                module3.lastEditStart -= 1;
            }
            if (module3.lastEditStart != -1)
              module3.lastEditEnd = module3.lastEditStart + 1;
            else
              module3.lastEditEnd = -1;
          } else {
            let addLength = content.length - module3.content.length;
            let oldIndex = module3.lastEditStart;
            let newIndex = module3.lastEditStart + addLength;
            let remainderMatches = true;
            while (oldIndex < module3.content.length) {
              if (module3.content[oldIndex] != content[newIndex]) {
                remainderMatches = false;
                break;
              }
              ++oldIndex;
              ++newIndex;
            }
            if (remainderMatches) {
              module3.lastEditEnd = module3.lastEditStart + addLength;
            } else {
              module3.lastEditEnd = module3.lastEditStart + 1;
            }
          }
        }
      } else {
        module3.lastEditStart = -1;
        module3.lastEditEnd = -1;
      }
      ClearModule(module3);
      module3.content = content;
      module3.exists = true;
      LoadModule(module3);
    }
    exports2.UpdateModuleFromContent = UpdateModuleFromContent;
    function UpdateModuleFromContentChanges(module3, contentChanges) {
      let textDocument = module3.textDocument;
      ClearModule(module3);
      vscode_languageserver_textdocument_1.TextDocument.update(textDocument, contentChanges, textDocument.version + 1);
      module3.textDocument = textDocument;
      module3.content = textDocument.getText();
      module3.exists = true;
      module3.loaded = true;
      for (let change of contentChanges) {
        if ("range" in change) {
          if (change.text.length == 0) {
            module3.lastEditStart = textDocument.offsetAt(change.range.start) - 1;
            module3.lastEditEnd = textDocument.offsetAt(change.range.start) + change.text.length;
          } else {
            module3.lastEditStart = textDocument.offsetAt(change.range.start);
            module3.lastEditEnd = textDocument.offsetAt(change.range.start) + change.text.length;
          }
        }
      }
    }
    exports2.UpdateModuleFromContentChanges = UpdateModuleFromContentChanges;
    function UpdateModuleFromDisk(module3) {
      if (!module3.filename)
        return;
      ClearModule(module3);
      try {
        module3.content = fs.readFileSync(module3.filename, "utf8");
        if (module3.content.charCodeAt(0) === 65279)
          module3.content = module3.content.substring(1);
        module3.exists = true;
      } catch (readError) {
        module3.content = "";
        module3.exists = false;
      }
      module3.lastEditStart = -1;
      module3.lastEditEnd = -1;
      LoadModule(module3);
      PreParseImports(module3);
      PreParseTypes(module3);
    }
    exports2.UpdateModuleFromDisk = UpdateModuleFromDisk;
    function ClearAllResolvedModules() {
      for (let [modulename, asmodule] of exports2.ModuleDatabase) {
        if (asmodule.resolved) {
          asmodule.resolved = false;
          asmodule.semanticSymbols = [];
          asmodule.delegateBinds = [];
          asmodule.annotatedFunctionCalls = [];
        }
      }
    }
    exports2.ClearAllResolvedModules = ClearAllResolvedModules;
    function LoadModule(module3) {
      if (module3.loaded)
        return;
      module3.loaded = true;
      module3.textDocument = vscode_languageserver_textdocument_1.TextDocument.create(module3.uri, "angelscript", 1, module3.content);
    }
    var re_import_statement = /\s*import\s+([A-Za-z0-9_]+(\.[A-Za-z0-9_]+)*);/g;
    function PreParseImports(module3) {
      module3.preParsedImports = [];
      re_import_statement.lastIndex = 0;
      while (true) {
        let match = re_import_statement.exec(module3.content);
        if (!match)
          break;
        module3.preParsedImports.push(match[1]);
      }
    }
    var re_preparse_type = /\s*(class|struct|namespace|enum)\s+([A-Za-z0-9_]+)(\s*:\s*([A-Za-z0-9_]+))?\s*\{/g;
    var re_preparse_function = /(\n|^)[ \t]*((mixin|delegate|event)[ \t]+)?((const[ \t]+)?([A-Za-z_0-9]+(\<[A-Za-z0-9_]+(,\s*[A-Za-z0-9_]+)*\>)?)([ \t]*&)?)[\t ]+([A-Za-z0-9_]+)\(((.|\n|\r)*?)\)/g;
    function PreParseTypes(module3) {
      module3.preParsedIdentifiers = [];
      re_preparse_type.lastIndex = 0;
      while (true) {
        let match = re_preparse_type.exec(module3.content);
        if (!match)
          break;
        let identifier = match[2];
        module3.preParsedIdentifiers.push(identifier);
        let list = PreParsedIdentifiersInModules.get(identifier);
        if (!list) {
          list = /* @__PURE__ */ new Set();
          PreParsedIdentifiersInModules.set(identifier, list);
        }
        list.add(module3);
      }
      re_preparse_function.lastIndex = 0;
      while (true) {
        let match = re_preparse_function.exec(module3.content);
        if (!match)
          break;
        let identifier = match[10];
        module3.preParsedIdentifiers.push(identifier);
        let list = PreParsedIdentifiersInModules.get(identifier);
        if (!list) {
          list = /* @__PURE__ */ new Set();
          PreParsedIdentifiersInModules.set(identifier, list);
        }
        list.add(module3);
      }
    }
    function GetModulesPotentiallyImportingSymbol(asmodule, findSymbol) {
      switch (findSymbol.type) {
        case ASSymbolType.Typename:
        case ASSymbolType.TemplateBaseType:
          {
            let dbtype = typedb2.GetTypeByName(findSymbol.symbol_name);
            if (dbtype) {
              if (dbtype.declaredModule)
                return GetModulesPotentiallyImporting(dbtype.declaredModule);
              else
                return GetAllLoadedModules();
            }
          }
          break;
        case ASSymbolType.Namespace:
          {
            let dbnamespace = typedb2.LookupNamespace(null, findSymbol.symbol_name);
            if (dbnamespace)
              return GetModulesPotentiallyImportingNamespace(dbnamespace);
          }
          break;
        case ASSymbolType.GlobalFunction:
        case ASSymbolType.GlobalAccessor:
        case ASSymbolType.GlobalVariable:
          {
            let dbnamespace = typedb2.LookupNamespace(null, findSymbol.container_type);
            if (dbnamespace)
              return GetModulesPotentiallyImportingNamespace(dbnamespace);
          }
          break;
        case ASSymbolType.MemberFunction:
        case ASSymbolType.MemberAccessor:
        case ASSymbolType.MemberVariable:
          {
            let dbtype = typedb2.GetTypeByName(findSymbol.container_type);
            if (dbtype) {
              if (dbtype.declaredModule)
                return GetModulesPotentiallyImporting(dbtype.declaredModule);
              else
                return GetAllLoadedModules();
            }
          }
          break;
        case ASSymbolType.Parameter:
        case ASSymbolType.LocalVariable:
          return [asmodule];
          break;
        case ASSymbolType.UnknownError:
        case ASSymbolType.NoSymbol:
          return [];
          break;
      }
      return GetAllLoadedModules();
    }
    exports2.GetModulesPotentiallyImportingSymbol = GetModulesPotentiallyImportingSymbol;
    function GetModulesPotentiallyImporting(findModule) {
      let markedModules = /* @__PURE__ */ new Set();
      markedModules.add(findModule);
      RecursiveMarkDependentModules(markedModules);
      let modules = new Array();
      for (let markedName of markedModules)
        modules.push(GetModule(markedName));
      return modules;
    }
    exports2.GetModulesPotentiallyImporting = GetModulesPotentiallyImporting;
    function GetModulesPotentiallyImportingMultiple(findModules) {
      let markedModules = /* @__PURE__ */ new Set();
      for (let module3 of findModules)
        markedModules.add(module3);
      RecursiveMarkDependentModules(markedModules);
      let modules = new Array();
      for (let markedName of markedModules)
        modules.push(GetModule(markedName));
      return modules;
    }
    exports2.GetModulesPotentiallyImportingMultiple = GetModulesPotentiallyImportingMultiple;
    function GetModulesPotentiallyImportingNamespace(namespace) {
      let allDeclaredModules = [];
      for (let decl of namespace.declarations) {
        if (!decl.declaredModule)
          return GetAllLoadedModules();
        allDeclaredModules.push(decl.declaredModule);
      }
      return GetModulesPotentiallyImportingMultiple(allDeclaredModules);
    }
    exports2.GetModulesPotentiallyImportingNamespace = GetModulesPotentiallyImportingNamespace;
    function RecursiveMarkDependentModules(markedModules) {
      let anyMarked = true;
      while (anyMarked) {
        anyMarked = false;
        for (let module3 of exports2.ModuleDatabase.values()) {
          if (markedModules.has(module3.modulename))
            continue;
          let isPotentialUser = false;
          if (ScriptSettings.automaticImports) {
            if (module3.resolved) {
              for (let dependency of module3.moduleDependencies) {
                if (markedModules.has(dependency.modulename)) {
                  isPotentialUser = true;
                  break;
                }
              }
            } else {
              isPotentialUser = true;
            }
          } else {
            if (module3.parsed) {
              for (let parsedImport of module3.importedModules) {
                if (markedModules.has(parsedImport.modulename)) {
                  isPotentialUser = true;
                  break;
                }
              }
            } else if (module3.preParsedImports) {
              for (let foundImport of module3.preParsedImports) {
                if (markedModules.has(foundImport)) {
                  isPotentialUser = true;
                  break;
                }
              }
            }
          }
          if (isPotentialUser) {
            markedModules.add(module3.modulename);
            anyMarked = true;
          }
        }
      }
    }
    exports2.RecursiveMarkDependentModules = RecursiveMarkDependentModules;
    function ClearModule(module3) {
      if (module3.parsed) {
        for (let ns of module3.namespaces)
          typedb2.RemoveNamespaceDeclaration(ns, module3.modulename);
        for (let sym of module3.globalSymbols)
          sym.namespace.removeSymbol(sym);
        for (let type of module3.types)
          typedb2.RemoveTypeFromDatabase(type);
        for (let asset of module3.literalAssets)
          exports2.ScriptLiteralAssetsByName.delete(asset.name);
      }
      module3.loaded = false;
      module3.parsed = false;
      module3.semanticSymbols = [];
      module3.types = [];
      module3.delegateBinds = [];
      module3.literalAssets = [];
      module3.annotatedFunctionCalls = [];
      module3.namespaces = [];
      module3.globalSymbols = [];
      module3.resolved = false;
      module3.typesPostProcessed = false;
      module3.rootscope = null;
      module3.textDocument = null;
      module3.content = null;
      module3.importedModules = [];
      module3.flatImportList.clear();
      module3.preParsedImports = [];
      module3.cachedStatements = module3.rawStatements;
      module3.rawStatements = [];
      module3.loadedFromCacheCount = 0;
      module3.parsedStatementCount = 0;
      module3.moduleDependencies.clear();
      for (let identifier of module3.preParsedIdentifiers) {
        let list = PreParsedIdentifiersInModules.get(identifier);
        if (list)
          list.delete(module3);
      }
      module3.preParsedIdentifiers = [];
    }
    function GetSymbolLocation(modulename, typename, symbolname) {
      let asmodule = GetModule(modulename);
      if (!asmodule)
        return null;
      if (!typename)
        return _GetScopeSymbol(asmodule, asmodule.rootscope, symbolname);
      if (typename.startsWith("__"))
        typename = typename.substring(2);
      return RecursiveFindScopeSymbol(asmodule, asmodule.rootscope, typename, symbolname);
    }
    exports2.GetSymbolLocation = GetSymbolLocation;
    function GetSymbolLocationInScope(scope, symbolname) {
      let checkScope = scope;
      while (checkScope) {
        let sym = _GetScopeSymbol(scope.module, checkScope, symbolname);
        if (sym)
          return sym;
        checkScope = checkScope.parentscope;
      }
      return null;
    }
    exports2.GetSymbolLocationInScope = GetSymbolLocationInScope;
    function RecursiveFindScopeSymbol(file, scope, typename, symbolname) {
      for (let subscope of scope.scopes) {
        let scopeType = subscope.getDatabaseType();
        if (!scopeType)
          continue;
        if (scopeType.name == typename) {
          let symbolLocation = _GetScopeSymbol(file, subscope, symbolname);
          if (symbolLocation)
            return symbolLocation;
        }
        let subLocation = RecursiveFindScopeSymbol(file, subscope, typename, symbolname);
        if (subLocation)
          return subLocation;
      }
      return null;
    }
    function _GetScopeSymbol(asmodule, scope, symbolname) {
      for (let scopevar of scope.variables) {
        if (scopevar.name != symbolname)
          continue;
        return asmodule.getLocation(scopevar.start_offset_name);
      }
      for (let innerscope of scope.scopes) {
        if (innerscope.scopetype != ASScopeType.Function)
          continue;
        let func = innerscope.getDatabaseFunction();
        if (!func)
          continue;
        if (func.name != symbolname)
          continue;
        return asmodule.getLocation(func.moduleOffset);
      }
      for (let innerscope of scope.scopes) {
        if (innerscope.scopetype != ASScopeType.Function)
          continue;
        let func = innerscope.getDatabaseFunction();
        if (!func)
          continue;
        if (func.name != "Get" + symbolname && func.name != "Set" + symbolname)
          continue;
        return asmodule.getLocation(func.moduleOffset);
      }
      return null;
    }
    function GetTypeSymbolLocation(modulename, typename) {
      let asmodule = GetModule(modulename);
      if (!asmodule)
        return null;
      let subscope = asmodule.rootscope.findScopeForType(typename);
      if (!subscope)
        return null;
      let dbtype = subscope.getDatabaseType();
      return asmodule.getLocation(dbtype.moduleOffset);
    }
    exports2.GetTypeSymbolLocation = GetTypeSymbolLocation;
    function AddDBType(scope, typename, addToDatabase = true) {
      let dbtype = new typedb2.DBType();
      dbtype.name = typename;
      dbtype.supertype = null;
      dbtype.declaredModule = scope.module.modulename;
      dbtype.documentation = null;
      dbtype.isStruct = false;
      dbtype.isEnum = false;
      if (addToDatabase)
        typedb2.AddTypeToDatabase(scope.getNamespace(), dbtype);
      return dbtype;
    }
    function AddDBMethod(scope, funcname) {
      let dbfunc = new typedb2.DBMethod();
      dbfunc.name = funcname;
      dbfunc.returnType = null;
      dbfunc.argumentStr = null;
      dbfunc.args = new Array();
      dbfunc.declaredModule = scope.module.modulename;
      dbfunc.documentation = null;
      dbfunc.isPrivate = false;
      dbfunc.isProtected = false;
      dbfunc.isConstructor = false;
      dbfunc.isConst = false;
      dbfunc.isProperty = false;
      dbfunc.isBlueprintEvent = false;
      return dbfunc;
    }
    function AddParametersToFunction(scope, statement, dbfunc, params) {
      if (!params || params.length == 0) {
        dbfunc.argumentStr = "";
        return;
      }
      dbfunc.argumentStr = statement.content.substring(params[0].start, params[params.length - 1].end);
      for (let param of params) {
        let asvar = new ASVariable();
        asvar.name = param.name ? param.name.value : null;
        asvar.typename = GetQualifiedTypename(param.typename);
        asvar.node_expression = param.expression;
        asvar.node_typename = param.typename;
        asvar.isArgument = true;
        asvar.in_statement = true;
        asvar.start_offset_type = statement.start_offset + param.typename.start;
        asvar.end_offset_type = statement.start_offset + param.typename.end;
        if (param.name) {
          asvar.start_offset_name = statement.start_offset + param.name.start;
          asvar.end_offset_name = statement.start_offset + param.name.end;
        }
        if (param.expression) {
          asvar.start_offset_expression = statement.start_offset + param.expression.start;
          asvar.end_offset_expression = statement.start_offset + param.expression.end;
        }
        if (asvar.name) {
          scope.variables.push(asvar);
          scope.variablesByName.set(asvar.name, asvar);
        }
        let dbarg = new typedb2.DBArg();
        dbarg.typename = asvar.typename;
        dbarg.name = asvar.name ? asvar.name : "";
        dbfunc.args.push(dbarg);
      }
    }
    function GetQualifiedTypename(typename) {
      let strtype;
      if (typename.const_qualifier)
        strtype = typename.const_qualifier.value + " " + typename.value;
      else
        strtype = typename.value;
      if (typename.ref_qualifier)
        strtype += typename.ref_qualifier;
      return strtype;
    }
    function CopyQualifiersToTypename(qualifiers_from, typename) {
      let strtype;
      if (qualifiers_from.const_qualifier)
        strtype = qualifiers_from.const_qualifier.value + " " + typename;
      else
        strtype = typename;
      if (qualifiers_from.ref_qualifier)
        strtype += qualifiers_from.ref_qualifier;
      return strtype;
    }
    function MakeMacroSpecifiers(macro, macroSpecifiers, macroMeta) {
      if (!macro.children)
        return;
      for (let macroEntry of macro.children) {
        if (macroEntry.name) {
          if (macroEntry.value) {
            macroSpecifiers.set(macroEntry.name.value, macroEntry.value.value);
          } else if (macroEntry.children && macroEntry.name.value.toLowerCase() == "meta") {
            for (let metaEntry of macroEntry.children) {
              if (!metaEntry.name)
                continue;
              if (metaEntry.value)
                macroMeta.set(metaEntry.name.value.toLowerCase(), metaEntry.value.value);
              else
                macroMeta.set(metaEntry.name.value.toLowerCase(), "");
            }
          } else {
            macroSpecifiers.set(macroEntry.name.value, "");
          }
        }
      }
    }
    function AddVarDeclToScope(scope, statement, vardecl, in_statement = false) {
      if (!vardecl.name)
        return null;
      let maybeWrong = false;
      if (scope.module.isEditingNode(statement, vardecl.typename) || scope.module.isEditingNode(statement, vardecl.name)) {
        if (!vardecl.name)
          return null;
        let afterName = statement.start_offset + vardecl.name.end;
        if (afterName >= scope.module.content.length || scope.module.content[afterName] != ";")
          maybeWrong = true;
      }
      let asvar = new ASVariable();
      asvar.name = vardecl.name.value;
      asvar.typename = GetQualifiedTypename(vardecl.typename);
      asvar.node_expression = vardecl.expression;
      asvar.node_typename = vardecl.typename;
      asvar.isAuto = vardecl.typename.value == "auto";
      asvar.in_statement = in_statement;
      asvar.potentiallyWrong = maybeWrong;
      if (vardecl.documentation)
        asvar.documentation = typedb2.FormatDocumentationComment(vardecl.documentation);
      asvar.start_offset_type = statement.start_offset + vardecl.typename.start;
      asvar.end_offset_type = statement.start_offset + vardecl.typename.end;
      asvar.start_offset_name = statement.start_offset + vardecl.name.start;
      asvar.end_offset_name = statement.start_offset + vardecl.name.end;
      if (vardecl.expression) {
        asvar.start_offset_expression = statement.start_offset + vardecl.expression.start;
        asvar.end_offset_expression = statement.start_offset + vardecl.expression.end;
      }
      if (vardecl.access) {
        if (vardecl.access.value == "private")
          asvar.isPrivate = true;
        else if (vardecl.access.value == "protected")
          asvar.isProtected = true;
        else if (scope.dbtype)
          asvar.accessSpecifier = scope.dbtype.getAccessSpecifier(vardecl.access.value);
      }
      scope.variables.push(asvar);
      scope.variablesByName.set(asvar.name, asvar);
      if (scope.dbtype || scope.isNamespaceOrGlobalScope()) {
        if (scope.isNamespaceOrGlobalScope())
          asvar.isGlobal = true;
        else
          asvar.isMember = true;
        let dbprop = new typedb2.DBProperty();
        dbprop.name = asvar.name;
        dbprop.typename = asvar.typename;
        dbprop.documentation = asvar.documentation;
        dbprop.declaredModule = scope.module.modulename;
        dbprop.moduleOffset = asvar.start_offset_name;
        dbprop.moduleOffsetEnd = asvar.end_offset_name;
        dbprop.isPrivate = asvar.isPrivate;
        dbprop.isProtected = asvar.isProtected;
        dbprop.accessSpecifier = asvar.accessSpecifier;
        if (vardecl.macro) {
          dbprop.isUProperty = true;
          dbprop.macroSpecifiers = /* @__PURE__ */ new Map();
          dbprop.macroMeta = /* @__PURE__ */ new Map();
          MakeMacroSpecifiers(vardecl.macro, dbprop.macroSpecifiers, dbprop.macroMeta);
          let keywords = dbprop.macroMeta.get("scriptkeywords");
          if (keywords)
            dbprop.keywords = keywords.split(" ");
        }
        if (scope.dbtype) {
          scope.dbtype.addSymbol(dbprop);
        } else {
          let namespace = scope.getNamespace();
          namespace.addSymbol(dbprop);
          if (vardecl.type == exports2.node_types.AssetDefinition)
            dbprop.isLiteralAsset = true;
          scope.module.globalSymbols.push(dbprop);
        }
      }
      return asvar;
    }
    function ExtendScopeToStatement(scope, statement) {
      scope.start_offset = statement.start_offset;
    }
    function GenerateTypeInformation(scope) {
      scope.resolvedNamespace = scope.parentscope ? scope.parentscope.resolvedNamespace : typedb2.GetRootNamespace();
      if (scope.previous && scope.previous instanceof ASStatement && scope.previous.ast) {
        if (scope.previous.ast.type == exports2.node_types.ClassDefinition) {
          scope.declaration = scope.previous;
          let classdef = scope.previous.ast;
          let dbtype = AddDBType(scope, classdef.name.value);
          dbtype.supertype = classdef.superclass ? classdef.superclass.value : "UObject";
          if (classdef.documentation)
            dbtype.documentation = typedb2.FormatDocumentationComment(classdef.documentation);
          dbtype.moduleOffset = scope.previous.start_offset + classdef.name.start;
          dbtype.moduleOffsetEnd = scope.previous.start_offset + classdef.name.end;
          scope.module.types.push(dbtype);
          scope.dbtype = dbtype;
          if (classdef.macro) {
            dbtype.macroSpecifiers = /* @__PURE__ */ new Map();
            dbtype.macroMeta = /* @__PURE__ */ new Map();
            MakeMacroSpecifiers(classdef.macro, dbtype.macroSpecifiers, dbtype.macroMeta);
            let keywords = dbtype.macroMeta.get("scriptkeywords");
            if (keywords)
              dbtype.keywords = keywords.split(" ");
          }
          ExtendScopeToStatement(scope, scope.previous);
          dbtype.moduleScopeStart = scope.start_offset;
          dbtype.moduleScopeEnd = scope.end_offset;
        } else if (scope.previous.ast.type == exports2.node_types.StructDefinition) {
          scope.declaration = scope.previous;
          let structdef = scope.previous.ast;
          let dbtype = AddDBType(scope, structdef.name.value);
          if (structdef.documentation)
            dbtype.documentation = typedb2.FormatDocumentationComment(structdef.documentation);
          dbtype.moduleOffset = scope.previous.start_offset + structdef.name.start;
          dbtype.moduleOffsetEnd = scope.previous.start_offset + structdef.name.end;
          dbtype.isStruct = true;
          scope.module.types.push(dbtype);
          scope.dbtype = dbtype;
          if (structdef.macro) {
            dbtype.macroSpecifiers = /* @__PURE__ */ new Map();
            dbtype.macroMeta = /* @__PURE__ */ new Map();
            MakeMacroSpecifiers(structdef.macro, dbtype.macroSpecifiers, dbtype.macroMeta);
            let keywords = dbtype.macroMeta.get("scriptkeywords");
            if (keywords)
              dbtype.keywords = keywords.split(" ");
          }
          ExtendScopeToStatement(scope, scope.previous);
          dbtype.moduleScopeStart = scope.start_offset;
          dbtype.moduleScopeEnd = scope.end_offset;
        } else if (scope.previous.ast.type == exports2.node_types.NamespaceDefinition) {
          scope.declaration = scope.previous;
          let parentNamespace = typedb2.GetRootNamespace();
          if (scope.parentscope)
            parentNamespace = scope.parentscope.getNamespace();
          let nsdef = scope.previous.ast;
          let decl = new typedb2.DBNamespaceDeclaration();
          decl.declaredModule = scope.module.modulename;
          decl.declaredOffset = scope.previous.start_offset + nsdef.name.start;
          decl.declaredOffsetEnd = scope.previous.start_offset + nsdef.name.end;
          decl.scopeOffsetStart = scope.start_offset;
          decl.scopeOffsetEnd = scope.end_offset;
          decl.isNestedParent = false;
          let identifier = nsdef.name.value;
          let namespaceIndex = identifier.indexOf("::");
          if (namespaceIndex != -1) {
            let parts = identifier.split("::");
            identifier = parts[parts.length - 1];
            for (let i = 0, count = parts.length - 1; i < count; ++i) {
              let parentDecl = new typedb2.DBNamespaceDeclaration();
              parentDecl.declaredModule = scope.module.modulename;
              parentDecl.declaredOffset = scope.previous.start_offset + nsdef.name.start;
              parentDecl.declaredOffsetEnd = scope.previous.start_offset + nsdef.name.end;
              parentDecl.scopeOffsetStart = scope.start_offset;
              parentDecl.scopeOffsetEnd = scope.end_offset;
              parentDecl.isNestedParent = true;
              parentNamespace = typedb2.DeclareNamespace(parentNamespace, parts[i], parentDecl);
              scope.module.namespaces.push(parentNamespace);
            }
          }
          scope.dbnamespace = typedb2.DeclareNamespace(parentNamespace, identifier, decl);
          scope.resolvedNamespace = scope.dbnamespace;
          if (nsdef.documentation)
            scope.dbnamespace.documentation = typedb2.FormatDocumentationComment(nsdef.documentation);
          scope.module.namespaces.push(scope.dbnamespace);
          ExtendScopeToStatement(scope, scope.previous);
        } else if (scope.previous.ast.type == exports2.node_types.EnumDefinition) {
          scope.declaration = scope.previous;
          let enumdef = scope.previous.ast;
          let dbtype = AddDBType(scope, enumdef.name.value);
          dbtype.isEnum = true;
          if (enumdef.documentation)
            dbtype.documentation = typedb2.FormatDocumentationComment(enumdef.documentation);
          dbtype.moduleOffset = scope.previous.start_offset + enumdef.name.start;
          dbtype.moduleOffsetEnd = scope.previous.start_offset + enumdef.name.end;
          scope.module.types.push(dbtype);
          scope.dbtype = dbtype;
          ExtendScopeToStatement(scope, scope.previous);
          dbtype.moduleScopeStart = scope.start_offset;
          dbtype.moduleScopeEnd = scope.end_offset;
        } else if (scope.previous.ast.type == exports2.node_types.FunctionDecl) {
          scope.declaration = scope.previous;
          let funcdef = scope.previous.ast;
          let dbfunc = AddDBMethod(scope, funcdef.name.value);
          if (funcdef.documentation)
            dbfunc.documentation = typedb2.FormatDocumentationComment(funcdef.documentation);
          dbfunc.moduleOffset = scope.previous.start_offset + funcdef.name.start;
          dbfunc.moduleOffsetEnd = scope.previous.start_offset + funcdef.name.end;
          if (funcdef.returntype)
            dbfunc.returnType = GetQualifiedTypename(funcdef.returntype);
          else
            dbfunc.returnType = "void";
          AddParametersToFunction(scope, scope.previous, dbfunc, funcdef.parameters);
          if (funcdef.macro) {
            dbfunc.isUFunction = true;
            dbfunc.macroSpecifiers = /* @__PURE__ */ new Map();
            dbfunc.macroMeta = /* @__PURE__ */ new Map();
            MakeMacroSpecifiers(funcdef.macro, dbfunc.macroSpecifiers, dbfunc.macroMeta);
            if (dbfunc.macroSpecifiers.has("BlueprintOverride")) {
              dbfunc.isBlueprintEvent = true;
              dbfunc.isBlueprintOverride = true;
            } else if (dbfunc.macroSpecifiers.has("BlueprintEvent")) {
              dbfunc.isBlueprintEvent = true;
            }
            let keywords = dbfunc.macroMeta.get("scriptkeywords");
            if (keywords)
              dbfunc.keywords = keywords.split(" ");
            dbfunc.cacheDelegateMeta();
          }
          if (funcdef.access) {
            if (funcdef.access.value == "protected")
              dbfunc.isProtected = true;
            else if (funcdef.access.value == "private")
              dbfunc.isPrivate = true;
            else if (scope.parentscope.dbtype)
              dbfunc.accessSpecifier = scope.parentscope.dbtype.getAccessSpecifier(funcdef.access.value);
          }
          if (funcdef.qualifiers) {
            for (let qual of funcdef.qualifiers) {
              if (qual == "property")
                dbfunc.isProperty = true;
              else if (qual == "const")
                dbfunc.isConst = true;
              else if (qual == "final")
                dbfunc.isFinal = true;
              else if (qual == "override")
                dbfunc.isOverride = true;
            }
          }
          if (funcdef.scoping) {
            if (funcdef.scoping == "mixin")
              dbfunc.isMixin = true;
            else if (funcdef.scoping == "local")
              dbfunc.isLocal = true;
          }
          if (scope.scopes.length != 0) {
            dbfunc.isEmpty = false;
          } else {
            dbfunc.isEmpty = true;
            for (let statement of scope.statements) {
              if (statement.ast) {
                dbfunc.isEmpty = false;
                break;
              }
            }
          }
          scope.dbfunc = dbfunc;
          if (scope.parentscope && scope.parentscope.dbtype) {
            scope.parentscope.dbtype.addSymbol(dbfunc);
          } else {
            let namespace = typedb2.GetRootNamespace();
            if (scope.parentscope)
              namespace = scope.parentscope.getNamespace();
            scope.module.globalSymbols.push(dbfunc);
            namespace.addSymbol(dbfunc);
          }
          ExtendScopeToStatement(scope, scope.previous);
          dbfunc.moduleScopeStart = scope.previous.start_offset + funcdef.name.start;
          dbfunc.moduleScopeEnd = scope.end_offset;
        } else if (scope.previous.ast.type == exports2.node_types.ConstructorDecl) {
          scope.declaration = scope.previous;
          let constrdef = scope.previous.ast;
          let dbfunc = AddDBMethod(scope, constrdef.name.value);
          AddParametersToFunction(scope, scope.previous, dbfunc, constrdef.parameters);
          dbfunc.moduleOffset = scope.previous.start_offset + constrdef.name.start;
          dbfunc.moduleOffsetEnd = scope.previous.start_offset + constrdef.name.end;
          dbfunc.isConstructor = true;
          scope.dbfunc = dbfunc;
          if (scope.parentscope) {
            let namespace = scope.parentscope.getNamespace();
            dbfunc.documentation = scope.parentscope.dbtype.documentation;
            dbfunc.returnType = scope.parentscope.dbtype.name;
            scope.module.globalSymbols.push(dbfunc);
            namespace.addSymbol(dbfunc);
          }
          ExtendScopeToStatement(scope, scope.previous);
          dbfunc.moduleScopeStart = scope.previous.start_offset + constrdef.name.start;
          dbfunc.moduleScopeEnd = scope.end_offset;
        } else if (scope.previous.ast.type == exports2.node_types.DestructorDecl) {
          scope.declaration = scope.previous;
          let destrdef = scope.previous.ast;
          let dbfunc = AddDBMethod(scope, destrdef.name.value);
          dbfunc.moduleOffset = scope.previous.start_offset + destrdef.name.start;
          dbfunc.moduleOffsetEnd = scope.previous.start_offset + destrdef.name.end;
          dbfunc.moduleScopeStart = scope.previous.start_offset + destrdef.name.start;
          dbfunc.moduleScopeEnd = scope.end_offset;
          scope.dbfunc = dbfunc;
          if (scope.parentscope && scope.parentscope.dbtype) {
            scope.parentscope.dbtype.addSymbol(dbfunc);
          }
        } else if (scope.previous.ast.type == exports2.node_types.AssetDefinition) {
          scope.assettype = scope.previous.ast.typename.value;
          if (scope.previous.ast.name) {
            let asset = new ASLiteralAsset();
            asset.name = scope.previous.ast.name.value;
            asset.type = scope.assettype;
            asset.content_scope = scope;
            asset.module = scope.module;
            asset.statement = scope.previous;
            asset.module.literalAssets.push(asset);
            exports2.ScriptLiteralAssetsByName.set(asset.name, asset);
          }
        }
      }
      for (let i = 0; i < scope.statements.length; ++i) {
        let statement = scope.statements[i];
        if (!statement)
          continue;
        if (!statement.ast)
          continue;
        switch (statement.ast.type) {
          case exports2.node_types.ImportStatement:
            {
              if (statement.ast.children[0]) {
                let importedModule = GetModule(statement.ast.children[0].value);
                scope.module.importedModules.push(importedModule);
              }
            }
            break;
          case exports2.node_types.VariableDecl:
            {
              AddVarDeclToScope(scope, statement, statement.ast);
            }
            break;
          case exports2.node_types.VariableDeclMulti:
            {
              for (let child of statement.ast.children)
                AddVarDeclToScope(scope, statement, child);
            }
            break;
          case exports2.node_types.ForLoop:
            {
              if (!statement.generatedTypes) {
                let subscope = MoveStatementToSubScope(scope, statement, statement.ast.children[3], true);
                if (statement.ast.children[0]) {
                  if (statement.ast.children[0].type == exports2.node_types.VariableDecl) {
                    let loopVar = AddVarDeclToScope(subscope, statement, statement.ast.children[0], true);
                    if (loopVar)
                      loopVar.isLoopVariable = true;
                  } else if (statement.ast.children[0].type == exports2.node_types.VariableDeclMulti) {
                    for (let child of statement.ast.children[0].children) {
                      let loopVar = AddVarDeclToScope(subscope, statement, child, true);
                      if (loopVar)
                        loopVar.isLoopVariable = true;
                    }
                  }
                }
                scope.statements[i] = null;
              }
            }
            break;
          case exports2.node_types.ForEachLoop:
            {
              if (!statement.generatedTypes) {
                let subscope = MoveStatementToSubScope(scope, statement, statement.ast.children[3], true);
                AddForEachVariableToScope(subscope, statement, statement.ast);
                scope.statements[i] = null;
              }
            }
            break;
          case exports2.node_types.IfStatement:
          case exports2.node_types.ElseStatement:
          case exports2.node_types.WhileLoop:
          case exports2.node_types.CaseStatement:
          case exports2.node_types.DefaultCaseStatement:
            {
              if (!statement.generatedTypes && statement.ast.children[statement.ast.children.length - 1]) {
                MoveStatementToSubScope(scope, statement, statement.ast.children[statement.ast.children.length - 1], false);
              }
            }
            break;
          case exports2.node_types.EventDecl:
          case exports2.node_types.DelegateDecl:
            {
              let signature = statement.ast.children[0];
              if (signature) {
                let dbtype = AddDBType(scope, signature.name.value);
                dbtype.isStruct = true;
                if (statement.ast.type == exports2.node_types.EventDecl)
                  dbtype.isEvent = true;
                else
                  dbtype.isDelegate = true;
                if (statement.ast.documentation)
                  dbtype.documentation = typedb2.FormatDocumentationComment(statement.ast.documentation);
                dbtype.moduleOffset = statement.start_offset + signature.name.start;
                dbtype.moduleOffsetEnd = statement.start_offset + signature.name.end;
                dbtype.delegateReturn = signature.returntype ? GetQualifiedTypename(signature.returntype) : "void";
                dbtype.delegateArgs = [];
                if (signature.parameters) {
                  for (let param of signature.parameters) {
                    let dbarg = new typedb2.DBArg();
                    dbarg.typename = GetQualifiedTypename(param.typename);
                    dbarg.name = param.name ? param.name.value : "";
                    dbtype.delegateArgs.push(dbarg);
                  }
                }
                scope.module.types.push(dbtype);
              }
            }
            break;
          case exports2.node_types.ImportFunctionStatement:
            {
              let funcdef = statement.ast.children[0];
              let dbfunc = AddDBMethod(scope, funcdef.name.value);
              if (funcdef.documentation)
                dbfunc.documentation = typedb2.FormatDocumentationComment(funcdef.documentation);
              dbfunc.moduleOffset = statement.start_offset + funcdef.name.start;
              dbfunc.moduleOffsetEnd = statement.start_offset + funcdef.name.end;
              if (funcdef.returntype)
                dbfunc.returnType = GetQualifiedTypename(funcdef.returntype);
              else
                dbfunc.returnType = "void";
              AddParametersToFunction(scope, statement, dbfunc, funcdef.parameters);
              let namespace = scope.getNamespace();
              scope.module.globalSymbols.push(dbfunc);
              namespace.addSymbol(dbfunc);
            }
            break;
          case exports2.node_types.AssetDefinition:
            {
              AddVarDeclToScope(scope, statement, statement.ast);
            }
            break;
          case exports2.node_types.EnumValueList:
            {
              if (scope.dbtype) {
                for (let enumValue of statement.ast.children) {
                  if (!enumValue)
                    continue;
                  let dbprop = new typedb2.DBProperty();
                  dbprop.name = enumValue.name.value;
                  dbprop.typename = scope.dbtype.name;
                  if (enumValue.documentation)
                    dbprop.documentation = typedb2.FormatDocumentationComment(enumValue.documentation);
                  dbprop.declaredModule = scope.module.modulename;
                  dbprop.moduleOffset = statement.start_offset + enumValue.name.start;
                  dbprop.moduleOffsetEnd = statement.start_offset + enumValue.name.end;
                  scope.dbtype.addSymbol(dbprop);
                }
              }
            }
            break;
          case exports2.node_types.AccessDeclaration:
            {
              AddAccessSpecifierToType(scope, statement, statement.ast);
            }
            break;
        }
        statement.generatedTypes = true;
      }
      for (let subscope of scope.scopes)
        GenerateTypeInformation(subscope);
      if (scope.scopetype == ASScopeType.Class && scope.dbtype && scope.dbtype.isStruct) {
        let namespace = scope.getNamespace();
        let hasDefaultConstructor = false;
        let constructors = namespace.findSymbols(scope.dbtype.name);
        for (let constr of constructors) {
          if (constr instanceof typedb2.DBMethod) {
            if (constr.args.length == 0 && constr.returnType == scope.dbtype.name) {
              hasDefaultConstructor = true;
              break;
            }
          }
        }
        if (!hasDefaultConstructor) {
          let dbfunc = AddDBMethod(scope, scope.dbtype.name);
          dbfunc.moduleOffset = scope.start_offset;
          dbfunc.moduleOffsetEnd = scope.end_offset;
          dbfunc.isConstructor = true;
          dbfunc.documentation = scope.dbtype.documentation;
          dbfunc.returnType = scope.dbtype.name;
          namespace.addSymbol(dbfunc);
          scope.module.globalSymbols.push(dbfunc);
        }
      }
    }
    function AddAccessSpecifierToType(scope, statement, node) {
      if (!scope.dbtype)
        return;
      let spec = scope.dbtype.getAccessSpecifier(node.name.value);
      spec.isDeclared = true;
      spec.declaredModule = scope.module.modulename;
      spec.moduleOffset = statement.start_offset + node.name.start;
      spec.moduleOffsetEnd = statement.start_offset + node.name.end;
      if (node.classList) {
        for (let accessClass of node.classList) {
          if (accessClass.className.value == "*") {
            if (accessClass.mods) {
              for (let mod of accessClass.mods) {
                if (mod.value == "editdefaults")
                  spec.bAnyEditDefaults = true;
                else if (mod.value == "readonly")
                  spec.bAnyReadOnly = true;
              }
            }
          } else if (accessClass.className.value == "private") {
            spec.isPrivate = true;
          } else if (accessClass.className.value == "protected") {
            spec.isProtected = true;
          } else {
            let cls = new typedb2.DBAccessPermission();
            cls.accessName = accessClass.className.value;
            if (accessClass.mods) {
              for (let mod of accessClass.mods) {
                if (mod.value == "editdefaults")
                  cls.bEditDefaults = true;
                else if (mod.value == "readonly")
                  cls.bReadOnly = true;
                else if (mod.value == "inherited")
                  cls.bInherited = true;
              }
            }
            if (spec.permissions)
              spec.permissions.push(cls);
            else
              spec.permissions = [cls];
          }
        }
      }
    }
    function MoveStatementToSubScope(scope, statement, optional_statement, move_main_statement) {
      let subscope;
      if (!optional_statement && statement.next && statement.next instanceof ASScope) {
        subscope = statement.next;
        if (move_main_statement)
          subscope.start_offset = statement.start_offset;
      } else {
        subscope = new ASScope();
        subscope.parentscope = scope;
        subscope.module = scope.module;
        subscope.start_offset = statement.start_offset;
        if (!move_main_statement && optional_statement)
          subscope.start_offset += optional_statement.start;
        subscope.end_offset = statement.end_offset;
        subscope.scopetype = ASScopeType.Code;
        subscope.parsed = true;
        scope.scopes.push(subscope);
        subscope.previous = statement;
        subscope.next = statement.next;
        if (statement.next)
          statement.next.previous = subscope;
        statement.next = subscope;
      }
      if (optional_statement) {
        let newStatement = new ASStatement();
        newStatement.ast = optional_statement;
        newStatement.start_offset = statement.start_offset;
        newStatement.end_offset = statement.end_offset;
        newStatement.parsed = true;
        let moveToSubScope = true;
        if (optional_statement.type == exports2.node_types.VariableDecl && scope.module.isEditingInside(statement.start_offset, statement.end_offset)) {
          if (scope.module.lastEditEnd <= statement.start_offset + optional_statement.typename.start)
            moveToSubScope = false;
        }
        if (moveToSubScope) {
          newStatement.next = subscope.element_head;
          if (subscope.element_head)
            subscope.element_head.previous = newStatement;
          subscope.element_head = newStatement;
          subscope.statements.push(newStatement);
        } else {
          newStatement.next = subscope.next;
          newStatement.previous = subscope;
          subscope.next = newStatement;
          scope.statements.push(newStatement);
        }
      }
      if (move_main_statement) {
        let prevStatement = statement.previous;
        let nextStatement = statement.next;
        if (prevStatement)
          prevStatement.next = nextStatement;
        if (nextStatement)
          nextStatement.previous = prevStatement;
        if (scope.element_head == statement)
          scope.element_head = nextStatement;
        statement.previous = null;
        statement.next = subscope.element_head;
        if (subscope.element_head)
          subscope.element_head.previous = statement;
        subscope.element_head = statement;
        subscope.statements.push(statement);
      }
      return subscope;
    }
    function AddForEachVariableToScope(scope, statement, node) {
      if (!node.children[0])
        return;
      if (!node.children[1])
        return;
      let asvar = new ASVariable();
      asvar.name = node.children[1].value;
      asvar.typename = GetQualifiedTypename(node.children[0]);
      asvar.node_typename = node.children[0];
      asvar.node_expression = node.children[2];
      asvar.isAuto = node.children[0].value == "auto";
      asvar.isIterator = true;
      asvar.in_statement = true;
      asvar.start_offset_type = statement.start_offset + node.children[0].start;
      asvar.end_offset_type = statement.start_offset + node.children[0].end;
      asvar.start_offset_name = statement.start_offset + node.children[1].start;
      asvar.end_offset_name = statement.start_offset + node.children[1].end;
      if (node.children[2]) {
        asvar.start_offset_expression = statement.start_offset + node.children[2].start;
        asvar.end_offset_expression = statement.start_offset + node.children[2].end;
      }
      scope.variables.push(asvar);
      scope.variablesByName.set(asvar.name, asvar);
    }
    function AddIdentifierSymbol(scope, statement, node, type, container_type = null, symbol_name = null, isWriteAccess = false) {
      if (!node)
        return null;
      let symbol = new ASSemanticSymbol();
      symbol.type = type;
      symbol.start = node.start + statement.start_offset;
      symbol.end = node.end + statement.start_offset;
      if (container_type instanceof typedb2.DBType)
        symbol.container_type = container_type.name;
      else
        symbol.container_type = container_type;
      symbol.symbol_name = symbol_name;
      symbol.isWriteAccess = isWriteAccess;
      scope.module.semanticSymbols.push(symbol);
      return symbol;
    }
    function AddUnknownSymbol(scope, statement, node, hasPotentialCompletions) {
      if (!node)
        return;
      if (hasPotentialCompletions) {
        if (scope.module.isEditingNode(statement, node))
          return;
      }
      AddIdentifierSymbol(scope, statement, node, ASSymbolType.UnknownError);
    }
    function DoesTypenameExist(scope, name) {
      let dbtype = typedb2.LookupType(scope.getNamespace(), name);
      if (dbtype)
        return dbtype;
      if (name == "auto")
        return true;
      return false;
    }
    function AddTypenameSymbol(scope, statement, node, errorOnUnknown = true) {
      if (!node)
        return null;
      if (node.basetype) {
        let baseSymbol = null;
        if (errorOnUnknown && !DoesTypenameExist(scope, node.basetype.value)) {
          let hasPotentialCompletions = false;
          AddUnknownSymbol(scope, statement, node.basetype, hasPotentialCompletions);
        } else {
          baseSymbol = AddIdentifierSymbol(scope, statement, node.basetype, ASSymbolType.TemplateBaseType, null, node.basetype.value);
        }
        for (let child of node.subtypes)
          AddTypenameSymbol(scope, statement, child, errorOnUnknown);
        return baseSymbol;
      } else {
        let exists = DoesTypenameExist(scope, node.name.value);
        if (errorOnUnknown && !exists) {
          let hasPotentialCompletions = false;
          if (scope.module.isEditingNode(statement, node))
            hasPotentialCompletions = typedb2.HasTypeWithPrefix(scope.getNamespace(), node.name.value);
          AddUnknownSymbol(scope, statement, node.name, hasPotentialCompletions);
          scope.module.markDependencyIdentifier(node.name.value);
          return null;
        } else {
          let namespaceIndex = node.name.value.indexOf("::");
          if (namespaceIndex != -1) {
            let prevNamespaceIndex = 0;
            let lookupNamespace = scope.getNamespace();
            if (namespaceIndex == 0) {
              prevNamespaceIndex = 2;
              namespaceIndex = node.name.value.indexOf("::", prevNamespaceIndex);
              lookupNamespace = null;
            }
            while (namespaceIndex != -1) {
              let symbol = new ASSemanticSymbol();
              symbol.start = node.name.start + statement.start_offset + prevNamespaceIndex;
              symbol.end = node.name.start + statement.start_offset + namespaceIndex;
              let namespace = typedb2.LookupNamespace(lookupNamespace, node.name.value.substring(0, namespaceIndex));
              if (namespace) {
                symbol.type = ASSymbolType.Namespace;
                symbol.container_type = null;
                symbol.symbol_name = namespace.getQualifiedNamespace();
              } else {
                symbol.type = ASSymbolType.UnknownError;
              }
              scope.module.semanticSymbols.push(symbol);
              prevNamespaceIndex = namespaceIndex + 2;
              namespaceIndex = node.name.value.indexOf("::", prevNamespaceIndex);
            }
            {
              let symbol = new ASSemanticSymbol();
              symbol.start = node.name.start + statement.start_offset + prevNamespaceIndex;
              symbol.end = node.name.end + statement.start_offset;
              symbol.type = ASSymbolType.Typename;
              symbol.container_type = null;
              symbol.symbol_name = node.name.value.substring(prevNamespaceIndex);
              scope.module.semanticSymbols.push(symbol);
            }
          } else {
            let addSymbol = AddIdentifierSymbol(scope, statement, node.name, ASSymbolType.Typename, null, node.name.value);
            if (exists instanceof typedb2.DBType) {
              if (exists.isEnum)
                addSymbol.symbol_name = exists.name;
              if (exists.declaredModule && !ScriptSettings.automaticImports && !scope.module.isModuleImported(exists.declaredModule))
                addSymbol.isUnimported = true;
              scope.module.markDependencyType(exists);
            }
            return addSymbol;
          }
        }
      }
    }
    function AddAccessSpecifierSymbol(scope, statement, node, errorOnUnknown = true) {
      if (!node)
        return null;
      if (node.value == "private" || node.value == "protected")
        return null;
      let dbtype = scope.getParentType();
      if (!dbtype)
        return null;
      let spec = dbtype.getAccessSpecifier(node.value, false);
      if (!spec || !spec.isDeclared) {
        if (errorOnUnknown && !scope.module.isEditingNode(statement, node))
          AddUnknownSymbol(scope, statement, node, false);
        return null;
      } else {
        return AddIdentifierSymbol(scope, statement, node, ASSymbolType.AccessSpecifier, dbtype.name, node.value);
      }
    }
    function UpdateAutoTypenameSymbol(symbol, expressionType) {
      if (!symbol)
        return;
      symbol.isAuto = true;
      if (!expressionType)
        return;
      if (expressionType instanceof typedb2.DBType) {
        symbol.container_type = null;
        symbol.symbol_name = expressionType.name;
      } else if (expressionType instanceof typedb2.DBProperty) {
        symbol.container_type = null;
        symbol.symbol_name = expressionType.typename;
      }
    }
    function ResolveAutos(scope) {
      for (let asvar of scope.variables) {
        if (!asvar.isAuto)
          continue;
        if (!asvar.node_expression)
          continue;
        let resolvedType = ResolveTypeFromExpression(scope, asvar.node_expression);
        if (resolvedType && asvar.isIterator)
          resolvedType = ResolveIteratorType(resolvedType);
        if (resolvedType) {
          let typename = resolvedType.getQualifiedTypenameInNamespace(scope.getNamespace());
          asvar.typename = CopyQualifiersToTypename(asvar.node_typename, typename);
        }
      }
      for (let subscope of scope.scopes)
        ResolveAutos(subscope);
    }
    function IsPrimitiveLiteralNode(node) {
      if (!node)
        return false;
      switch (node.type) {
        case exports2.node_types.ConstBool:
        case exports2.node_types.ConstDouble:
        case exports2.node_types.ConstInteger:
        case exports2.node_types.ConstHexInteger:
        case exports2.node_types.ConstOctalInteger:
        case exports2.node_types.ConstBinaryInteger:
        case exports2.node_types.ConstFloat:
          return true;
      }
      return false;
    }
    exports2.IsPrimitiveLiteralNode = IsPrimitiveLiteralNode;
    function ResolveTypeFromExpression(scope, node) {
      if (!node)
        return null;
      switch (node.type) {
        case exports2.node_types.Identifier:
          {
            return ResolveTypeFromIdentifier(scope, node.value);
          }
          break;
        case exports2.node_types.ConstFloat:
          {
            if (ScriptSettings.floatIsFloat64)
              return typedb2.GetTypeByName("float32");
            else
              return typedb2.GetTypeByName("float");
          }
          break;
        case exports2.node_types.ConstDouble: {
          if (ScriptSettings.floatIsFloat64)
            return typedb2.GetTypeByName("float");
          else
            return typedb2.GetTypeByName("double");
        }
        case exports2.node_types.ConstInteger:
        case exports2.node_types.ConstHexInteger:
        case exports2.node_types.ConstOctalInteger:
        case exports2.node_types.ConstBinaryInteger:
          {
            return typedb2.GetTypeByName("int");
          }
          break;
        case exports2.node_types.ConstString:
          {
            return typedb2.GetTypeByName("FString");
          }
          break;
        case exports2.node_types.ConstName:
          {
            return typedb2.GetTypeByName("FName");
          }
          break;
        case exports2.node_types.ConstFormatString:
          {
            return typedb2.GetTypeByName("FString");
          }
          break;
        case exports2.node_types.ConstBool: {
          return typedb2.GetTypeByName("bool");
        }
        case exports2.node_types.This: {
          return scope.getParentType();
        }
        case exports2.node_types.ConstNullptr: {
          return typedb2.GetTypeByName("UObject");
        }
        case exports2.node_types.MemberAccess:
          {
            let left_type = ResolveTypeFromExpression(scope, node.children[0]);
            if (!left_type || !node.children[1])
              return null;
            return ResolvePropertyType(left_type, node.children[1].value);
          }
          break;
        case exports2.node_types.NamespaceAccess:
          {
            if (!node.children[1])
              return null;
            let fullNamespace = CollapseNamespaceFromNode(node.children[0]);
            if (fullNamespace == "Super" && scope.getParentType()) {
              let superType = scope.getParentType().getSuperType();
              if (!superType)
                return null;
              return ResolvePropertyType(superType, node.children[1].value);
            } else {
              let shadowedType = typedb2.LookupType(scope.getNamespace(), fullNamespace);
              if (shadowedType && shadowedType.isEnum)
                return ResolvePropertyType(shadowedType, node.children[1].value);
              let nsSymbol = ResolveNamespacePropertyType(scope.getNamespace(), fullNamespace, node.children[1].value);
              if (nsSymbol)
                return nsSymbol;
              if (shadowedType && scope.getParentType() && scope.getParentType().inheritsFrom(shadowedType.name))
                return ResolvePropertyType(shadowedType, node.children[1].value);
              return null;
            }
          }
          break;
        case exports2.node_types.FunctionCall:
          {
            let left_func = ResolveFunctionFromExpression(scope, node.children[0]);
            if (!left_func) {
              if (node.children[0] && node.children[0].type == exports2.node_types.Identifier) {
                let constrType = typedb2.LookupType(scope.getNamespace(), node.children[0].value);
                if (constrType)
                  return constrType;
              }
              return null;
            }
            if (left_func.determinesOutputTypeArgumentIndex != -1 && node.children[1] && node.children[1].children && node.children[1].children[left_func.determinesOutputTypeArgumentIndex]) {
              let argumentExpr = node.children[1].children[left_func.determinesOutputTypeArgumentIndex];
              let argumentType = ResolveTypeFromExpression(scope, argumentExpr);
              if (argumentType)
                return left_func.applyDeterminesOutputType(left_func.returnType, argumentType);
            }
            return typedb2.LookupType(left_func.namespace, left_func.returnType);
          }
          break;
        case exports2.node_types.ConstructorCall:
          if (!node.children[0] || !node.children[0].value)
            return null;
          return typedb2.LookupType(scope.getNamespace(), node.children[0].value);
          break;
        case exports2.node_types.IndexOperator:
          {
            let left_type = ResolveTypeFromExpression(scope, node.children[0]);
            if (!left_type)
              return null;
            return ResolveTypeFromOperator(scope, left_type, null, "opIndex");
          }
          break;
        case exports2.node_types.CastOperation:
          {
            if (!node.children[0] || !node.children[0].value)
              return null;
            return typedb2.LookupType(scope.getNamespace(), node.children[0].value);
          }
          break;
        case exports2.node_types.BinaryOperation:
          {
            if (!node.operator)
              return null;
            let left_type = ResolveTypeFromExpression(scope, node.children[0]);
            let right_type = ResolveTypeFromExpression(scope, node.children[1]);
            return ResolveTypeFromOperator(scope, left_type, right_type, getBinaryOperatorOverloadMethod(node.operator));
          }
          break;
        case exports2.node_types.UnaryOperation:
          {
            if (!node.operator)
              return null;
            let left_type = ResolveTypeFromExpression(scope, node.children[0]);
            return ResolveTypeFromOperator(scope, left_type, null, getUnaryOperatorOverloadMethod(node.operator));
          }
          break;
        case exports2.node_types.PostfixOperation:
          {
            if (!node.operator)
              return null;
            let left_type = ResolveTypeFromExpression(scope, node.children[0]);
            return ResolveTypeFromOperator(scope, left_type, null, getPostfixOperatorOverloadMethod(node.operator));
          }
          break;
        case exports2.node_types.TernaryOperation:
          {
            let left_type = ResolveTypeFromExpression(scope, node.children[1]);
            let right_type = ResolveTypeFromExpression(scope, node.children[2]);
            if (left_type) {
              if (right_type) {
                if (left_type != right_type && !left_type.isValueType() && !right_type.isValueType()) {
                  let target_type = left_type;
                  while (target_type && !right_type.inheritsFrom(target_type.name))
                    target_type = target_type.getSuperType();
                  if (target_type)
                    return target_type;
                  else
                    return left_type;
                } else {
                  return left_type;
                }
              } else {
                return left_type;
              }
            } else {
              return right_type;
            }
            return null;
          }
          break;
      }
      return null;
    }
    exports2.ResolveTypeFromExpression = ResolveTypeFromExpression;
    function GetOverloadMethodForOperator(operator) {
      switch (operator) {
        case "+":
          return "opAdd";
        case "-":
          return "opSub";
        case "*":
          return "opMul";
        case "/":
          return "opDiv";
        case "%":
          return "opMod";
        case "**":
          return "opPow";
        case "&":
          return "opAnd";
        case "|":
          return "opOr";
        case "^":
          return "opXor";
        case "<<":
          return "opShl";
        case ">>":
          return "opShr";
        case ">>>":
          return "opUShr";
        case "==":
          return "opEquals";
        case "!=":
          return "opEquals";
        case "<":
          return "opCmp";
        case ">":
          return "opCmp";
        case ">=":
          return "opCmp";
        case "<=":
          return "opCmp";
        case "-":
          return "opNeg";
        case "~":
          return "opCom";
        case "++":
          return "opPreInc";
        case "--":
          return "opPreDec";
        case "++":
          return "opPostInc";
        case "--":
          return "opPostDec";
        case "+=":
          return "opAddAssign";
        case "-=":
          return "opSubAssign";
        case "*=":
          return "opMulAssign";
        case "/=":
          return "opDivAssign";
        case "%=":
          return "opModAssign";
        case "**=":
          return "opPowAssign";
        case "|=":
          return "opOrAssign";
        case "&=":
          return "opAndAssign";
        case "^=":
          return "opXorAssign";
        case "<<=":
          return "opShlAssign";
        case ">>=":
          return "opShrAssign";
        case ">>>=":
          return "opUShrAssign";
      }
      return null;
    }
    exports2.GetOverloadMethodForOperator = GetOverloadMethodForOperator;
    function getBinaryOperatorOverloadMethod(operator) {
      switch (operator) {
        case "+":
          return "opAdd";
        case "-":
          return "opSub";
        case "*":
          return "opMul";
        case "/":
          return "opDiv";
        case "%":
          return "opMod";
        case "**":
          return "opPow";
        case "&":
          return "opAnd";
        case "|":
          return "opOr";
        case "^":
          return "opXor";
        case "<<":
          return "opShl";
        case ">>":
          return "opShr";
        case ">>>":
          return "opUShr";
        case "==":
          return "BOOLEAN";
        case "!=":
          return "BOOLEAN";
        case "<":
          return "BOOLEAN";
        case ">":
          return "BOOLEAN";
        case ">=":
          return "BOOLEAN";
        case "<=":
          return "BOOLEAN";
        case "&&":
          return "BOOLEAN";
        case "||":
          return "BOOLEAN";
      }
      return operator;
    }
    function getUnaryOperatorOverloadMethod(operator) {
      switch (operator) {
        case "-":
          return "opNeg";
        case "~":
          return "opCom";
        case "++":
          return "opPreInc";
        case "--":
          return "opPreDec";
        case "!":
          return "BOOLEAN";
      }
      return operator;
    }
    function getPostfixOperatorOverloadMethod(operator) {
      switch (operator) {
        case "++":
          return "opPostInc";
        case "--":
          return "opPostDec";
      }
      return operator;
    }
    function ResolveIteratorType(dbtype) {
      if (!dbtype)
        return null;
      let iterator_sym = dbtype.findFirstSymbol("Iterator", typedb2.DBAllowSymbol.Functions);
      if (iterator_sym && iterator_sym instanceof typedb2.DBMethod) {
        let return_type = typedb2.LookupType(iterator_sym.namespace, iterator_sym.returnType);
        if (!return_type)
          return dbtype;
        let proceed_sym = return_type.findFirstSymbol("Proceed", typedb2.DBAllowSymbol.Functions);
        if (proceed_sym && proceed_sym instanceof typedb2.DBMethod) {
          let proceed_return = typedb2.LookupType(proceed_sym.namespace, proceed_sym.returnType);
          if (proceed_return)
            return proceed_return;
        }
      }
      return dbtype;
    }
    function ResolvePropertyType(dbtype, name) {
      if (!dbtype || !name)
        return null;
      let usedSymbol = dbtype.findFirstSymbol(name, typedb2.DBAllowSymbol.Properties);
      if (usedSymbol && usedSymbol instanceof typedb2.DBProperty)
        return typedb2.LookupType(dbtype.namespace, usedSymbol.typename);
      let getAccessor = dbtype.findFirstSymbol("Get" + name, typedb2.DBAllowSymbol.Functions);
      if (getAccessor && getAccessor instanceof typedb2.DBMethod) {
        if (getAccessor.isProperty)
          return typedb2.LookupType(dbtype.namespace, getAccessor.returnType);
      }
      let setAccessor = dbtype.findFirstSymbol("Set" + name, typedb2.DBAllowSymbol.Functions);
      if (setAccessor && setAccessor instanceof typedb2.DBMethod) {
        if (setAccessor.isProperty && setAccessor.args.length != 0)
          return typedb2.LookupType(dbtype.namespace, setAccessor.args[0].typename);
      }
      return null;
    }
    function CollapseNamespaceFromNode(node) {
      if (!node)
        return "::";
      if (node.type == exports2.node_types.Identifier)
        return node.value;
      let namespace = "";
      let checkNode = node;
      while (checkNode) {
        if (checkNode.children[1]) {
          if (namespace.length == 0)
            namespace = checkNode.children[1].value;
          else
            namespace = checkNode.children[1].value + "::" + namespace;
        }
        if (checkNode.children[0] && checkNode.children[0].type == exports2.node_types.Identifier) {
          if (namespace.length == 0)
            namespace = checkNode.children[0].value;
          else
            namespace = checkNode.children[0].value + "::" + namespace;
          break;
        } else {
          checkNode = checkNode.children[0];
          if (!checkNode)
            namespace = "::" + namespace;
        }
      }
      return namespace;
    }
    exports2.CollapseNamespaceFromNode = CollapseNamespaceFromNode;
    function GetStaticTypeSignatureForType(dbnamespace, typeSymbol) {
      if (typeSymbol.isValueType())
        return typedb2.LookupType(dbnamespace, "TStructType<" + typeSymbol.getQualifiedTypenameInNamespace(dbnamespace) + ">");
      else
        return typedb2.LookupType(dbnamespace, "TSubclassOf<" + typeSymbol.getQualifiedTypenameInNamespace(dbnamespace) + ">");
    }
    function ResolveNamespacePropertyType(dbnamespace, nsPrefix, name) {
      if (!dbnamespace || !name)
        return null;
      let propName = name;
      if (nsPrefix && nsPrefix.length != 0)
        propName = nsPrefix + "::" + propName;
      let globalSymbols = typedb2.LookupGlobalSymbol(dbnamespace, propName, typedb2.DBAllowSymbol.Properties);
      if (globalSymbols && globalSymbols.length != 0 && globalSymbols[0] instanceof typedb2.DBProperty)
        return typedb2.LookupType(globalSymbols[0].namespace, globalSymbols[0].typename);
      let getterName = "Get" + name;
      if (nsPrefix && nsPrefix.length != 0)
        getterName = nsPrefix + "::" + getterName;
      let getAccessors = typedb2.LookupGlobalSymbol(dbnamespace, getterName, typedb2.DBAllowSymbol.Functions);
      if (getAccessors && getAccessors.length != 0 && getAccessors[0] instanceof typedb2.DBMethod) {
        if (getAccessors[0].isProperty)
          return typedb2.LookupType(getAccessors[0].namespace, getAccessors[0].returnType);
      }
      let setterName = "Set" + name;
      if (nsPrefix && nsPrefix.length != 0)
        setterName = nsPrefix + "::" + getterName;
      let setAccessors = typedb2.LookupGlobalSymbol(dbnamespace, setterName, typedb2.DBAllowSymbol.Functions);
      if (setAccessors && setAccessors.length != 0 && setAccessors[0] instanceof typedb2.DBMethod) {
        if (setAccessors[0].isProperty && setAccessors[0].args.length != 0)
          return typedb2.LookupType(dbnamespace, setAccessors[0].args[0].typename);
      }
      let typeSymbol = typedb2.LookupType(dbnamespace, propName);
      if (typeSymbol)
        return GetStaticTypeSignatureForType(dbnamespace, typeSymbol);
      return null;
    }
    function ResolveTypeFromIdentifier(scope, identifier) {
      let checkscope = scope;
      while (checkscope && checkscope.isInFunctionBody()) {
        let usedVariable = checkscope.variablesByName.get(identifier);
        if (usedVariable)
          return typedb2.LookupType(checkscope.getNamespace(), usedVariable.typename);
        checkscope = checkscope.parentscope;
      }
      let insideType = scope.getParentType();
      if (insideType) {
        let usedType = ResolvePropertyType(insideType, identifier);
        if (usedType)
          return usedType;
      }
      let globalSymbols = typedb2.LookupGlobalSymbol(scope.getNamespace(), identifier, typedb2.DBAllowSymbol.Properties);
      if (globalSymbols) {
        for (let sym of globalSymbols) {
          if (sym instanceof typedb2.DBProperty) {
            if (!sym.isLiteralAsset && sym.declaredModule != scope.module.modulename)
              continue;
            return typedb2.LookupType(sym.namespace, sym.typename);
          }
        }
        if (!ScriptSettings.automaticImports) {
          for (let sym of globalSymbols) {
            if (sym instanceof typedb2.DBProperty)
              return typedb2.LookupType(sym.namespace, sym.typename);
          }
        }
      }
      let getSymbols = typedb2.LookupGlobalSymbol(scope.getNamespace(), "Get" + identifier, typedb2.DBAllowSymbol.Functions);
      if (getSymbols) {
        for (let sym of getSymbols) {
          if (sym instanceof typedb2.DBMethod && sym.isProperty && sym.returnType && !sym.isMixin) {
            if (sym.isLocal && sym.declaredModule && sym.declaredModule != scope.module.modulename)
              continue;
            return typedb2.LookupType(sym.namespace, sym.returnType);
          }
        }
      }
      let setSymbols = typedb2.LookupGlobalSymbol(scope.getNamespace(), "Set" + identifier, typedb2.DBAllowSymbol.Functions);
      if (setSymbols) {
        for (let sym of setSymbols) {
          if (sym instanceof typedb2.DBMethod && sym.isProperty && sym.args.length > 0 && !sym.isMixin) {
            if (sym.isLocal && sym.declaredModule && sym.declaredModule != scope.module.modulename)
              continue;
            return typedb2.LookupType(sym.namespace, sym.args[0].typename);
          }
        }
      }
      let typeSymbol = typedb2.LookupType(scope.getNamespace(), identifier);
      if (typeSymbol)
        return GetStaticTypeSignatureForType(scope.getNamespace(), typeSymbol);
      return null;
    }
    function ResolveTypeFromOperator(scope, leftType, rightType, operator) {
      if (!operator)
        return null;
      if (operator == "BOOLEAN")
        return typedb2.GetTypeByName("bool");
      if (leftType && leftType.isPrimitive && rightType && rightType.isPrimitive) {
        if (leftType.name == "double")
          return leftType;
        if (leftType.name == "float64")
          return leftType;
        if (rightType.name == "double")
          return rightType;
        if (rightType.name == "float64")
          return rightType;
        if (leftType.name == "float")
          return leftType;
        if (rightType.name == "float")
          return rightType;
        if (leftType.name == "float32")
          return leftType;
        if (rightType.name == "float32")
          return rightType;
        return leftType;
      } else if (!rightType && leftType && leftType.isPrimitive) {
        return leftType;
      }
      if (leftType) {
        let sym = leftType.findFirstSymbol(operator);
        if (sym && sym instanceof typedb2.DBMethod)
          return typedb2.LookupType(sym.namespace, sym.returnType);
      }
      if (rightType) {
        let sym_r = rightType.findFirstSymbol(operator + "_r");
        if (sym_r && sym_r instanceof typedb2.DBMethod)
          return typedb2.LookupType(sym_r.namespace, sym_r.returnType);
      }
      return null;
    }
    function ResolveFunctionFromExpression(scope, node) {
      if (!node)
        return null;
      switch (node.type) {
        case exports2.node_types.Identifier:
          {
            return ResolveFunctionFromIdentifier(scope, node.value);
          }
          break;
        case exports2.node_types.MemberAccess:
          {
            if (!node.children[0] || !node.children[1])
              return null;
            let left_type = ResolveTypeFromExpression(scope, node.children[0]);
            if (!left_type)
              return null;
            return ResolveFunctionFromType(scope, left_type, node.children[1].value, true);
          }
          break;
        case exports2.node_types.NamespaceAccess:
          {
            if (!node.children[1])
              return null;
            let fullNamespace = CollapseNamespaceFromNode(node.children[0]);
            let insideType = scope.getParentType();
            if (insideType) {
              if (fullNamespace == "Super") {
                let superType = scope.getParentType().getSuperType();
                if (superType)
                  return ResolveFunctionFromType(scope, superType, node.children[1].value);
                else
                  return null;
              }
              let superClass = typedb2.LookupType(scope.getNamespace(), fullNamespace);
              if (superClass && insideType.inheritsFrom(superClass.name)) {
                let superSymbol = ResolveFunctionFromType(scope, superClass, node.children[1].value);
                if (superSymbol)
                  return superSymbol;
              }
            }
            let namespaceSymbol = ResolveFunctionFromNamespace(scope, scope.getNamespace(), fullNamespace, node.children[1].value);
            if (namespaceSymbol)
              return namespaceSymbol;
            return null;
          }
          break;
      }
      return null;
    }
    exports2.ResolveFunctionFromExpression = ResolveFunctionFromExpression;
    function ResolveFunctionFromType(scope, dbtype, name, allowMixin = false) {
      if (!dbtype || !name)
        return null;
      let usedSymbol = dbtype.findFirstSymbol(name, typedb2.DBAllowSymbol.Functions);
      if (usedSymbol && usedSymbol instanceof typedb2.DBMethod)
        return usedSymbol;
      if (allowMixin) {
        let globalSymbols = typedb2.LookupGlobalSymbol(scope.getNamespace(), name, typedb2.DBAllowSymbol.Mixins);
        if (globalSymbols) {
          for (let usedSymbol2 of globalSymbols) {
            if (usedSymbol2 instanceof typedb2.DBMethod) {
              if (!usedSymbol2.isMixin)
                continue;
              if (usedSymbol2.isLocal && usedSymbol2.declaredModule && usedSymbol2.declaredModule != scope.module.modulename)
                continue;
              if (usedSymbol2.args.length != 0 && dbtype.inheritsFrom(usedSymbol2.args[0].typename))
                return usedSymbol2;
            }
          }
        }
      }
      return null;
    }
    function ResolveFunctionFromIdentifier(scope, identifier) {
      let insideType = scope.getParentType();
      if (insideType) {
        let usedFunc = ResolveFunctionFromType(scope, insideType, identifier, true);
        if (usedFunc)
          return usedFunc;
      }
      let globalSymbols = typedb2.LookupGlobalSymbol(scope.getNamespace(), identifier, typedb2.DBAllowSymbol.Functions | typedb2.DBAllowSymbol.Mixins);
      if (globalSymbols) {
        for (let sym of globalSymbols) {
          if (sym instanceof typedb2.DBMethod) {
            if (sym.isLocal && sym.declaredModule && sym.declaredModule != scope.module.modulename)
              continue;
            if (sym.isMixin) {
              if (insideType) {
                if (sym.args.length == 0 || !insideType.inheritsFrom(sym.args[0].typename))
                  continue;
              } else {
                continue;
              }
            }
            return sym;
          }
        }
      }
      return null;
    }
    function DisambiguateFunctionOverloadsFromOverriddenFunctions(functions) {
      if (!functions)
        return;
      for (let i = 0; i < functions.length; ++i) {
        let insideType = functions[i].containingType;
        if (!insideType)
          continue;
        let hasOverriddenFunction = false;
        for (let j = 0; j < functions.length; ++j) {
          let compareType = functions[j].containingType;
          if (i == j)
            continue;
          if (!compareType)
            continue;
          if (!functions[i].isSignatureEqual(functions[j]))
            continue;
          if (compareType.inheritsFrom(insideType.name)) {
            hasOverriddenFunction = true;
            break;
          }
        }
        if (hasOverriddenFunction) {
          functions.splice(i, 1);
          i -= 1;
        }
      }
    }
    exports2.DisambiguateFunctionOverloadsFromOverriddenFunctions = DisambiguateFunctionOverloadsFromOverriddenFunctions;
    function ResolveFunctionOverloadsFromExpression(scope, node, functions) {
      if (!node)
        return;
      switch (node.type) {
        case exports2.node_types.Identifier:
          {
            ResolveFunctionOverloadsFromIdentifier(scope, node.value, functions);
          }
          break;
        case exports2.node_types.MemberAccess:
          {
            if (!node.children[0] || !node.children[1])
              return;
            let left_type = ResolveTypeFromExpression(scope, node.children[0]);
            if (!left_type)
              return;
            ResolveFunctionOverloadsFromType(scope, left_type, node.children[1].value, true, functions);
          }
          break;
        case exports2.node_types.NamespaceAccess:
          {
            if (!node.children[1])
              return;
            let fullNamespace = CollapseNamespaceFromNode(node.children[0]);
            let insideType = scope.getParentType();
            if (insideType) {
              if (fullNamespace == "Super") {
                let superType = scope.getParentType().getSuperType();
                if (superType)
                  ResolveFunctionOverloadsFromType(scope, superType, node.children[1].value, false, functions);
                return;
              }
              let nsClass = typedb2.LookupType(scope.getNamespace(), fullNamespace);
              if (nsClass && insideType.inheritsFrom(nsClass.name))
                ResolveFunctionOverloadsFromType(scope, nsClass, node.children[1].value, false, functions);
            }
            ResolveFunctionOverloadsFromNamespace(scope, scope.getNamespace(), fullNamespace, node.children[1].value, false, functions);
          }
          break;
      }
    }
    exports2.ResolveFunctionOverloadsFromExpression = ResolveFunctionOverloadsFromExpression;
    function ResolveFunctionOverloadsFromType(scope, dbtype, name, allowMixin = false, functions) {
      if (!dbtype || !name)
        return;
      {
        let usedSymbols = dbtype.findSymbols(name);
        if (usedSymbols) {
          for (let symbol of usedSymbols) {
            if (symbol instanceof typedb2.DBMethod) {
              if (symbol.isMixin)
                continue;
              if (symbol.isLocal && symbol.declaredModule && symbol.declaredModule != scope.module.modulename)
                continue;
              functions.push(symbol);
            }
          }
        }
      }
      if (allowMixin) {
        let globalSymbols = typedb2.LookupGlobalSymbol(scope.getNamespace(), name, typedb2.DBAllowSymbol.Mixins);
        if (globalSymbols) {
          for (let symbol of globalSymbols) {
            if (symbol instanceof typedb2.DBMethod) {
              if (!symbol.isMixin)
                continue;
              if (symbol.isLocal && symbol.declaredModule && symbol.declaredModule != scope.module.modulename)
                continue;
              if (symbol.args.length != 0 && dbtype.inheritsFrom(symbol.args[0].typename))
                functions.push(symbol);
            }
          }
        }
      }
    }
    function ResolveFunctionOverloadsFromNamespace(scope, namespace, nsPrefix, name, allowMixin = false, functions) {
      if (!namespace || !name)
        return;
      let identifier = name;
      if (nsPrefix && nsPrefix.length != 0)
        identifier = nsPrefix + "::" + name;
      {
        let globalSymbols = typedb2.LookupGlobalSymbol(namespace, identifier, typedb2.DBAllowSymbol.Functions);
        if (globalSymbols) {
          for (let symbol of globalSymbols) {
            if (symbol instanceof typedb2.DBMethod) {
              if (symbol.isMixin)
                continue;
              if (symbol.isLocal && symbol.declaredModule && symbol.declaredModule != scope.module.modulename)
                continue;
              functions.push(symbol);
            }
          }
        }
      }
    }
    function ResolveFunctionFromNamespace(scope, namespace, nsPrefix, name) {
      if (!namespace || !name)
        return null;
      let identifier = name;
      if (nsPrefix && nsPrefix.length != 0)
        identifier = nsPrefix + "::" + name;
      let globalSymbols = typedb2.LookupGlobalSymbol(namespace, identifier, typedb2.DBAllowSymbol.Functions);
      if (globalSymbols && globalSymbols.length != 0 && globalSymbols[0] instanceof typedb2.DBMethod)
        return globalSymbols[0];
      return null;
    }
    function ResolveFunctionOverloadsFromIdentifier(scope, identifier, functions, allowMixin = true) {
      let insideType = scope.getParentType();
      if (insideType)
        ResolveFunctionOverloadsFromType(scope, insideType, identifier, allowMixin, functions);
      let globalSyms = typedb2.LookupGlobalSymbol(scope.getNamespace(), identifier);
      if (globalSyms) {
        for (let sym of globalSyms) {
          if (sym instanceof typedb2.DBMethod) {
            if (sym.isMixin)
              continue;
            if (functions.includes(sym))
              continue;
            functions.push(sym);
          }
        }
      }
    }
    exports2.ResolveFunctionOverloadsFromIdentifier = ResolveFunctionOverloadsFromIdentifier;
    function DetectScopeSymbols(scope) {
      let element = scope.element_head;
      let parseContext = new ASParseContext();
      while (element) {
        if (element instanceof ASStatement) {
          if (element.ast) {
            parseContext.isRootIdentifier = true;
            DetectNodeSymbols(scope, element, element.ast, parseContext, typedb2.DBAllowSymbol.Properties | typedb2.DBAllowSymbol.Functions);
          }
        } else if (element instanceof ASScope) {
          DetectScopeSymbols(element);
        }
        element = element.next;
      }
      return parseContext;
    }
    function GetTypeFromSymbol(symbol) {
      if (symbol instanceof typedb2.DBProperty)
        return typedb2.LookupType(symbol.namespace, symbol.typename);
      else if (symbol instanceof typedb2.DBType)
        return symbol;
      else
        return null;
    }
    var ASParseContext = class {
      constructor() {
        this.allow_errors = true;
        this.isWriteAccess = false;
        this.isRootIdentifier = false;
        this.argumentFunction = null;
        this.isResolvingFunction = false;
        this.functionPassedParameterCount = -1;
      }
    };
    function GetConstantNumberFromNode(node) {
      if (!node)
        return [false, 0];
      switch (node.type) {
        case exports2.node_types.ConstDouble:
          return [true, parseFloat(node.value)];
        case exports2.node_types.ConstFloat:
          return [true, parseFloat(node.value.substring(0, node.value.length - 1))];
        case exports2.node_types.ConstInteger:
          return [true, parseInt(node.value)];
        case exports2.node_types.ConstHexInteger:
          return [true, parseInt(node.value.substring(2), 16)];
        case exports2.node_types.ConstOctalInteger:
          return [true, parseInt(node.value.substring(2), 8)];
        case exports2.node_types.ConstBinaryInteger:
          return [true, parseInt(node.value.substring(2), 2)];
          break;
      }
      return [false, 0];
    }
    exports2.GetConstantNumberFromNode = GetConstantNumberFromNode;
    function DetectNodeSymbols(scope, statement, node, parseContext, symbol_type = typedb2.DBAllowSymbol.Properties) {
      if (!node)
        return;
      let outerWriteAccess = parseContext.isWriteAccess;
      let outerArgumentFunction = parseContext.argumentFunction;
      let outerRootIdentifier = parseContext.isRootIdentifier;
      let outerIsResolvingFunction = parseContext.isResolvingFunction;
      parseContext.isWriteAccess = false;
      parseContext.argumentFunction = null;
      parseContext.isRootIdentifier = false;
      parseContext.isResolvingFunction = false;
      switch (node.type) {
        case exports2.node_types.This:
          return scope.getParentType();
          break;
        case exports2.node_types.ConstBool:
          return typedb2.GetTypeByName("bool");
          break;
        case exports2.node_types.ConstDouble:
          if (ScriptSettings.floatIsFloat64)
            return typedb2.GetTypeByName("float");
          else
            return typedb2.GetTypeByName("double");
          break;
        case exports2.node_types.ConstInteger:
        case exports2.node_types.ConstHexInteger:
        case exports2.node_types.ConstOctalInteger:
        case exports2.node_types.ConstBinaryInteger:
          return typedb2.GetTypeByName("int");
          break;
        case exports2.node_types.ConstFloat:
          if (ScriptSettings.floatIsFloat64)
            return typedb2.GetTypeByName("float32");
          else
            return typedb2.GetTypeByName("float");
          break;
        case exports2.node_types.ConstName:
          return typedb2.GetTypeByName("FName");
          break;
        case exports2.node_types.ConstString:
          return typedb2.GetTypeByName("FString");
          break;
        case exports2.node_types.ConstNullptr:
          return typedb2.GetTypeByName("UObject");
          break;
        case exports2.node_types.ConstFormatString:
          DetectFormatStringSymbols(scope, statement, node, parseContext);
          return typedb2.GetTypeByName("FString");
          break;
        case exports2.node_types.Identifier:
          {
            parseContext.isWriteAccess = outerWriteAccess;
            parseContext.argumentFunction = outerArgumentFunction;
            parseContext.isRootIdentifier = outerRootIdentifier;
            return DetectIdentifierSymbols(scope, statement, node, parseContext, symbol_type);
          }
          break;
        case exports2.node_types.MemberAccess:
          {
            parseContext.isRootIdentifier = outerRootIdentifier;
            if (outerWriteAccess && node.children[0] && node.children[0].type == exports2.node_types.Identifier) {
              let checkscope = scope;
              while (checkscope && checkscope.isInFunctionBody()) {
                let usedVariable = checkscope.variablesByName.get(node.children[0].value);
                if (usedVariable) {
                  if (!usedVariable.isReference() && usedVariable.isValueType(scope))
                    parseContext.isWriteAccess = true;
                  break;
                }
                checkscope = checkscope.parentscope;
              }
            }
            let left_symbol = DetectNodeSymbols(scope, statement, node.children[0], parseContext, typedb2.DBAllowSymbol.Properties);
            if (!left_symbol) {
              if (parseContext.allow_errors)
                AddUnknownSymbol(scope, statement, node.children[1], false);
              return null;
            }
            if (node.children[1]) {
              parseContext.isWriteAccess = outerWriteAccess;
              parseContext.isRootIdentifier = outerRootIdentifier;
              parseContext.isResolvingFunction = outerIsResolvingFunction;
              return DetectSymbolsInType(scope, statement, left_symbol, node.children[1], parseContext, symbol_type);
            }
            return null;
          }
          break;
        case exports2.node_types.NamespaceAccess:
          {
            if (!node.children[0] || node.children[0].type == exports2.node_types.Identifier) {
              let insideType = scope.getParentType();
              let parentType = null;
              let shadowedType = null;
              let namespace = null;
              if (node.children[0])
                namespace = typedb2.LookupNamespace(scope.getNamespace(), node.children[0].value);
              else
                namespace = typedb2.GetRootNamespace();
              if (insideType && node.children[0]) {
                if (node.children[0].value == "Super") {
                  parentType = scope.getParentType().getSuperType();
                } else {
                  if (typedb2.AllowsFunctions(symbol_type)) {
                    if (insideType.inheritsFrom(node.children[0].value))
                      parentType = typedb2.LookupType(scope.getNamespace(), node.children[0].value);
                  }
                }
              }
              if (!parentType && node.children[0])
                shadowedType = typedb2.LookupType(scope.getNamespace(), node.children[0].value);
              if (!namespace && !parentType && !shadowedType) {
                if (node.children[0])
                  scope.module.markDependencyIdentifier(node.children[0].value);
                if (parseContext.allow_errors) {
                  if (node.children[0])
                    AddUnknownSymbol(scope, statement, node.children[0], false);
                  AddUnknownSymbol(scope, statement, node.children[1], false);
                }
                return null;
              }
              if (node.children[0]) {
                let addedSymbol = AddIdentifierSymbol(scope, statement, node.children[0], ASSymbolType.Namespace, null, null);
                if (shadowedType && (namespace || shadowedType.isEnum)) {
                  scope.module.markDependencyType(shadowedType);
                  addedSymbol.symbol_name = shadowedType.name;
                  addedSymbol.type = ASSymbolType.Typename;
                } else if (namespace) {
                  scope.module.markDependencyNamespace(namespace);
                  addedSymbol.symbol_name = namespace.getQualifiedNamespace();
                } else if (parentType) {
                  scope.module.markDependencyType(parentType);
                  addedSymbol.symbol_name = parentType.name;
                  addedSymbol.type = ASSymbolType.Typename;
                }
              }
              if (node.children[1]) {
                if (parentType) {
                  let prevErrors = parseContext.allow_errors;
                  parseContext.isWriteAccess = outerWriteAccess;
                  parseContext.allow_errors = false;
                  let parentSymbol = DetectSymbolsInType(scope, statement, parentType, node.children[1], parseContext, symbol_type);
                  parseContext.allow_errors = prevErrors;
                  if (parentSymbol) {
                    let scopeFunc = scope.getParentFunction();
                    if (scopeFunc && parentSymbol instanceof typedb2.DBMethod && parentSymbol.name == scopeFunc.name)
                      scopeFunc.hasSuperCall = true;
                    return parentSymbol;
                  }
                } else if (shadowedType && shadowedType.isEnum) {
                  parseContext.isWriteAccess = outerWriteAccess;
                  return DetectSymbolsInType(scope, statement, shadowedType, node.children[1], parseContext, symbol_type);
                }
                if (namespace) {
                  parseContext.isWriteAccess = outerWriteAccess;
                  parseContext.isResolvingFunction = outerIsResolvingFunction;
                  return DetectSymbolsInNamespace(scope, statement, namespace, node.children[1], parseContext, symbol_type | typedb2.DBAllowSymbol.Types);
                }
              }
            } else {
              let identifierNodes = [];
              let checkNode = node;
              let lookupRootNamespace = scope.getNamespace();
              while (checkNode) {
                if (checkNode.type == exports2.node_types.Identifier) {
                  identifierNodes.splice(0, 0, checkNode);
                  break;
                } else if (checkNode.type == exports2.node_types.NamespaceAccess) {
                  identifierNodes.splice(0, 0, checkNode.children[1]);
                  checkNode = checkNode.children[0];
                  if (!checkNode)
                    lookupRootNamespace = typedb2.GetRootNamespace();
                } else {
                  break;
                }
              }
              let qualifiedNamespace = "";
              for (let i = 0, count = identifierNodes.length - 1; i < count; ++i) {
                if (identifierNodes[i]) {
                  if (qualifiedNamespace.length != 0)
                    qualifiedNamespace += "::";
                  qualifiedNamespace += identifierNodes[i].value;
                }
              }
              let resolveNamespace = "";
              let prevNamespace = null;
              for (let i = 0, count = identifierNodes.length - 1; i < count; ++i) {
                if (identifierNodes[i]) {
                  if (resolveNamespace.length != 0)
                    resolveNamespace += "::";
                  resolveNamespace += identifierNodes[i].value;
                  let subNamespace = typedb2.LookupNamespace(lookupRootNamespace, resolveNamespace);
                  if (subNamespace) {
                    let addedSymbol = AddIdentifierSymbol(scope, statement, identifierNodes[i], ASSymbolType.Namespace, null, null);
                    let shadowedType = subNamespace.getShadowedType();
                    prevNamespace = subNamespace;
                    if (shadowedType) {
                      scope.module.markDependencyType(shadowedType);
                      addedSymbol.symbol_name = shadowedType.name;
                      addedSymbol.type = ASSymbolType.Typename;
                    } else {
                      scope.module.markDependencyNamespace(subNamespace);
                      addedSymbol.symbol_name = subNamespace.getQualifiedNamespace();
                    }
                  } else {
                    let enumType = typedb2.LookupType(prevNamespace, identifierNodes[i].value);
                    if (enumType && enumType.isEnum) {
                      AddIdentifierSymbol(scope, statement, identifierNodes[i], ASSymbolType.Typename, null, enumType.name);
                      let enumValueNode = identifierNodes[i + 1];
                      if (enumValueNode) {
                        let value = enumType.findFirstSymbol(enumValueNode.value, typedb2.DBAllowSymbol.Properties);
                        if (value)
                          AddIdentifierSymbol(scope, statement, enumValueNode, ASSymbolType.MemberVariable, enumType.name, value.name);
                        else
                          AddUnknownSymbol(scope, statement, enumValueNode, false);
                        for (let n = i + 2; n < identifierNodes.length; ++n) {
                          if (identifierNodes[n])
                            AddUnknownSymbol(scope, statement, identifierNodes[n], false);
                        }
                      }
                      return enumType;
                    }
                    AddUnknownSymbol(scope, statement, identifierNodes[i], false);
                  }
                }
              }
              let namespace = typedb2.LookupNamespace(lookupRootNamespace, qualifiedNamespace);
              if (!namespace) {
                AddUnknownSymbol(scope, statement, node.children[1], false);
                return null;
              } else if (node.children[1]) {
                parseContext.isWriteAccess = outerWriteAccess;
                parseContext.isResolvingFunction = outerIsResolvingFunction;
                return DetectSymbolsInNamespace(scope, statement, namespace, node.children[1], parseContext, symbol_type | typedb2.DBAllowSymbol.Types);
              }
            }
            return null;
          }
          break;
        case exports2.node_types.FunctionCall:
          {
            let delegateBind = null;
            let left_type = null;
            let left_symbol = null;
            if (node.children[0] && node.children[0].type == exports2.node_types.Identifier) {
              let refType = typedb2.LookupType(scope.getNamespace(), node.children[0].value);
              if (refType && refType.isEnum) {
                left_type = refType;
                let addedSymbol = AddIdentifierSymbol(scope, statement, node.children[0], ASSymbolType.Typename, null, refType.name);
                if (refType.declaredModule && !ScriptSettings.automaticImports && !scope.module.isModuleImported(refType.declaredModule))
                  addedSymbol.isUnimported = true;
                scope.module.markDependencyType(refType);
              } else if (refType) {
                scope.module.markDependencyType(refType);
                let constructors = typedb2.LookupGlobalSymbol(refType.namespace, refType.name, typedb2.DBAllowSymbol.Functions);
                if (constructors && constructors.length >= 1)
                  left_symbol = constructors[0];
                else
                  left_symbol = null;
                left_type = refType;
                let addedSymbol = AddIdentifierSymbol(scope, statement, node.children[0], ASSymbolType.Typename, null, refType.name);
                if (refType.declaredModule && !ScriptSettings.automaticImports && !scope.module.isModuleImported(refType.declaredModule))
                  addedSymbol.isUnimported = true;
                if (left_type.isDelegate && node.children[1]) {
                  delegateBind = new ASDelegateBind();
                  delegateBind.scope = scope;
                  delegateBind.statement = statement;
                  delegateBind.node_expression = node;
                  if (node.children[1].children[0])
                    delegateBind.node_object = node.children[1].children[0];
                  if (node.children[1].children[1])
                    delegateBind.node_name = node.children[1].children[1];
                  delegateBind.delegateType = left_type.name;
                  scope.module.delegateBinds.push(delegateBind);
                }
              }
            }
            if (left_type == null) {
              parseContext.isResolvingFunction = true;
              if (node.children[1])
                parseContext.functionPassedParameterCount = node.children[1].children.length;
              else
                parseContext.functionPassedParameterCount = 0;
              left_symbol = DetectNodeSymbols(scope, statement, node.children[0], parseContext, typedb2.DBAllowSymbol.Functions);
              parseContext.isResolvingFunction = false;
              if (left_symbol && left_symbol instanceof typedb2.DBMethod)
                left_type = typedb2.LookupType(left_symbol.namespace, left_symbol.returnType);
            }
            if (left_symbol && left_symbol instanceof typedb2.DBMethod)
              parseContext.argumentFunction = left_symbol;
            else
              parseContext.argumentFunction = null;
            if (left_symbol instanceof typedb2.DBMethod) {
              if (left_symbol.isDelegateBindFunction && node.children[1]) {
                delegateBind = new ASDelegateBind();
                delegateBind.scope = scope;
                delegateBind.statement = statement;
                delegateBind.node_expression = node;
                if (node.children[1].children[left_symbol.delegateObjectParam])
                  delegateBind.node_object = node.children[1].children[left_symbol.delegateObjectParam];
                if (node.children[1].children[left_symbol.delegateFunctionParam])
                  delegateBind.node_name = node.children[1].children[left_symbol.delegateFunctionParam];
                if (left_symbol.delegateWildcardParam != -1 && node.children[1].children[left_symbol.delegateWildcardParam]) {
                  delegateBind.node_wildcard = node.children[1].children[left_symbol.delegateWildcardParam];
                  delegateBind.wildcard_name = left_symbol.macroMeta.get("delegatewildcardparam");
                }
                delegateBind.delegateType = left_symbol.delegateBindType;
                scope.module.delegateBinds.push(delegateBind);
              } else if (left_symbol.methodAnnotation != typedb2.DBMethodAnnotation.None) {
                let annotation = new ASAnnotatedCall();
                annotation.scope = scope;
                annotation.statement = statement;
                annotation.node_call = node;
                annotation.method = left_symbol;
                scope.module.annotatedFunctionCalls.push(annotation);
              }
            }
            if (delegateBind && left_symbol && left_symbol instanceof typedb2.DBMethod) {
              for (let i = 0; i < node.children[1].children.length; ++i) {
                let childNode = node.children[1].children[i];
                if (!childNode)
                  continue;
                if (childNode == delegateBind.node_name && childNode.type == exports2.node_types.ConstName) {
                  parseContext.argumentFunction = left_symbol;
                  DetectSymbolFromDelegateBindFunctionName(scope, statement, parseContext, delegateBind);
                } else {
                  parseContext.argumentFunction = left_symbol;
                  DetectNodeSymbols(scope, statement, childNode, parseContext, typedb2.DBAllowSymbol.Properties);
                }
              }
            } else if (left_symbol instanceof typedb2.DBMethod && left_symbol.determinesOutputTypeArgumentIndex != -1) {
              if (node.children[1] && node.children[1].children) {
                let argumentNodes = node.children[1].children;
                for (let i = 0; i < argumentNodes.length; ++i) {
                  parseContext.argumentFunction = outerArgumentFunction;
                  let argumentSymbol = DetectNodeSymbols(scope, statement, argumentNodes[i], parseContext);
                  if (i == left_symbol.determinesOutputTypeArgumentIndex) {
                    if (argumentSymbol instanceof typedb2.DBType) {
                      left_type = left_symbol.applyDeterminesOutputType(left_symbol.returnType, argumentSymbol);
                    } else if (argumentSymbol instanceof typedb2.DBProperty) {
                      let property_type = typedb2.LookupType(scope.getNamespace(), argumentSymbol.typename);
                      left_type = left_symbol.applyDeterminesOutputType(left_symbol.returnType, property_type);
                    }
                  }
                }
              }
            } else {
              DetectNodeSymbols(scope, statement, node.children[1], parseContext, typedb2.DBAllowSymbol.Properties);
            }
            return left_type;
          }
          break;
        case exports2.node_types.ConstructorCall:
          {
            AddTypenameSymbol(scope, statement, node.children[0]);
            DetectNodeSymbols(scope, statement, node.children[1], parseContext, typedb2.DBAllowSymbol.Properties);
            if (!node.children[0] || !node.children[0].value)
              return null;
            return typedb2.LookupType(scope.getNamespace(), node.children[0].value);
          }
          break;
        case exports2.node_types.ArgumentList:
          {
            if (node.children) {
              for (let child of node.children) {
                parseContext.argumentFunction = outerArgumentFunction;
                DetectNodeSymbols(scope, statement, child, parseContext);
              }
            }
          }
          break;
        case exports2.node_types.IndexOperator:
          {
            let left_symbol = DetectNodeSymbols(scope, statement, node.children[0], parseContext, typedb2.DBAllowSymbol.Properties);
            DetectNodeSymbols(scope, statement, node.children[1], parseContext, typedb2.DBAllowSymbol.Properties);
            return ResolveTypeFromOperator(scope, GetTypeFromSymbol(left_symbol), null, "opIndex");
          }
          break;
        case exports2.node_types.BinaryOperation:
          {
            let left_symbol = DetectNodeSymbols(scope, statement, node.children[0], parseContext, typedb2.DBAllowSymbol.Properties);
            let right_symbol = DetectNodeSymbols(scope, statement, node.children[1], parseContext, typedb2.DBAllowSymbol.Properties);
            return ResolveTypeFromOperator(scope, GetTypeFromSymbol(left_symbol), GetTypeFromSymbol(right_symbol), getBinaryOperatorOverloadMethod(node.operator));
          }
          break;
        case exports2.node_types.UnaryOperation:
          {
            let left_symbol = DetectNodeSymbols(scope, statement, node.children[0], parseContext, typedb2.DBAllowSymbol.Properties);
            return ResolveTypeFromOperator(scope, GetTypeFromSymbol(left_symbol), null, getUnaryOperatorOverloadMethod(node.operator));
          }
          break;
        case exports2.node_types.PostfixOperation:
          {
            let left_symbol = DetectNodeSymbols(scope, statement, node.children[0], parseContext, typedb2.DBAllowSymbol.Properties);
            return ResolveTypeFromOperator(scope, GetTypeFromSymbol(left_symbol), null, getPostfixOperatorOverloadMethod(node.operator));
          }
          break;
        case exports2.node_types.TernaryOperation:
          {
            DetectNodeSymbols(scope, statement, node.children[0], parseContext, typedb2.DBAllowSymbol.Properties);
            let left_symbol = DetectNodeSymbols(scope, statement, node.children[1], parseContext, typedb2.DBAllowSymbol.Properties);
            let right_symbol = DetectNodeSymbols(scope, statement, node.children[2], parseContext, typedb2.DBAllowSymbol.Properties);
            if (left_symbol) {
              if (left_symbol != right_symbol) {
                if (left_symbol instanceof typedb2.DBType && right_symbol instanceof typedb2.DBType) {
                  if (!left_symbol.isValueType() && !right_symbol.isValueType()) {
                    let target_type = left_symbol;
                    while (target_type && !right_symbol.inheritsFrom(target_type.name))
                      target_type = target_type.getSuperType();
                    if (target_type)
                      return target_type;
                  }
                }
              }
              return left_symbol;
            } else {
              return right_symbol;
            }
          }
          break;
        case exports2.node_types.CastOperation:
          {
            AddTypenameSymbol(scope, statement, node.children[0]);
            DetectNodeSymbols(scope, statement, node.children[1], parseContext, typedb2.DBAllowSymbol.Properties);
            if (!node.children[0] || !node.children[0].value)
              return null;
            return typedb2.LookupType(scope.getNamespace(), node.children[0].value);
          }
          break;
        case exports2.node_types.FunctionDecl:
        case exports2.node_types.ConstructorDecl:
          {
            if (node.access)
              AddAccessSpecifierSymbol(scope, statement, node.access);
            if (node.returntype && node.returntype.value != "void")
              AddTypenameSymbol(scope, statement, node.returntype);
            if (node.name) {
              let insideType = scope.dbtype ? scope.dbtype.name : null;
              let symType = scope.dbtype ? ASSymbolType.MemberFunction : ASSymbolType.GlobalFunction;
              if (!insideType)
                insideType = scope.getNamespace().getQualifiedNamespace();
              if (node.type == exports2.node_types.ConstructorDecl) {
                insideType = null;
                symType = ASSymbolType.Typename;
              }
              AddIdentifierSymbol(scope, statement, node.name, symType, insideType, node.name.value);
            }
            if (node.parameters) {
              for (let param of node.parameters) {
                if (param.typename)
                  AddTypenameSymbol(scope, statement, param.typename);
                if (param.name)
                  AddIdentifierSymbol(scope, statement, param.name, ASSymbolType.Parameter, null, param.name.value);
                if (param.expression)
                  DetectNodeSymbols(scope, statement, param.expression, parseContext, typedb2.DBAllowSymbol.Properties);
              }
            }
          }
          break;
        case exports2.node_types.DestructorDecl:
          {
            if (node.name) {
              AddIdentifierSymbol(scope, statement, {
                value: node.name.value.substr(1),
                start: node.name.start + 1,
                end: node.name.end
              }, ASSymbolType.Typename, null, node.name.value.substr(1));
            }
          }
          break;
        case exports2.node_types.EventDecl:
        case exports2.node_types.DelegateDecl:
          {
            let signature = statement.ast.children[0];
            if (signature) {
              if (signature.returntype && signature.returntype.value != "void")
                AddTypenameSymbol(scope, statement, signature.returntype);
              if (signature.name)
                AddIdentifierSymbol(scope, statement, signature.name, ASSymbolType.Typename, null, signature.name.value);
              if (signature.parameters) {
                for (let param of signature.parameters) {
                  if (param.typename)
                    AddTypenameSymbol(scope, statement, param.typename);
                  if (param.name)
                    AddIdentifierSymbol(scope, statement, param.name, ASSymbolType.Parameter, null, param.name.value);
                  if (param.expression)
                    DetectNodeSymbols(scope, statement, param.expression, parseContext, typedb2.DBAllowSymbol.Properties);
                }
              }
            }
          }
          break;
        case exports2.node_types.ImportFunctionStatement:
          {
            let signature = statement.ast.children[0];
            if (signature) {
              if (signature.returntype && signature.returntype.value != "void")
                AddTypenameSymbol(scope, statement, signature.returntype);
              if (signature.name) {
                let namespace = scope.getNamespace().getQualifiedNamespace();
                AddIdentifierSymbol(scope, statement, signature.name, ASSymbolType.GlobalFunction, namespace, signature.name.value);
              }
              if (signature.parameters) {
                for (let param of signature.parameters) {
                  if (param.typename)
                    AddTypenameSymbol(scope, statement, param.typename);
                  if (param.name)
                    AddIdentifierSymbol(scope, statement, param.name, ASSymbolType.Parameter, null, param.name.value);
                  if (param.expression)
                    DetectNodeSymbols(scope, statement, param.expression, parseContext, typedb2.DBAllowSymbol.Properties);
                }
              }
            }
          }
          break;
        case exports2.node_types.VariableDecl:
          {
            if (node.access)
              AddAccessSpecifierSymbol(scope, statement, node.access);
            let typenameSymbol = null;
            let variableType = null;
            if (node.typename) {
              variableType = typedb2.LookupType(scope.getNamespace(), node.typename.value);
              if (scope.module.isEditingNode(statement, node.typename)) {
                if (variableType || DoesTypenameExist(scope, node.typename.value)) {
                  if (!node.is_secondary)
                    typenameSymbol = AddTypenameSymbol(scope, statement, node.typename);
                } else {
                  let namespacedSymbol = DetectSymbolFromNamespacedIdentifier(scope, statement, node.typename, true, typedb2.DBAllowSymbol.PropertiesAndFunctions);
                  if (!namespacedSymbol) {
                    let prevErrors = parseContext.allow_errors;
                    parseContext.allow_errors = false;
                    parseContext.isWriteAccess = outerWriteAccess;
                    let identifierSymbol = DetectIdentifierSymbols(scope, statement, node.typename, parseContext, typedb2.DBAllowSymbol.PropertiesAndFunctions);
                    parseContext.allow_errors = prevErrors;
                    if (identifierSymbol) {
                    } else {
                      let hasPotentialCompletions = CheckIdentifierIsPrefixForValidSymbol(scope, statement, parseContext, node.typename.value, typedb2.DBAllowSymbol.PropertiesAndFunctions);
                      if (!hasPotentialCompletions) {
                        if (!node.is_secondary)
                          typenameSymbol = AddTypenameSymbol(scope, statement, node.typename);
                      }
                    }
                  }
                }
              } else {
                if (!node.is_secondary)
                  typenameSymbol = AddTypenameSymbol(scope, statement, node.typename);
              }
            }
            if (node.name) {
              let insideType = scope.dbtype ? scope.dbtype.name : null;
              let symType = ASSymbolType.LocalVariable;
              if (scope.dbtype && scope.scopetype == ASScopeType.Class) {
                symType = ASSymbolType.MemberVariable;
              } else if (scope.scopetype == ASScopeType.Namespace || scope.scopetype == ASScopeType.Global) {
                symType = ASSymbolType.GlobalVariable;
                insideType = scope.getNamespace().getQualifiedNamespace();
              }
              AddIdentifierSymbol(scope, statement, node.name, symType, insideType, node.name.value, true);
            }
            if (node.expression) {
              if (variableType && variableType.isDelegate && node.expression.type == exports2.node_types.ArgumentList) {
                let delegateBind = new ASDelegateBind();
                delegateBind.scope = scope;
                delegateBind.statement = statement;
                delegateBind.node_expression = node;
                if (node.expression.children[0])
                  delegateBind.node_object = node.expression.children[0];
                if (node.expression.children[1])
                  delegateBind.node_name = node.expression.children[1];
                delegateBind.delegateType = variableType.name;
                scope.module.delegateBinds.push(delegateBind);
                for (let i = 0; i < node.expression.children.length; ++i) {
                  let childNode = node.expression.children[i];
                  if (!childNode)
                    continue;
                  if (childNode == delegateBind.node_name && childNode.type == exports2.node_types.ConstName) {
                    DetectSymbolFromDelegateBindFunctionName(scope, statement, parseContext, delegateBind);
                  } else {
                    DetectNodeSymbols(scope, statement, childNode, parseContext, typedb2.DBAllowSymbol.Properties);
                  }
                }
              } else {
                let expressionType = DetectNodeSymbols(scope, statement, node.expression, parseContext, typedb2.DBAllowSymbol.Properties);
                if (typenameSymbol && typenameSymbol.symbol_name == "auto")
                  UpdateAutoTypenameSymbol(typenameSymbol, expressionType);
              }
            }
          }
          break;
        case exports2.node_types.AccessDeclaration:
          {
            if (node.name) {
              let insideType = scope.dbtype ? scope.dbtype.name : null;
              let symType = ASSymbolType.AccessSpecifier;
              AddIdentifierSymbol(scope, statement, node.name, symType, insideType, node.name.value, true);
            }
            if (node.classList) {
              for (let cls of node.classList) {
                if (cls.className.value == "*")
                  continue;
                if (cls.className.value == "private")
                  continue;
                if (cls.className.value == "protected")
                  continue;
                let specType = typedb2.LookupType(scope.getNamespace(), cls.className.value);
                if (specType) {
                  AddIdentifierSymbol(scope, statement, cls.className, ASSymbolType.Typename, null, cls.className.value);
                } else {
                  let globalFunctions = typedb2.LookupGlobalSymbol(scope.getNamespace(), cls.className.value, typedb2.DBAllowSymbol.Functions);
                  if (globalFunctions && globalFunctions.length != 0) {
                    let func = globalFunctions[0];
                    let namespace = func.namespace.getQualifiedNamespace();
                    AddIdentifierSymbol(scope, statement, cls.className, ASSymbolType.GlobalFunction, namespace, func.name);
                  } else {
                    let namespace = typedb2.LookupNamespace(null, cls.className.value);
                    if (namespace) {
                      AddIdentifierSymbol(scope, statement, cls.className, ASSymbolType.Namespace, null, namespace.getQualifiedNamespace());
                    } else {
                      if (!scope.module.isEditingNode(statement, cls.className) && InitialParseDone)
                        AddUnknownSymbol(scope, statement, cls.className, false);
                    }
                  }
                }
              }
            }
          }
          break;
        case exports2.node_types.AssetDefinition:
          {
            let namespace = scope.getNamespace().getQualifiedNamespace();
            AddIdentifierSymbol(scope, statement, node.name, ASSymbolType.GlobalVariable, namespace, node.name.value);
            if (node.typename)
              AddTypenameSymbol(scope, statement, node.typename);
          }
          break;
        case exports2.node_types.VariableDeclMulti:
          {
            for (let child of node.children) {
              DetectNodeSymbols(scope, statement, child, parseContext, typedb2.DBAllowSymbol.Properties);
            }
          }
          break;
        case exports2.node_types.Assignment:
        case exports2.node_types.CompoundAssignment:
          {
            for (let i = 0, count = node.children.length; i < count; ++i) {
              parseContext.isWriteAccess = i == 0;
              DetectNodeSymbols(scope, statement, node.children[i], parseContext, typedb2.DBAllowSymbol.Properties);
            }
          }
          break;
        case exports2.node_types.ReturnStatement:
        case exports2.node_types.DefaultStatement:
        case exports2.node_types.SwitchStatement:
        case exports2.node_types.CommaExpression:
          {
            for (let child of node.children)
              DetectNodeSymbols(scope, statement, child, parseContext, typedb2.DBAllowSymbol.Properties);
          }
          break;
        case exports2.node_types.IfStatement:
        case exports2.node_types.ElseStatement:
        case exports2.node_types.ForLoop:
        case exports2.node_types.WhileLoop:
        case exports2.node_types.CaseStatement:
        case exports2.node_types.DefaultCaseStatement:
          {
            for (let i = 0, count = node.children.length - 1; i < count; ++i)
              DetectNodeSymbols(scope, statement, node.children[i], parseContext, typedb2.DBAllowSymbol.Properties);
          }
          break;
        case exports2.node_types.ForEachLoop:
          {
            let typenameSymbol = AddTypenameSymbol(scope, statement, node.children[0]);
            if (node.children[1])
              AddIdentifierSymbol(scope, statement, node.children[1], ASSymbolType.LocalVariable, null, node.children[1].value);
            let expressionType = DetectNodeSymbols(scope, statement, node.children[2], parseContext, typedb2.DBAllowSymbol.Properties);
            if (typenameSymbol && typenameSymbol.symbol_name == "auto") {
              UpdateAutoTypenameSymbol(typenameSymbol, ResolveIteratorType(GetTypeFromSymbol(expressionType)));
            }
          }
          break;
        case exports2.node_types.ClassDefinition:
          {
            AddIdentifierSymbol(scope, statement, node.name, ASSymbolType.Typename, null, node.name.value);
            if (node.superclass) {
              let superType = typedb2.LookupType(scope.getNamespace(), node.superclass.value);
              if (superType) {
                let superSymbol = AddIdentifierSymbol(scope, statement, node.superclass, ASSymbolType.Typename, null, node.superclass.value);
                if (superType.declaredModule && !ScriptSettings.automaticImports && !scope.module.isModuleImported(superType.declaredModule))
                  superSymbol.isUnimported = true;
                scope.module.markDependencyType(superType);
              } else {
                let hasPotentialCompletions = false;
                if (scope.module.isEditingNode(statement, node.superclass))
                  hasPotentialCompletions = typedb2.HasTypeWithPrefix(scope.getNamespace(), node.superclass.value);
                AddUnknownSymbol(scope, statement, node.superclass, hasPotentialCompletions);
                scope.module.markDependencyIdentifier(node.superclass.value);
                return null;
              }
            }
          }
          break;
        case exports2.node_types.StructDefinition:
          {
            AddIdentifierSymbol(scope, statement, node.name, ASSymbolType.Typename, null, node.name.value);
          }
          break;
        case exports2.node_types.EnumDefinition:
          {
            AddIdentifierSymbol(scope, statement, node.name, ASSymbolType.Typename, null, node.name.value);
          }
          break;
        case exports2.node_types.NamespaceDefinition:
          {
            let namespace = typedb2.LookupNamespace(scope.getNamespace(), node.name.value);
            if (namespace) {
              let shadowedType = typedb2.LookupType(scope.getNamespace(), node.name.value);
              if (shadowedType)
                AddIdentifierSymbol(scope, statement, node.name, ASSymbolType.Typename, null, namespace.name);
              else
                AddIdentifierSymbol(scope, statement, node.name, ASSymbolType.Namespace, null, namespace.getQualifiedNamespace());
            }
          }
          break;
        case exports2.node_types.NamedArgument:
          {
            let expr_type = DetectNodeSymbols(scope, statement, node.children[1], parseContext, typedb2.DBAllowSymbol.Properties);
            return expr_type;
          }
          break;
        case exports2.node_types.EnumValueList:
          {
            if (scope.dbtype) {
              for (let enumValue of statement.ast.children) {
                if (!enumValue)
                  continue;
                AddIdentifierSymbol(scope, statement, enumValue.name, ASSymbolType.MemberVariable, scope.dbtype.name, enumValue.name.value);
              }
            }
          }
          break;
      }
      return null;
    }
    function DetectIdentifierSymbols(scope, statement, node, parseContext, symbol_type) {
      if (!node)
        return null;
      if (typedb2.AllowsProperties(symbol_type)) {
        let checkscope = scope;
        while (checkscope && checkscope.isInFunctionBody()) {
          let usedVariable = checkscope.variablesByName.get(node.value);
          if (usedVariable) {
            if (!parseContext.isRootIdentifier && (!parseContext.isWriteAccess || usedVariable.isReference()))
              usedVariable.isUnused = false;
            usedVariable.hasAnyUsages = true;
            let symType2 = usedVariable.isArgument ? ASSymbolType.Parameter : ASSymbolType.LocalVariable;
            let varSymbol = AddIdentifierSymbol(scope, statement, node, symType2, null, node.value, parseContext.isWriteAccess);
            if (!usedVariable.usages)
              usedVariable.usages = new Array();
            usedVariable.usages.push(varSymbol);
            let dbType = typedb2.LookupType(checkscope.getNamespace(), usedVariable.typename);
            scope.module.markDependencyType(dbType);
            return dbType;
          }
          checkscope = checkscope.parentscope;
        }
      }
      let insideType = scope.getParentType();
      if (insideType) {
        let usedSymbol = insideType.findFirstSymbol(node.value, symbol_type);
        if (usedSymbol) {
          let symType2 = usedSymbol instanceof typedb2.DBProperty ? ASSymbolType.MemberVariable : ASSymbolType.MemberFunction;
          AddIdentifierSymbol(scope, statement, node, symType2, usedSymbol.containingType, usedSymbol.name, parseContext.isWriteAccess);
          scope.module.markDependencySymbol(usedSymbol);
          return usedSymbol;
        }
        if (typedb2.AllowsProperties(symbol_type)) {
          let getAccessor = insideType.findFirstSymbol("Get" + node.value, typedb2.DBAllowSymbol.Functions);
          if (getAccessor && getAccessor instanceof typedb2.DBMethod) {
            AddIdentifierSymbol(scope, statement, node, ASSymbolType.MemberAccessor, getAccessor.containingType, getAccessor.name, parseContext.isWriteAccess);
            scope.module.markDependencyFunction(getAccessor);
            return typedb2.LookupType(getAccessor.namespace, getAccessor.returnType);
          }
          let setAccessor = insideType.findFirstSymbol("Set" + node.value, typedb2.DBAllowSymbol.Functions);
          if (setAccessor && setAccessor instanceof typedb2.DBMethod && setAccessor.isProperty && setAccessor.args.length != 0) {
            AddIdentifierSymbol(scope, statement, node, ASSymbolType.MemberAccessor, setAccessor.containingType, setAccessor.name, parseContext.isWriteAccess);
            scope.module.markDependencyFunction(setAccessor);
            return typedb2.LookupType(setAccessor.namespace, setAccessor.args[0].typename);
          }
        }
      }
      let globalSymbols = typedb2.LookupGlobalSymbol(scope.getNamespace(), node.value);
      if (globalSymbols) {
        for (let usedSymbol of globalSymbols) {
          if (usedSymbol instanceof typedb2.DBMethod && typedb2.AllowsFunctions(symbol_type)) {
            if (usedSymbol.isMixin) {
              if (insideType) {
                if (usedSymbol.args.length == 0 || !insideType.inheritsFrom(usedSymbol.args[0].typename))
                  continue;
              } else {
                continue;
              }
            }
            if (usedSymbol.isConstructor)
              continue;
            if (usedSymbol.isLocal && usedSymbol.declaredModule && usedSymbol.declaredModule != scope.module.modulename)
              continue;
            let addedSym = AddIdentifierSymbol(scope, statement, node, ASSymbolType.GlobalFunction, usedSymbol.namespace.getQualifiedNamespace(), usedSymbol.name, parseContext.isWriteAccess);
            if (!ScriptSettings.automaticImports && usedSymbol.declaredModule && !scope.module.isModuleImported(usedSymbol.declaredModule))
              addedSym.isUnimported = true;
            scope.module.markDependencyFunction(usedSymbol);
            return usedSymbol;
          } else if (usedSymbol instanceof typedb2.DBProperty && typedb2.AllowsProperties(symbol_type)) {
            let addedSym = AddIdentifierSymbol(scope, statement, node, ASSymbolType.GlobalVariable, usedSymbol.namespace.getQualifiedNamespace(), usedSymbol.name, parseContext.isWriteAccess);
            if (!ScriptSettings.automaticImports && usedSymbol.declaredModule && !scope.module.isModuleImported(usedSymbol.declaredModule))
              addedSym.isUnimported = true;
            scope.module.markDependencyProperty(usedSymbol);
            return usedSymbol;
          }
        }
      }
      if (typedb2.AllowsProperties(symbol_type)) {
        let globalGetAccessors = typedb2.LookupGlobalSymbol(scope.getNamespace(), "Get" + node.value, typedb2.DBAllowSymbol.Functions);
        if (globalGetAccessors) {
          for (let usedSymbol of globalGetAccessors) {
            if (usedSymbol instanceof typedb2.DBMethod && usedSymbol.isProperty && !usedSymbol.isMixin) {
              if (usedSymbol.isLocal && usedSymbol.declaredModule && usedSymbol.declaredModule != scope.module.modulename)
                continue;
              let addedSym = AddIdentifierSymbol(scope, statement, node, ASSymbolType.GlobalAccessor, usedSymbol.namespace.getQualifiedNamespace(), usedSymbol.name, parseContext.isWriteAccess);
              if (!ScriptSettings.automaticImports)
                addedSym.isUnimported = true;
              scope.module.markDependencyFunction(usedSymbol);
              return typedb2.LookupType(usedSymbol.namespace, usedSymbol.returnType);
            }
          }
        }
        let globalSetAccessors = typedb2.LookupGlobalSymbol(scope.getNamespace(), "Set" + node.value, typedb2.DBAllowSymbol.Functions);
        if (globalSetAccessors) {
          for (let usedSymbol of globalSetAccessors) {
            if (usedSymbol instanceof typedb2.DBMethod && usedSymbol.isProperty && usedSymbol.args.length != 0 && !usedSymbol.isMixin) {
              if (usedSymbol.isLocal && usedSymbol.declaredModule && usedSymbol.declaredModule != scope.module.modulename)
                continue;
              let addedSym = AddIdentifierSymbol(scope, statement, node, ASSymbolType.GlobalAccessor, usedSymbol.namespace.getQualifiedNamespace(), usedSymbol.name, parseContext.isWriteAccess);
              if (!ScriptSettings.automaticImports && usedSymbol.declaredModule && !scope.module.isModuleImported(usedSymbol.declaredModule))
                addedSym.isUnimported = true;
              scope.module.markDependencyFunction(usedSymbol);
              return typedb2.LookupType(usedSymbol.namespace, usedSymbol.args[0].typename);
            }
          }
        }
      }
      if (parseContext.argumentFunction && parseContext.argumentFunction.args) {
        for (let arg of parseContext.argumentFunction.args) {
          if (arg.name == node.value)
            return null;
        }
      }
      let symType = typedb2.LookupType(scope.getNamespace(), node.value);
      if (symType) {
        let addedSymbol = AddIdentifierSymbol(scope, statement, node, ASSymbolType.Typename, null, symType.name);
        if (symType.declaredModule && !ScriptSettings.automaticImports && !scope.module.isModuleImported(symType.declaredModule))
          addedSymbol.isUnimported = true;
        scope.module.markDependencyType(symType);
        return GetStaticTypeSignatureForType(scope.getNamespace(), symType);
      }
      let isTypingSingleIdentifier = node == statement.ast && scope.module.isEditingInside(statement.start_offset + node.start, statement.start_offset + node.end + 2);
      if (isTypingSingleIdentifier || node.maybeTypename) {
        let nsType = typedb2.LookupNamespace(scope.getNamespace(), node.value);
        if (nsType) {
          let symType2 = ASSymbolType.Namespace;
          let addedSymbol = AddIdentifierSymbol(scope, statement, node, symType2, null, nsType.getQualifiedNamespace());
          scope.module.markDependencyNamespace(nsType);
          return null;
        }
      }
      if (node.value == "auto") {
        AddIdentifierSymbol(scope, statement, node, ASSymbolType.Typename, null, "auto");
        return null;
      }
      if (parseContext.allow_errors) {
        let hasPotentialCompletions = false;
        if (scope.module.isEditingNode(statement, node)) {
          hasPotentialCompletions = CheckIdentifierIsPrefixForValidSymbol(scope, statement, parseContext, node.value, typedb2.DBAllowSymbol.PropertiesAndFunctions);
        }
        AddUnknownSymbol(scope, statement, node, hasPotentialCompletions);
        scope.module.markDependencyIdentifier(node.value);
      }
      return null;
    }
    function DetectSymbolFromNamespacedIdentifier(scope, statement, identifier, allow_errors = true, symbol_type) {
      if (!identifier)
        return false;
      if (identifier.value.indexOf("::") == -1)
        return false;
      let scopes = identifier.value.split("::");
      let nsName = "";
      for (let i = 0; i < scopes.length - 1; ++i) {
        if (i != 0)
          nsName += "::";
        nsName += scopes[i];
      }
      let refType = typedb2.LookupType(scope.getNamespace(), nsName.trim());
      let namespace = typedb2.LookupNamespace(scope.getNamespace(), nsName.trim());
      if (!refType && !namespace)
        return false;
      let nsSymbol = AddIdentifierSymbol(scope, statement, {
        start: identifier.start,
        end: identifier.start + nsName.length,
        value: nsName
      }, ASSymbolType.Namespace, null, null);
      if (refType && (namespace || refType.isEnum)) {
        nsSymbol.type = ASSymbolType.Typename;
        nsSymbol.symbol_name = refType.name;
      } else {
        nsSymbol.symbol_name = namespace.getQualifiedNamespace();
      }
      let findName = identifier.value.substr(nsName.length + 2).trim();
      let identifierNode = {
        start: identifier.start + nsName.length + 2,
        end: identifier.end,
        value: findName
      };
      if (refType && refType.isEnum) {
        let usedSymbol = refType.findFirstSymbol(findName, symbol_type);
        if (usedSymbol) {
          let symType = usedSymbol instanceof typedb2.DBProperty ? ASSymbolType.MemberVariable : ASSymbolType.MemberFunction;
          AddIdentifierSymbol(scope, statement, identifierNode, symType, usedSymbol.containingType, usedSymbol.name);
          scope.module.markDependencySymbol(usedSymbol);
          return true;
        }
      } else {
        let usedSymbol = namespace.findFirstSymbol(findName, symbol_type);
        if (usedSymbol) {
          let symType = usedSymbol instanceof typedb2.DBProperty ? ASSymbolType.GlobalVariable : ASSymbolType.GlobalFunction;
          AddIdentifierSymbol(scope, statement, identifierNode, symType, namespace.getQualifiedNamespace(), usedSymbol.name);
          scope.module.markDependencySymbol(usedSymbol);
          return true;
        }
        if (typedb2.AllowsProperties(symbol_type)) {
          let getAccessor = namespace.findFirstSymbol("Get" + findName, typedb2.DBAllowSymbol.Functions);
          if (getAccessor && getAccessor instanceof typedb2.DBMethod) {
            AddIdentifierSymbol(scope, statement, identifierNode, ASSymbolType.GlobalAccessor, namespace.getQualifiedNamespace(), getAccessor.name);
            scope.module.markDependencyFunction(getAccessor);
            return true;
          }
          let setAccessor = namespace.findFirstSymbol("Set" + findName, typedb2.DBAllowSymbol.Functions);
          if (setAccessor && setAccessor instanceof typedb2.DBMethod && setAccessor.isProperty && setAccessor.args.length != 0) {
            AddIdentifierSymbol(scope, statement, identifierNode, ASSymbolType.GlobalAccessor, namespace.getQualifiedNamespace(), setAccessor.name);
            scope.module.markDependencyFunction(setAccessor);
            return true;
          }
        }
      }
      if (allow_errors) {
        let hasPotentialCompletions = false;
        if (scope.module.isEditingNode(statement, identifier)) {
          if (refType && refType.isEnum)
            hasPotentialCompletions = CheckIdentifierIsPrefixForValidSymbolInType(scope, statement, refType, findName, typedb2.DBAllowSymbol.PropertiesAndFunctions);
          else
            hasPotentialCompletions = CheckIdentifierIsPrefixForValidSymbolInNamespace(scope, statement, namespace, findName, typedb2.DBAllowSymbol.PropertiesAndFunctions);
        }
        AddUnknownSymbol(scope, statement, identifierNode, hasPotentialCompletions);
        scope.module.markDependencyIdentifier(identifierNode.value);
      }
      return true;
    }
    function DetectSymbolFromDelegateBindFunctionName(scope, statement, parseContext, delegateBind) {
      let insideType = ResolveTypeFromExpression(scope, delegateBind.node_object);
      let nameNode = delegateBind.node_name;
      if (nameNode && (nameNode.type == exports2.node_types.ConstName || nameNode.type == exports2.node_types.ConstString) && insideType) {
        let funcName = nameNode.value;
        let symbolOffset = 1;
        if (nameNode.type == exports2.node_types.ConstName) {
          symbolOffset = 2;
          funcName = funcName.substring(2, funcName.length - 1);
        } else {
          funcName = funcName.substring(1, funcName.length - 1);
        }
        let foundFunc = insideType.findFirstSymbol(funcName, typedb2.DBAllowSymbol.Functions);
        if (!foundFunc) {
          if (!scope.module.isEditingNode(statement, nameNode)) {
            AddUnknownSymbol(scope, statement, {
              value: funcName,
              start: nameNode.start + symbolOffset,
              end: nameNode.end - 1
            }, false);
          }
        } else {
          let symbol = AddIdentifierSymbol(scope, statement, nameNode, ASSymbolType.MemberFunction, foundFunc.containingType.name, foundFunc.name);
          if (symbol) {
            symbol.start += symbolOffset;
            symbol.end -= 1;
            symbol.noColor = true;
          }
        }
      }
    }
    function CheckIdentifierIsPrefixForValidSymbol(scope, statement, parseContext, identifierPrefix, symbol_type) {
      if (identifierPrefix.length < 2)
        return true;
      if (typedb2.AllowsProperties(symbol_type)) {
        let checkscope = scope;
        while (checkscope && checkscope.isInFunctionBody()) {
          for (let usedVariable of checkscope.variables) {
            if (usedVariable.name.startsWith(identifierPrefix))
              return true;
          }
          checkscope = checkscope.parentscope;
        }
      }
      let insideType = scope.getParentType();
      if (insideType) {
        let usedSymbol = insideType.findFirstSymbolWithPrefix(identifierPrefix, symbol_type);
        if (usedSymbol)
          return true;
        if (typedb2.AllowsProperties(symbol_type)) {
          let getAccessor = insideType.findFirstSymbolWithPrefix("Get" + identifierPrefix, typedb2.DBAllowSymbol.Functions);
          if (getAccessor && getAccessor instanceof typedb2.DBMethod)
            return true;
          let setAccessor = insideType.findFirstSymbol("Set" + identifierPrefix, typedb2.DBAllowSymbol.Functions);
          if (setAccessor && setAccessor instanceof typedb2.DBMethod && setAccessor.isProperty && setAccessor.args.length != 0)
            return true;
        }
      }
      if (typedb2.HasTypeWithPrefix(scope.getNamespace(), identifierPrefix))
        return true;
      for (let kw of exports2.ASKeywords) {
        if (kw.startsWith(identifierPrefix))
          return true;
      }
      if (parseContext.argumentFunction && parseContext.argumentFunction.args) {
        for (let arg of parseContext.argumentFunction.args) {
          if (arg.name.startsWith(identifierPrefix))
            return true;
        }
      }
      {
        let prefixed = typedb2.LookupGlobalSymbolsWithPrefix(scope.getNamespace(), identifierPrefix);
        if (prefixed) {
          for (let func of prefixed) {
            if (func instanceof typedb2.DBMethod && typedb2.AllowsFunctions(symbol_type) && (!func.isLocal || !func.declaredModule || func.declaredModule == scope.module.modulename)) {
              if (!func.isMixin || insideType && func.args.length != 0 && insideType.inheritsFrom(func.args[0].typename))
                return true;
            }
            if (func instanceof typedb2.DBProperty && typedb2.AllowsProperties(symbol_type))
              return true;
          }
        }
      }
      let namespaces = typedb2.LookupNamespacesWithPrefix(scope.getNamespace(), identifierPrefix);
      if (namespaces && namespaces.length != 0)
        return true;
      if (typedb2.AllowsProperties(symbol_type)) {
        let getAccessors = typedb2.LookupGlobalSymbolsWithPrefix(scope.getNamespace(), "Get" + identifierPrefix, typedb2.DBAllowSymbol.Functions);
        if (getAccessors) {
          for (let func of getAccessors) {
            if (func instanceof typedb2.DBMethod && func.isProperty && !func.isMixin && (!func.isLocal || !func.declaredModule || func.declaredModule == scope.module.modulename))
              return true;
          }
        }
        let setAccessors = typedb2.LookupGlobalSymbolsWithPrefix(scope.getNamespace(), "Set" + identifierPrefix, typedb2.DBAllowSymbol.Functions);
        if (setAccessors) {
          for (let func of setAccessors) {
            if (func instanceof typedb2.DBMethod && func.isProperty && !func.isMixin && (!func.isLocal || !func.declaredModule || func.declaredModule == scope.module.modulename))
              return true;
          }
        }
      }
      return false;
    }
    function DetectSymbolsInType(scope, statement, inSymbol, node, parseContext, symbol_type) {
      if (!inSymbol)
        return null;
      let dbtype = null;
      if (inSymbol instanceof typedb2.DBType)
        dbtype = inSymbol;
      else if (inSymbol instanceof typedb2.DBProperty)
        dbtype = typedb2.LookupType(inSymbol.namespace, inSymbol.typename);
      if (!dbtype)
        return null;
      let symType = ASSymbolType.UnknownError;
      let usedSymbol;
      if (parseContext.isResolvingFunction)
        usedSymbol = dbtype.findFunctionSymbolByParameterCount(node.value, parseContext.functionPassedParameterCount);
      else
        usedSymbol = dbtype.findFirstSymbol(node.value, symbol_type);
      if (usedSymbol) {
        if (usedSymbol instanceof typedb2.DBProperty)
          symType = ASSymbolType.MemberVariable;
        else
          symType = ASSymbolType.MemberFunction;
        let identifierSym = AddIdentifierSymbol(scope, statement, node, symType, usedSymbol.containingType, usedSymbol.name);
        scope.module.markDependencySymbol(usedSymbol);
        return usedSymbol;
      }
      if (typedb2.AllowsProperties(symbol_type)) {
        let getAccessor = dbtype.findFirstSymbol("Get" + node.value, typedb2.DBAllowSymbol.Functions);
        if (getAccessor && getAccessor instanceof typedb2.DBMethod) {
          symType = ASSymbolType.MemberAccessor;
          let identifierSym = AddIdentifierSymbol(scope, statement, node, symType, getAccessor.containingType, getAccessor.name);
          scope.module.markDependencyFunction(getAccessor);
          return typedb2.LookupType(getAccessor.namespace, getAccessor.returnType);
        }
        let setAccessor = dbtype.findFirstSymbol("Set" + node.value, typedb2.DBAllowSymbol.Functions);
        if (setAccessor && setAccessor instanceof typedb2.DBMethod && setAccessor.isProperty && setAccessor.args.length != 0) {
          symType = ASSymbolType.MemberAccessor;
          let identifierSym = AddIdentifierSymbol(scope, statement, node, symType, setAccessor.containingType, setAccessor.name);
          scope.module.markDependencyFunction(setAccessor);
          return typedb2.LookupType(setAccessor.namespace, setAccessor.args[0].typename);
        }
      }
      if (typedb2.AllowsFunctions(symbol_type)) {
        let mixinFunctions = typedb2.LookupGlobalSymbol(scope.getNamespace(), node.value, typedb2.DBAllowSymbol.Mixins);
        if (mixinFunctions) {
          for (let symbol of mixinFunctions) {
            if (symbol instanceof typedb2.DBMethod) {
              if (!symbol.isMixin)
                continue;
              if (symbol.args.length != 0 && dbtype.inheritsFrom(symbol.args[0].typename)) {
                let addedSym = AddIdentifierSymbol(scope, statement, node, ASSymbolType.GlobalFunction, symbol.namespace.getQualifiedNamespace(), symbol.name);
                if (!ScriptSettings.automaticImports && symbol.declaredModule && !scope.module.isModuleImported(symbol.declaredModule))
                  addedSym.isUnimported = true;
                scope.module.markDependencyFunction(symbol);
                return symbol;
              }
            }
          }
        }
      }
      if (parseContext.allow_errors) {
        let hasPotentialCompletions = false;
        if (scope.module.isEditingNode(statement, node)) {
          hasPotentialCompletions = CheckIdentifierIsPrefixForValidSymbolInType(scope, statement, dbtype, node.value, typedb2.DBAllowSymbol.PropertiesAndFunctions);
        }
        AddUnknownSymbol(scope, statement, node, hasPotentialCompletions);
        scope.module.markDependencyIdentifier(node.value);
      }
      return null;
    }
    function CheckIdentifierIsPrefixForValidSymbolInType(scope, statement, dbtype, identifierPrefix, symbol_type) {
      if (identifierPrefix.length < 2)
        return true;
      let usedSymbol = dbtype.findFirstSymbolWithPrefix(identifierPrefix, symbol_type);
      if (usedSymbol)
        return true;
      if (typedb2.AllowsProperties(symbol_type)) {
        let getAccessor = dbtype.findFirstSymbolWithPrefix("Get" + identifierPrefix, typedb2.DBAllowSymbol.Functions);
        if (getAccessor && getAccessor instanceof typedb2.DBMethod)
          return true;
        let setAccessor = dbtype.findFirstSymbolWithPrefix("Set" + identifierPrefix, typedb2.DBAllowSymbol.Functions);
        if (setAccessor && setAccessor instanceof typedb2.DBMethod && setAccessor.isProperty && setAccessor.args.length != 0)
          return true;
      }
      if (typedb2.AllowsFunctions(symbol_type)) {
        let mixinFunctions = typedb2.LookupGlobalSymbolsWithPrefix(scope.getNamespace(), identifierPrefix, typedb2.DBAllowSymbol.Mixins);
        if (mixinFunctions) {
          for (let usedSymbol2 of mixinFunctions) {
            if (usedSymbol2 instanceof typedb2.DBMethod) {
              if (!usedSymbol2.isMixin)
                continue;
              if (usedSymbol2.isLocal && usedSymbol2.declaredModule && usedSymbol2.declaredModule != scope.module.modulename)
                continue;
              if (usedSymbol2.args.length != 0 && dbtype.inheritsFrom(usedSymbol2.args[0].typename)) {
                return true;
              }
            }
          }
        }
      }
      return false;
    }
    function DetectSymbolsInNamespace(scope, statement, namespace, node, parseContext, symbol_type) {
      if (!namespace)
        return null;
      let symType = ASSymbolType.UnknownError;
      let usedSymbol = namespace.findFirstSymbol(node.value, symbol_type);
      if (usedSymbol) {
        if (usedSymbol instanceof typedb2.DBType) {
          let identifierSym = AddIdentifierSymbol(scope, statement, node, ASSymbolType.Typename, null, usedSymbol.name);
          if (!ScriptSettings.automaticImports && usedSymbol.declaredModule && !scope.module.isModuleImported(usedSymbol.declaredModule))
            identifierSym.isUnimported = true;
          scope.module.markDependencyType(usedSymbol);
          if (!parseContext.isResolvingFunction)
            return GetStaticTypeSignatureForType(scope.getNamespace(), usedSymbol);
          else
            return usedSymbol;
        } else {
          if (usedSymbol instanceof typedb2.DBProperty)
            symType = ASSymbolType.GlobalVariable;
          else
            symType = ASSymbolType.GlobalFunction;
          let identifierSym = AddIdentifierSymbol(scope, statement, node, symType, usedSymbol.namespace.getQualifiedNamespace(), usedSymbol.name);
          if (!ScriptSettings.automaticImports && usedSymbol.declaredModule && !scope.module.isModuleImported(usedSymbol.declaredModule))
            identifierSym.isUnimported = true;
          scope.module.markDependencySymbol(usedSymbol);
          return usedSymbol;
        }
      }
      if (typedb2.AllowsProperties(symbol_type)) {
        let getAccessor = namespace.findFirstSymbol("Get" + node.value, typedb2.DBAllowSymbol.Functions);
        if (getAccessor && getAccessor instanceof typedb2.DBMethod) {
          symType = ASSymbolType.GlobalAccessor;
          let identifierSym = AddIdentifierSymbol(scope, statement, node, symType, getAccessor.namespace.getQualifiedNamespace(), getAccessor.name);
          if (!ScriptSettings.automaticImports && getAccessor.declaredModule && !scope.module.isModuleImported(getAccessor.declaredModule))
            identifierSym.isUnimported = true;
          scope.module.markDependencyFunction(getAccessor);
          return typedb2.LookupType(getAccessor.namespace, getAccessor.returnType);
        }
        let setAccessor = namespace.findFirstSymbol("Set" + node.value, typedb2.DBAllowSymbol.Functions);
        if (setAccessor && setAccessor instanceof typedb2.DBMethod && setAccessor.isProperty && setAccessor.args.length != 0) {
          symType = ASSymbolType.GlobalAccessor;
          let identifierSym = AddIdentifierSymbol(scope, statement, node, symType, setAccessor.namespace.getQualifiedNamespace(), setAccessor.name);
          if (!ScriptSettings.automaticImports && getAccessor.declaredModule && !scope.module.isModuleImported(setAccessor.declaredModule))
            identifierSym.isUnimported = true;
          scope.module.markDependencyFunction(setAccessor);
          return typedb2.LookupType(setAccessor.namespace, setAccessor.args[0].typename);
        }
      }
      if (parseContext.allow_errors) {
        let hasPotentialCompletions = false;
        if (scope.module.isEditingNode(statement, node)) {
          hasPotentialCompletions = CheckIdentifierIsPrefixForValidSymbolInNamespace(scope, statement, namespace, node.value, typedb2.DBAllowSymbol.PropertiesAndFunctions);
        }
        AddUnknownSymbol(scope, statement, node, hasPotentialCompletions);
        scope.module.markDependencyIdentifier(node.value);
      }
      return null;
    }
    function CheckIdentifierIsPrefixForValidSymbolInNamespace(scope, statement, namespace, identifierPrefix, symbol_type) {
      if (identifierPrefix.length < 2)
        return true;
      let usedSymbol = namespace.findFirstSymbolWithPrefix(identifierPrefix, symbol_type, true);
      if (usedSymbol)
        return true;
      if (typedb2.AllowsProperties(symbol_type)) {
        let getAccessor = namespace.findFirstSymbolWithPrefix("Get" + identifierPrefix, typedb2.DBAllowSymbol.Functions, true);
        if (getAccessor && getAccessor instanceof typedb2.DBMethod)
          return true;
        let setAccessor = namespace.findFirstSymbolWithPrefix("Set" + identifierPrefix, typedb2.DBAllowSymbol.Functions, true);
        if (setAccessor && setAccessor instanceof typedb2.DBMethod && setAccessor.isProperty && setAccessor.args.length != 0)
          return true;
      }
      let childNS = namespace.findChildNamespacesWithPrefix(identifierPrefix);
      if (childNS)
        return true;
      return false;
    }
    var re_equalsspecifier = /^(.*)=\s*$/;
    var re_formatspecifier = /^(.*)=?:(.?[=<>^])?[0-9dxXbconeEfFgG,+-\.%#\s]*$/;
    function DetectFormatStringSymbols(scope, statement, node, parseContext) {
      let expressions = new Array();
      let offsets = new Array();
      let index = 2;
      let count = node.value.length;
      let expressionStart = -1;
      for (; index < count; ++index) {
        let char = node.value[index];
        if (expressionStart == -1) {
          if (char == "{") {
            if (index + 1 < count && node.value[index + 1] == "{") {
              index += 1;
              continue;
            } else {
              expressionStart = index + 1;
            }
          }
        } else {
          if (char == "}") {
            expressions.push(node.value.substring(expressionStart, index));
            offsets.push(expressionStart);
            expressionStart = -1;
          }
        }
      }
      if (expressionStart != -1 && expressionStart < count - 1) {
        expressions.push(node.value.substring(expressionStart, count - 1));
        offsets.push(expressionStart);
      }
      for (let i = 0; i < expressions.length; ++i) {
        let match = expressions[i].match(re_equalsspecifier);
        if (match) {
          expressions[i] = match[1];
        } else {
          match = expressions[i].match(re_formatspecifier);
          if (match) {
            expressions[i] = match[1];
          }
        }
        let fakeStatement = new ASStatement();
        fakeStatement.content = expressions[i];
        fakeStatement.start_offset = statement.start_offset + node.start + offsets[i];
        fakeStatement.end_offset = fakeStatement.start_offset + fakeStatement.content.length;
        fakeStatement.rawIndex = scope.module.rawStatements.length;
        scope.module.rawStatements.push(fakeStatement);
        let fromCache = GetCachedStatementParse(scope.module, ASScopeType.Code, fakeStatement, fakeStatement.rawIndex);
        if (!fromCache) {
          ParseStatement(ASScopeType.Code, fakeStatement);
          scope.module.parsedStatementCount += 1;
        } else {
          scope.module.loadedFromCacheCount += 1;
        }
        if (fakeStatement.ast)
          DetectNodeSymbols(scope, fakeStatement, fakeStatement.ast, parseContext, typedb2.DBAllowSymbol.Properties);
      }
    }
    function ParseScopeIntoStatements(scope) {
      let module3 = scope.module;
      let length = scope.end_offset - scope.start_offset;
      scope.parsed = true;
      let depth_brace = 0;
      let depth_paren = 0;
      let scope_start = -1;
      let statement_start = scope.start_offset;
      let log_start = statement_start;
      let cur_offset = scope.start_offset;
      let in_preprocessor_directive = false;
      let in_line_comment = false;
      let in_block_comment = false;
      let in_dq_string = false;
      let in_sq_string = false;
      let in_escape_sequence = false;
      let cur_element = null;
      function finishElement(element) {
        if (!scope.element_head)
          scope.element_head = element;
        element.previous = cur_element;
        if (cur_element)
          cur_element.next = element;
        cur_element = element;
      }
      function finishStatement(endsWithSemicolon) {
        if (statement_start != cur_offset) {
          let content = module3.content.substring(statement_start, cur_offset);
          if (content.length != 0 && !/^[ \t\r\n]*$/.test(content)) {
            let statement = new ASStatement();
            statement.content = content;
            statement.start_offset = statement_start;
            statement.end_offset = cur_offset;
            statement.endsWithSemicolon = endsWithSemicolon;
            scope.statements.push(statement);
            statement.rawIndex = scope.module.rawStatements.length;
            scope.module.rawStatements.push(statement);
            finishElement(statement);
          }
        }
        statement_start = cur_offset + 1;
      }
      function restartStatement() {
        statement_start = cur_offset + 1;
      }
      for (; cur_offset < scope.end_offset; ++cur_offset) {
        let curchar = scope.module.content[cur_offset];
        if (curchar == "\n") {
          if (in_preprocessor_directive)
            in_preprocessor_directive = false;
          if (in_line_comment)
            in_line_comment = false;
          continue;
        }
        if (in_line_comment)
          continue;
        if (in_block_comment) {
          if (curchar == "/" && scope.module.content[cur_offset - 1] == "*") {
            in_block_comment = false;
          }
          continue;
        }
        if (in_sq_string) {
          if (!in_escape_sequence && curchar == "'") {
            in_sq_string = false;
          }
          if (curchar == "\\")
            in_escape_sequence = !in_escape_sequence;
          else
            in_escape_sequence = false;
          continue;
        }
        if (in_dq_string) {
          if (!in_escape_sequence && curchar == '"') {
            in_dq_string = false;
          }
          if (curchar == "\\")
            in_escape_sequence = !in_escape_sequence;
          else
            in_escape_sequence = false;
          continue;
        }
        if (in_preprocessor_directive)
          continue;
        if (curchar == '"') {
          in_dq_string = true;
          continue;
        }
        if (curchar == "'") {
          in_sq_string = true;
          continue;
        }
        if (curchar == "/" && cur_offset + 1 < scope.end_offset && scope.module.content[cur_offset + 1] == "/") {
          in_line_comment = true;
          continue;
        }
        if (curchar == "/" && cur_offset + 1 < scope.end_offset && scope.module.content[cur_offset + 1] == "*") {
          in_block_comment = true;
          continue;
        }
        if (curchar == "#" && depth_brace == 0) {
          in_preprocessor_directive = true;
          continue;
        }
        if (curchar == "{") {
          if (depth_brace == 0) {
            finishStatement(false);
            scope_start = cur_offset;
            depth_paren = 0;
          }
          depth_brace += 1;
        } else if (curchar == "}") {
          if (depth_brace == 0) {
            continue;
          }
          depth_brace -= 1;
          if (depth_brace == 0) {
            let subscope = new ASScope();
            subscope.parentscope = scope;
            subscope.module = scope.module;
            subscope.start_offset = scope_start + 1;
            subscope.end_offset = cur_offset;
            scope.scopes.push(subscope);
            finishElement(subscope);
            scope_start = null;
            restartStatement();
          }
        }
        if (depth_brace != 0)
          continue;
        if (curchar == "(") {
          depth_paren += 1;
        } else if (curchar == ")") {
          depth_paren -= 1;
          if (depth_paren < 0)
            depth_paren = 0;
        }
        if ((curchar == "." || curchar == ":") && depth_paren == 0 && scope.module.isEditingInside(cur_offset - 16, cur_offset + 1) && cur_offset + 1 < scope.end_offset) {
          let nextchar = scope.module.content[cur_offset + 1];
          if (nextchar == "\r" || nextchar == "\n") {
            cur_offset += 1;
            finishStatement(false);
          }
        }
        if (curchar == ";" && depth_paren == 0)
          finishStatement(true);
      }
      finishStatement(false);
      for (let subscope of scope.scopes)
        ParseScopeIntoStatements(subscope);
    }
    function DetermineScopeType(scope) {
      if (scope.parentscope) {
        if (scope.parentscope.scopetype == ASScopeType.Function || scope.parentscope.scopetype == ASScopeType.LiteralAsset) {
          scope.scopetype = ASScopeType.Code;
          return;
        }
        scope.scopetype = scope.parentscope.scopetype;
      } else {
        scope.scopetype = ASScopeType.Global;
      }
      if (scope.previous && scope.previous instanceof ASStatement) {
        if (scope.previous.ast) {
          let ast_type = scope.previous.ast.type;
          if (ast_type == exports2.node_types.ClassDefinition) {
            scope.scopetype = ASScopeType.Class;
          } else if (ast_type == exports2.node_types.StructDefinition) {
            scope.scopetype = ASScopeType.Class;
          } else if (ast_type == exports2.node_types.EnumDefinition) {
            scope.scopetype = ASScopeType.Enum;
          } else if (ast_type == exports2.node_types.NamespaceDefinition) {
            scope.scopetype = ASScopeType.Namespace;
          } else if (ast_type == exports2.node_types.FunctionDecl) {
            scope.scopetype = ASScopeType.Function;
          } else if (ast_type == exports2.node_types.ConstructorDecl) {
            scope.scopetype = ASScopeType.Function;
          } else if (ast_type == exports2.node_types.DestructorDecl) {
            scope.scopetype = ASScopeType.Function;
          } else if (ast_type == exports2.node_types.AssetDefinition) {
            scope.scopetype = ASScopeType.LiteralAsset;
          }
        }
      }
    }
    function GetCachedStatementParse(module3, scopetype, statement, rawIndex) {
      if (!module3.cachedStatements)
        return false;
      if (rawIndex >= module3.cachedStatements.length)
        return false;
      let cachedStatement = module3.cachedStatements[rawIndex];
      if (cachedStatement && cachedStatement.parsed && cachedStatement.parsedType == scopetype && cachedStatement.content == statement.content) {
        statement.ast = cachedStatement.ast;
        statement.parsed = true;
        statement.parseError = cachedStatement.parseError;
        statement.parsedType = cachedStatement.parsedType;
        return true;
      }
      if (rawIndex + 1 < module3.cachedStatements.length) {
        cachedStatement = module3.cachedStatements[rawIndex + 1];
        if (cachedStatement && cachedStatement.parsed && cachedStatement.parsedType == scopetype && cachedStatement.content == statement.content) {
          statement.parsed = true;
          statement.parseError = cachedStatement.parseError;
          statement.parsedType = cachedStatement.parsedType;
          statement.ast = cachedStatement.ast;
          return true;
        }
      }
      if (rawIndex > 0) {
        cachedStatement = module3.cachedStatements[rawIndex - 1];
        if (cachedStatement && cachedStatement.parsed && cachedStatement.parsedType == scopetype && cachedStatement.content == statement.content) {
          statement.parsed = true;
          statement.parseError = cachedStatement.parseError;
          statement.parsedType = cachedStatement.parsedType;
          statement.ast = cachedStatement.ast;
          return true;
        }
      }
      return false;
    }
    function ParseAllStatements(scope, debug = false) {
      DetermineScopeType(scope);
      for (let i = 0, count = scope.statements.length; i < count; ++i) {
        let statement = scope.statements[i];
        if (!statement)
          continue;
        let fromCache = GetCachedStatementParse(scope.module, scope.scopetype, statement, statement.rawIndex);
        if (!fromCache) {
          ParseStatement(scope.scopetype, statement, debug);
          scope.module.parsedStatementCount += 1;
        } else {
          scope.module.loadedFromCacheCount += 1;
        }
        let trySplit = false;
        let allowNoSplit = false;
        if (!statement.ast) {
          if (scope.module.isEditingInside(statement.start_offset, statement.end_offset)) {
            trySplit = true;
          }
        }
        if (!trySplit && statement.ast && statement.ast.type == exports2.node_types.VariableDecl && scope.module.isEditingInside(statement.start_offset, statement.end_offset)) {
          let startLine = scope.module.getPosition(statement.start_offset).line;
          let endLine = scope.module.getPosition(statement.end_offset).line;
          if (startLine != endLine && scope.module.getPosition(scope.module.lastEditStart).line < endLine) {
            trySplit = true;
            allowNoSplit = true;
          }
        }
        if (trySplit) {
          let splitContent = SplitStatementBasedOnEdit(statement.content, scope.module.lastEditStart - statement.start_offset, allowNoSplit);
          if (splitContent && splitContent.length != 0) {
            let orig_start = statement.start_offset;
            let orig_end = statement.end_offset;
            statement.content = splitContent[0];
            statement.end_offset = statement.start_offset + statement.content.length;
            statement.parsed = false;
            let fromCache2 = GetCachedStatementParse(scope.module, scope.scopetype, statement, statement.rawIndex);
            if (!fromCache2) {
              ParseStatement(scope.scopetype, statement, debug);
              scope.module.parsedStatementCount += 1;
            } else {
              scope.module.loadedFromCacheCount += 1;
            }
            let splitOffset = statement.end_offset;
            let prevStatement = statement;
            for (let splitIndex = 1; splitIndex < splitContent.length; ++splitIndex) {
              if (!splitContent[splitIndex])
                continue;
              let newStatement = new ASStatement();
              newStatement.content = splitContent[splitIndex];
              newStatement.start_offset = splitOffset;
              newStatement.end_offset = splitOffset + newStatement.content.length;
              newStatement.previous = prevStatement;
              newStatement.next = prevStatement.next;
              if (prevStatement.next)
                prevStatement.next.previous = newStatement;
              prevStatement.next = newStatement;
              scope.statements.push(newStatement);
              let fromCache3 = GetCachedStatementParse(scope.module, scope.scopetype, newStatement, statement.rawIndex);
              if (!fromCache3) {
                ParseStatement(scope.scopetype, newStatement, debug);
                scope.module.parsedStatementCount += 1;
              } else {
                scope.module.loadedFromCacheCount += 1;
              }
            }
          }
        }
      }
      for (let subscope of scope.scopes)
        ParseAllStatements(subscope, debug);
    }
    function SplitStatementBasedOnEdit(content, editOffset, allowNoSplit) {
      let length = content.length;
      let in_preprocessor_directive = false;
      let in_line_comment = false;
      let in_block_comment = false;
      let in_dq_string = false;
      let in_sq_string = false;
      let in_escape_sequence = false;
      let depth_brace = 0;
      let depth_paren = 0;
      let depth_squarebracket = 0;
      for (let splitIndex = 0; splitIndex < length; ++splitIndex) {
        let curchar = content[splitIndex];
        if (curchar == "\n") {
          if (in_preprocessor_directive)
            in_preprocessor_directive = false;
          if (in_line_comment)
            in_line_comment = false;
        }
        if (in_line_comment)
          continue;
        if (in_block_comment) {
          if (curchar == "/" && content[splitIndex - 1] == "*") {
            in_block_comment = false;
          }
          continue;
        }
        if (in_sq_string) {
          if (!in_escape_sequence && curchar == "'") {
            in_sq_string = false;
          }
          if (curchar == "\\")
            in_escape_sequence = !in_escape_sequence;
          else
            in_escape_sequence = false;
          continue;
        }
        if (in_dq_string) {
          if (!in_escape_sequence && curchar == '"') {
            in_dq_string = false;
          }
          if (curchar == "\\")
            in_escape_sequence = !in_escape_sequence;
          else
            in_escape_sequence = false;
          continue;
        }
        if (in_preprocessor_directive)
          continue;
        if (curchar == '"') {
          in_dq_string = true;
          continue;
        }
        if (curchar == "'") {
          in_sq_string = true;
          continue;
        }
        if (curchar == "/" && splitIndex + 1 < length && content[splitIndex + 1] == "/") {
          in_line_comment = true;
          continue;
        }
        if (curchar == "/" && splitIndex + 1 < length && content[splitIndex + 1] == "*") {
          in_block_comment = true;
          continue;
        }
        if (curchar == "#" && depth_brace == 0) {
          in_preprocessor_directive = true;
          continue;
        }
        if (curchar == "{")
          depth_brace += 1;
        else if (curchar == "}")
          depth_brace -= 1;
        if (curchar == "(")
          depth_paren += 1;
        else if (curchar == ")")
          depth_paren -= 1;
        if (curchar == "[")
          depth_squarebracket += 1;
        else if (curchar == "]")
          depth_squarebracket -= 1;
        if (splitIndex >= editOffset && curchar == "\n" && depth_brace == 0 && depth_paren == 0 && depth_squarebracket == 0) {
          return [
            content.substring(0, splitIndex + 1),
            content.substring(splitIndex + 1)
          ];
        }
      }
      if (allowNoSplit && depth_brace == 0 && depth_paren == 0 && depth_squarebracket == 0) {
        return [
          content,
          null
        ];
      }
      for (let splitIndex = editOffset; splitIndex < length; ++splitIndex) {
        let curchar = content[splitIndex];
        if (curchar == "\n") {
          return [
            content.substring(0, splitIndex + 1),
            content.substring(splitIndex + 1)
          ];
        }
      }
      return null;
    }
    function ParseStatement(scopetype, statement, debug = false) {
      statement.parsed = true;
      statement.ast = null;
      statement.parsedType = scopetype;
      let startRule = null;
      switch (scopetype) {
        default:
        case ASScopeType.Global:
        case ASScopeType.Namespace:
          startRule = "start_global";
          break;
        case ASScopeType.Class:
          startRule = "start_class";
          break;
        case ASScopeType.Enum:
          startRule = "start_enum";
          break;
        case ASScopeType.Function:
        case ASScopeType.LiteralAsset:
        case ASScopeType.Code:
          startRule = "start";
          break;
      }
      let precedesBlock = statement.next && statement.next instanceof ASScope;
      let parseError = false;
      try {
        statement.ast = PEGGY_GRAMMAR.parse(statement.content, {
          startRule,
          precedesBlock,
          endsWithSemicolon: statement.endsWithSemicolon
        });
        statement.parseError = false;
      } catch (error) {
        if (debug) {
          console.log("Error Parsing Statement: ");
          console.log(statement.content);
          console.log(error);
        }
        parseError = true;
        statement.parseError = true;
      }
    }
    exports2.ParseStatement = ParseStatement;
  }
});

// unreal-angelscript-lsp/language-server/out/specifiers.js
var require_specifiers = __commonJS({
  "unreal-angelscript-lsp/language-server/out/specifiers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ASFunctionSubSpecifiers = exports2.ASFunctionSpecifiers_NO_HAZE = exports2.ASFunctionSpecifiers_HAZE = exports2.ASFunctionSpecifiers = exports2.ASStructSubSpecifiers = exports2.ASStructSpecifiers = exports2.ASClassSubSpecifiers = exports2.ASClassSpecifiers = exports2.ASPropertySubSpecifiers = exports2.ASPropertySpecifiers_NO_HAZE = exports2.ASPropertySpecifiers_HAZE = exports2.ASPropertySpecifiers = void 0;
    exports2.ASPropertySpecifiers = {
      "BlueprintReadWrite": "Allow the property to be read and written from blueprint nodes",
      "BlueprintReadOnly": "Allow the property to be read from blueprint but not written",
      "BlueprintHidden": "Do not make this property available to blueprint at all",
      "EditInstanceOnly": "Property can only be changed on instances in the level",
      "EditDefaultsOnly": "Property can only be changed on defaults inside blueprint classes",
      "EditAnywhere": "Property can be changed by blueprint classes and on instances in the level",
      "NotEditable": "Property cannot be edited from unreal anywhere",
      "NotVisible": "Property cannot be changed or seen in the details panel at all",
      "EditConst": "Property can be seen in the details panel but not edited",
      "VisibleAnywhere": "Property can be seen both on blueprint classes and instances in the level, but not changed",
      "VisibleInstanceOnly": "Property can only be seen on instances in the level, but not changed",
      "VisibleDefaultsOnly": "Property can only be seen on defaults inside blueprint classes, but not changed",
      "AdvancedDisplay": "Property can only be edited after expanding to advanced view",
      "Transient": "Property is never saved into the on-disk asset",
      "Config": "Property can be saved and loaded from config ini files",
      "Interp": "Property can be modified by sequence tracks",
      "AssetRegistrySearchable": "Property is indexed for searching in the Asset Registry",
      "NoClear": "Property is not allowed to be changed to nullptr",
      "Category": "Category to list this under in the editor",
      "Keywords": "Keywords this can be found by in the editor",
      "ToolTip": "Tooltip to show in the editor",
      "DisplayName": "Name to use to display in the editor",
      "EditInline": "Edit the values of this object inline in its container",
      "ExposeOnSpawn": "Property should be available to be changed when spawning this object from blueprint",
      "EditFixedSize": "Use on TArray propertie, the size of the array cannot be changed from the editor",
      "BlueprintProtected": "Treat this property as protected in blueprint, disallowing it from being edited by non-child blueprints",
      "DefaultComponent": "Component will be created as a default component on the actor",
      "OverrideComponent": "Specify a component in the parent class to override the class type of",
      "RootComponent": "Use on DefaultComponents, specify that this component should be the root component of the actor",
      "ShowOnActor": "Use on DefaultComponents, properties from the component will appear in the actor's details panel",
      "Attach": "Use on DefaultComponents, specify a different component to attach this to in the scene hierarchy",
      "AttachSocket": "Use on DefaultComponents with an Attach, specify a socket to attach to on this component's attach parent",
      "Meta": "Specify arbitrary meta tags",
      "Instanced": "The object in this property is a new instance for each containing instance",
      "BlueprintSetter": "Specify a function to call instead when writing this property from blueprint",
      "BlueprintGetter": "Specify a function to call instead when reading this property from blueprint",
      "BindWidget": "Automatically bind this property to the widget with the same name within child UMG blueprints",
      "BindWidgetAnim": "Automatically bind this property to the widget animation with the same name within child UMG blueprints",
      "SaveGame": "Property should be serialized for save games",
      "BindComponent": "Automatically bind this property to the component with the same name within child actor blueprints"
    };
    exports2.ASPropertySpecifiers_HAZE = {};
    exports2.ASPropertySpecifiers_NO_HAZE = {
      "Replicated": "Property should be replicated to clients",
      "ReplicatedUsing": "Specify a function to call when the property is replicated (requires Replicated)",
      "ReplicationCondition": "Specify when the property should be replicated",
      "ReplicationPushModel": "Use Push Model to replicate this property"
    };
    exports2.ASPropertySubSpecifiers = {
      // Note: subspecifier keys should be lowercase so they can be found consistently
      "meta": {
        "InlineEditConditionToggle": "When this boolean is used as an edit condition, display it inline to the left of the conditional property",
        "EditCondition": "Only allow this property to be edited depending on the state of other properties",
        "EditConditionHides": "Hide this property completely when its EditCondition is false",
        "MakeEditWidget": "Create a movable 3D widget in the world for transforms and vectors",
        "ClampMin": "Clamp the numeric value of this property so it is never below the specifiec value",
        "ClampMax": "Clamp the numeric value of this property so it is never below the specifiec value",
        "UIMin": "Set the minimum value for the UI slider for the numeric value of this property",
        "UIMax": "Set the maximum value for the UI slider for the numeric value of this property",
        "Units": "Determine the unit of this property's numeric value for the UI",
        "Delta": "How large is one value step in the UI for the numeric value of this property",
        "ShowOnlyInnerProperties": "Show this property's inner properties as if they are parent-level properties"
      },
      "replicationcondition": {
        "InitialOnly": "This property will only attempt to send on the initial bunch",
        "OwnerOnly": "This property will only send to the actor's owner",
        "SkipOwner": "This property send to every connection EXCEPT the owner",
        "SimulatedOnly": "This property will only send to simulated actors",
        "AutonomousOnly": "This property will only send to autonomous actors",
        "SimulatedOrPhysics": "This property will send to simulated OR bRepPhysics actors",
        "InitialOrOwner": "This property will send on the initial packet, or to the actors owner",
        "Custom": "",
        "ReplayOrOwner": "",
        "ReplayOnly": "",
        "SimulatedOnlyNoReplay": "",
        "SimulatedOrPhysicsNoReplay": "",
        "SkipReplay": ""
      }
    };
    exports2.ASClassSpecifiers = {
      "NotPlaceable": "Class cannot be placed in the level or on an actor by the editor",
      "NotBlueprintable": "Blueprints cannot be choose this as a parent class",
      "Blueprintable": "Blueprints can be created with this as a parent class",
      "Abstract": "Cannot be instantiated on its own, must have a child class to spawn",
      "Transient": "All instances of this class will be transient",
      "HideDropdown": "This class will be hidden from property combo boxes in Editor",
      "Config": "Allow properties in this class to be saved and loaded to the specified ini",
      "Deprecated": "This class is deprecated and should not be used",
      "HideCategories": "Properties in these categories are not editable on this class",
      "DefaultConfig": "Config properties on this class should be saved to default configs, not user configs",
      "ComponentWrapperClass": "Actor is a lightweight wrapper around a single component",
      "ClassGroup": "List this class under the specified group in the editor",
      "DefaultToInstanced": "Indicates that references to this class default to instanced",
      "EditInlineNew": "Class can be constructed from editinline New button",
      "Meta": "Specify arbitrary meta tags"
    };
    exports2.ASClassSubSpecifiers = {
      // Note: subspecifier keys should be lowercase so they can be found consistently
      "meta": {
        "DisplayName": "Name to use to display in the editor"
      }
    };
    exports2.ASStructSpecifiers = {
      "Meta": "Specify arbitrary meta tags"
    };
    exports2.ASStructSubSpecifiers = {
      // Note: subspecifier keys should be lowercase so they can be found consistently
      "meta": {
        "DisplayName": "Name to use to display in the editor"
      }
    };
    exports2.ASFunctionSpecifiers = {
      "BlueprintCallable": "Function can be called from blueprint",
      "NotBlueprintCallable": "Function is not available in blueprint at all",
      "BlueprintPure": "Function is a pure node in blueprint without an exec pin",
      "BlueprintEvent": "Function can be overridden by child blueprint classes",
      "Unreliable": "Network function is sent as unreliable",
      "BlueprintOverride": "Override a BlueprintEvent in a parent script or C++ class",
      "CallInEditor": "Create a button in the details panel to call this function in the editor",
      "Category": "Category to list this under in the editor",
      "Keywords": "Keywords this can be found by in the editor",
      "ToolTip": "Tooltip to show in the editor",
      "DisplayName": "Name to use to display the function in the editor",
      "BlueprintProtected": "Treat this function as protected in blueprint, disallowing it from being called by non-child blueprints",
      "Meta": "Specify arbitrary meta tags"
    };
    exports2.ASFunctionSpecifiers_HAZE = {
      "NetFunction": "Function is a NetFunction",
      "CrumbFunction": "Function is a CrumbFunction",
      "DevFunction": "Function is a DevFunction"
    };
    exports2.ASFunctionSpecifiers_NO_HAZE = {
      "NetMulticast": "The function is executed both locally on the server, and replicated to all clients, regardless of the Actor's NetOwner",
      "Client": "The function is only executed on the only client if called from the server",
      "Server": "The function is only executed on the server if called from the owning client",
      "BlueprintAuthorityOnly": "This function will only execute from Blueprint code if running on a machine with network authority (a server, dedicated server, or single-player game)"
    };
    exports2.ASFunctionSubSpecifiers = {
      // Note: subspecifier keys should be lowercase so they can be found consistently
      "meta": {
        "NoSuperCall": "This function is allowed to not call its Super, suppress the warning",
        "AdvancedDisplay": "Determine which parameters to the function are considered Advanced"
      }
    };
  }
});

// unreal-angelscript-lsp/language-server/out/documentation.js
var require_documentation = __commonJS({
  "unreal-angelscript-lsp/language-server/out/documentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FormatPropertyDocumentation = exports2.FormatFunctionDocumentation = void 0;
    function FormatFunctionDocumentation(doc, dbmethod, activeArg, italicize = true) {
      if (!doc)
        return "";
      let lines = doc.split("\n");
      let result = "";
      for (let line of lines) {
        line = line.trimEnd();
        let trimmed = line.trimStart();
        if (trimmed.startsWith("@param")) {
          let match = trimmed.match(/@param\s+([A-Za-z0-9]+)\s+(.*)/);
          if (match) {
            let argIndex = -1;
            let refArg = null;
            if (dbmethod.args) {
              for (let i = 0, count = dbmethod.args.length; i < count; ++i) {
                if (dbmethod.args[i].name == match[1]) {
                  argIndex = i;
                  refArg = dbmethod.args[i];
                  break;
                }
              }
            }
            if (argIndex >= 0 && activeArg !== null && activeArg == argIndex)
              result += "* **`" + match[1] + "` - " + match[2] + "**\n\n";
            else if (italicize)
              result += "* `" + match[1] + "` - *" + match[2] + "*\n\n";
            else
              result += "* `" + match[1] + "` - " + match[2] + "\n\n";
            continue;
          }
        }
        if (trimmed.startsWith("@return")) {
          if (italicize)
            result += "**Return:** *" + trimmed.substring(7).trim() + "*\n\n";
          else
            result += "**Return:** " + trimmed.substring(7).trim() + "\n\n";
          continue;
        }
        if (trimmed.startsWith("@note")) {
          if (italicize)
            result += "\uFE0F**Note:** *" + trimmed.substring(5).trim() + "*\n\n";
          else
            result += "\u2139**Note:** " + trimmed.substring(5).trim() + "\n\n";
          continue;
        }
        if (trimmed.startsWith("@see")) {
          if (italicize)
            result += "\uFE0F**See:** *" + trimmed.substring(4).trim() + "*\n\n";
          else
            result += "\u2139**See:** " + trimmed.substring(4).trim() + "\n\n";
          continue;
        }
        if (line.length != 0) {
          if (italicize) {
            if (trimmed.length < line.length)
              result += "  *" + trimmed + "*\n\n";
            else
              result += "*" + trimmed + "*\n\n";
          } else {
            if (trimmed.length < line.length)
              result += "  " + trimmed + "\n\n";
            else
              result += trimmed + "\n\n";
          }
        } else
          result += "\n\n";
      }
      return result;
    }
    exports2.FormatFunctionDocumentation = FormatFunctionDocumentation;
    function FormatPropertyDocumentation(doc, italicize = true) {
      if (!doc)
        return "";
      let lines = doc.split("\n");
      let result = "";
      for (let line of lines) {
        line = line.trimEnd();
        let trimmed = line.trimStart();
        if (trimmed.startsWith("@note")) {
          if (italicize)
            result += "\uFE0F**Note:** *" + trimmed.substring(5).trim() + "*\n\n";
          else
            result += "\u2139**Note:** " + trimmed.substring(5).trim() + "\n\n";
          continue;
        }
        if (trimmed.startsWith("@see")) {
          if (italicize)
            result += "\uFE0F**See:** *" + trimmed.substring(4).trim() + "*\n\n";
          else
            result += "\u2139**See:** " + trimmed.substring(4).trim() + "\n\n";
          continue;
        }
        if (line.length != 0) {
          if (italicize) {
            if (trimmed.length < line.length)
              result += "  *" + trimmed + "*\n\n";
            else
              result += "*" + trimmed + "*\n\n";
          } else {
            if (trimmed.length < line.length)
              result += "  " + trimmed + "\n\n";
            else
              result += trimmed + "\n\n";
          }
        } else
          result += "\n\n";
      }
      return result;
    }
    exports2.FormatPropertyDocumentation = FormatPropertyDocumentation;
  }
});

// unreal-angelscript-lsp/language-server/out/parsed_completion.js
var require_parsed_completion = __commonJS({
  "unreal-angelscript-lsp/language-server/out/parsed_completion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GetExpectedTypeAtOffset = exports2.HandleFloatLiteralHelper = exports2.AddMathShortcutCompletions = exports2.Resolve = exports2.isValidModuleDependency = exports2.resolveModuleIsolation = exports2.AddMixinCompletions = exports2.AddCompletionsFromType = exports2.AddCompletionsFromLocalVariables = exports2.AddCompletionsFromClassKeywords = exports2.Signature = exports2.GetDetermineTypeFromArguments = exports2.SortMethodsBasedOnArgumentTypes = exports2.Complete = exports2.RefreshDependencyRestrictions = exports2.GetCompletionSettings = void 0;
    var node_12 = require_node3();
    var typedb2 = require_database();
    var scriptfiles2 = require_as_parser();
    var specifiers = require_specifiers();
    var documentation_1 = require_documentation();
    var path = require("path");
    var CommonTypenames = /* @__PURE__ */ new Set([
      "FVector",
      "FRotator",
      "FTransform",
      "FQuat"
    ]);
    var CommonObjectTypes = /* @__PURE__ */ new Set([
      "AActor",
      "UActorComponent",
      "UObject"
    ]);
    var CommonNamespaces = /* @__PURE__ */ new Set([
      "Math"
    ]);
    var CommonTemplateTypes = /* @__PURE__ */ new Set(["TArray", "TMap", "TSet", "TSubclassOf", "TSoftObjectPtr", "TSoftClassPtr", "TInstigated", "TPerPlayer", "TOptional"]);
    var CompletionSettings = {
      mathCompletionShortcuts: true,
      correctFloatLiteralsWhenExpectingDoublePrecision: false,
      dependencyRestrictions: []
    };
    function GetCompletionSettings() {
      return CompletionSettings;
    }
    exports2.GetCompletionSettings = GetCompletionSettings;
    function RefreshDependencyRestrictions() {
      ResolvedModuleDependencyIsolations.clear();
      IsolateRegexes = [];
      for (let restriction of CompletionSettings.dependencyRestrictions) {
        if (restriction.isolate) {
          let pattern = "^" + restriction.isolate.replace(/\./g, "\\.").replace(/\$/g, "[^.]+");
          IsolateRegexes.push(new RegExp(pattern));
        } else if (restriction.unisolate) {
          let pattern = "^" + restriction.unisolate.replace(/\./g, "\\.").replace(/\$/g, "[^.]+");
          UnisolateRegexes.push(new RegExp(pattern));
        }
      }
    }
    exports2.RefreshDependencyRestrictions = RefreshDependencyRestrictions;
    var FunctionLabelSuffix = "()";
    var FunctionLabelWithParamsSuffix = "(\u2026)";
    var IsolateRegexes = new Array();
    var UnisolateRegexes = new Array();
    var ResolvedModuleDependencyIsolations = /* @__PURE__ */ new Map();
    var Sort;
    (function(Sort2) {
      Sort2.EnumValue_Expected = "1";
      Sort2.EnumName_Expected = "0";
      Sort2.EnumValue_Max_Expected = "2";
      Sort2.Local_Expected = "2";
      Sort2.Local = "4";
      Sort2.Keyword_Expected = "8a";
      Sort2.Keyword = "8b";
      Sort2.ImportModule = "8c";
      Sort2.MemberProp_Direct = "a";
      Sort2.MemberProp_Parent = "c";
      Sort2.MemberProp_Direct_Expected = "6";
      Sort2.MemberProp_Parent_Expected = "7";
      Sort2.Method_Direct_Expected = "8a";
      Sort2.Method_Parent_Expected = "9";
      Sort2.Method_Direct = "b";
      Sort2.Method_Parent = "d";
      Sort2.EnumValue = "h";
      Sort2.EnumValue_Max = "j";
      Sort2.GlobalProp = "j";
      Sort2.GlobalProp_Expected = "d";
      Sort2.Global = "k";
      Sort2.Global_Expected = "d";
      Sort2.Typename_Common = "fa";
      Sort2.Typename_SameFile = "fb";
      Sort2.Typename_NearbyUsage = "fc";
      Sort2.Typename_CommonObject = "fd";
      Sort2.Typename = "fe";
      Sort2.Typename_Expected = "3";
      Sort2.Unimported = "x";
      Sort2.Method_Override_Snippet = "0";
      Sort2.Namespace_Unexpected = "z";
      Sort2.Snippet = "z";
      Sort2.Math_Shortcut = "z";
    })(Sort || (Sort = {}));
    var CompletionContext = class {
      constructor() {
        this.scope = null;
        this.statement = null;
        this.baseStatement = null;
        this.completeOffset = -1;
        this.completingSymbol = null;
        this.completingNode = null;
        this.priorExpression = null;
        this.previousLineContent = null;
        this.priorType = null;
        this.priorTypeWasNamespace = false;
        this.requiresPriorType = false;
        this.completingDot = false;
        this.completingNamespace = false;
        this.completingSymbolLowerCase = null;
        this.completingSymbolGetter = null;
        this.completingSymbolSetter = null;
        this.isRightExpression = false;
        this.isEqualityExpression = false;
        this.rightOperator = null;
        this.isSubExpression = false;
        this.isAssignment = false;
        this.isNamingSomethingNew = false;
        this.isNamingNewClass = false;
        this.isNamingNewStruct = false;
        this.isTypingAccessSpecifier = false;
        this.isIgnoredCode = false;
        this.isIncompleteNamespace = false;
        this.isFunctionDeclaration = false;
        this.isInsideType = false;
        this.expectedType = null;
        this.maybeTypename = false;
        this.typenameExpected = null;
        this.subOuterStatement = null;
        this.subOuterFunctions = null;
        this.subOuterArgumentIndex = -1;
        this.fullOuterStatement = null;
        this.leftStatement = null;
        this.leftType = null;
        this.outerAssignIdentifier = null;
        this.completionsMatchingExpected = [];
        this.havePreselection = false;
        this.forceCaseInsensitive = false;
        this.nearbyTypenames = /* @__PURE__ */ new Set();
      }
      isTypeExpected(typename) {
        if (!this.expectedType)
          return false;
        if (!typename || typename == "void")
          return false;
        if (this.expectedType.name == typename)
          return true;
        let dbtype = typedb2.GetTypeByName(typename);
        if (!dbtype)
          return false;
        return dbtype.inheritsFrom(this.expectedType.name);
      }
    };
    var CompletionExpressionCandidate = class {
      constructor() {
        this.start = -1;
        this.end = -1;
        this.code = null;
        this.isRightExpression = false;
        this.rightOperator = null;
      }
    };
    var CompletionArguments = class {
      constructor() {
        this.isAfterNamedArgument = false;
        this.currentArgumentName = null;
        this.usedArgumentNames = [];
        this.nodesForPositionalArguments = [];
      }
    };
    function Complete(asmodule, position) {
      if (!asmodule)
        return null;
      let completions = new Array();
      let offset = asmodule.getOffset(position);
      let context = GenerateCompletionContext(asmodule, offset - 1);
      if (context.isIgnoredCode)
        return [];
      if (context.isNamingSomethingNew) {
        AddCompletionsForNamingSomethingNew(context, completions);
        return completions;
      }
      if (AddCompletionsFromImportStatement(context, completions))
        return completions;
      if (AddCompletionsFromUnrealMacro(context, completions))
        return completions;
      if (AddCompletionsFromAccessSpecifiers(context, completions))
        return completions;
      if (context.completingSymbol == null)
        return null;
      let searchTypes = new Array();
      let insideType = context.scope ? context.scope.getParentType() : null;
      if (context.priorType) {
        if (context.requiresPriorType) {
          if (context.priorTypeWasNamespace != context.completingNamespace)
            return null;
        }
        searchTypes.push(context.priorType);
      } else if (context.requiresPriorType) {
        return null;
      } else if (context.scope) {
        if (insideType)
          searchTypes.push(insideType);
        let checkNamespace = context.scope.getNamespace();
        while (checkNamespace) {
          searchTypes.push(checkNamespace);
          checkNamespace = checkNamespace.parentNamespace;
        }
        let checkscope = context.scope;
        while (checkscope) {
          if (!checkscope.isInFunctionBody())
            break;
          AddCompletionsFromLocalVariables(context, checkscope, completions);
          checkscope = checkscope.parentscope;
        }
        if (insideType)
          AddCompletionsFromClassKeywords(context, completions);
        AddMathShortcutCompletions(context, completions);
      }
      for (let dbtype of searchTypes) {
        let showEvents = !context.scope || context.scope.scopetype != scriptfiles2.ASScopeType.Class || !insideType;
        AddCompletionsFromType(context, dbtype, completions, showEvents);
      }
      if (context.priorType || !context.isInsideType && context.scope.getParentType()) {
        AddMixinCompletions(context, completions);
      }
      if (!context.isInsideType)
        AddCompletionsFromKeywords(context, completions);
      if (context.isSubExpression && context.subOuterFunctions && !context.isInsideType)
        AddCompletionsFromCallSignature(context, completions);
      if (context.scope && context.scope.scopetype == scriptfiles2.ASScopeType.Class && !context.isRightExpression && !context.isSubExpression && !context.isInsideType) {
        AddMethodOverrideSnippets(context, completions, position);
      }
      AddShortcutCompletions(context, completions);
      AddSuperCallSnippet(context, completions);
      if (!context.havePreselection)
        DeterminePreSelectedCompletion(context);
      if (context.forceCaseInsensitive)
        MakeCompletionsLowerCase(completions);
      return completions;
    }
    exports2.Complete = Complete;
    function MakeCompletionsLowerCase(completions) {
      for (let compl of completions) {
        if (compl.filterText) {
          compl.filterText = compl.filterText.toLowerCase();
        } else {
          let lowercaseLabel = compl.label.toLowerCase();
          if (lowercaseLabel != compl.label)
            compl.filterText = lowercaseLabel;
        }
      }
    }
    function DeterminePreSelectedCompletion(context) {
      if (context.havePreselection)
        return;
      if (context.completionsMatchingExpected.length == 0)
        return;
      if (context.completingSymbol && context.completingSymbol.length != 0) {
        let startWithCompletions = [];
        for (let compl of context.completionsMatchingExpected) {
          let complText = compl.filterText ? compl.filterText : compl.label;
          if (CanCompleteToOnlyStart(context, complText))
            startWithCompletions.push(compl);
        }
        if (startWithCompletions.length != 0)
          context.completionsMatchingExpected = startWithCompletions;
      }
      if (context.completionsMatchingExpected.length == 1) {
        context.completionsMatchingExpected[0].preselect = true;
        context.havePreselection = true;
        return;
      }
      let completionsIdentical = true;
      let identicalText = null;
      for (let compl of context.completionsMatchingExpected) {
        let complText = compl.insertText ? compl.insertText : compl.label;
        if (identicalText == null || complText == identicalText) {
          identicalText = complText;
        } else {
          completionsIdentical = false;
          break;
        }
      }
      if (completionsIdentical) {
        context.havePreselection = true;
        for (let compl of context.completionsMatchingExpected)
          compl.preselect = true;
      }
    }
    function GenerateCompletionArguments(context) {
      let args = new CompletionArguments();
      if (context.fullOuterStatement && context.fullOuterStatement.ast) {
        if (context.fullOuterStatement.ast.type == scriptfiles2.node_types.FunctionCall || context.fullOuterStatement.ast.type == scriptfiles2.node_types.ConstructorCall) {
          let arglist = context.fullOuterStatement.ast.children[1];
          if (arglist && arglist.children) {
            for (let i = 0; i < arglist.children.length; ++i) {
              let argnode = arglist.children[i];
              if (argnode && argnode.type == scriptfiles2.node_types.NamedArgument) {
                if (argnode.children[0])
                  args.usedArgumentNames.push(argnode.children[0].value);
                if (i <= context.subOuterArgumentIndex)
                  args.isAfterNamedArgument = true;
                if (i == context.subOuterArgumentIndex && argnode.children[0])
                  args.currentArgumentName = argnode.children[0].value;
              } else {
                args.nodesForPositionalArguments.push(argnode);
              }
            }
          }
        }
      }
      return args;
    }
    function ScoreTypeMatch(wantedType, providedType) {
      if (wantedType == providedType)
        return 2;
      if (wantedType.isPrimitive && providedType.isPrimitive) {
        if (typedb2.ArePrimitiveTypesEquivalent(wantedType.name, providedType.name))
          return 2;
        let wantedFloat = typedb2.IsPrimitiveFloatType(wantedType.name);
        let providedFloat = typedb2.IsPrimitiveFloatType(providedType.name);
        if (wantedFloat && !providedFloat)
          return 1;
        if (providedFloat && !wantedFloat)
          return 0;
      }
      return -2;
    }
    function ScoreMethodOverload(context, func, argContext) {
      let score = 0;
      let argumentIndex = context.subOuterArgumentIndex;
      let argumentLength = func.args.length;
      let argumentOffset = 0;
      if (func.isMixin) {
        argumentOffset = 1;
        argumentIndex += 1;
      }
      if (argumentIndex >= argumentLength) {
        if (argumentIndex > argumentOffset || context.statement.content && context.statement.content.length > 0)
          score -= 50;
      }
      let activeArg = -1;
      for (let usedName of argContext.usedArgumentNames) {
        let foundArg = -1;
        for (let argIndex = argumentOffset; argIndex < func.args.length; ++argIndex) {
          if (func.args[argIndex].name == usedName) {
            foundArg = argIndex;
            break;
          }
        }
        if (foundArg == -1) {
          if (argContext.currentArgumentName && usedName == argContext.currentArgumentName)
            score -= 100;
          else
            score -= 10;
        } else {
          if (argContext.currentArgumentName && usedName == argContext.currentArgumentName)
            activeArg = foundArg - argumentOffset;
        }
      }
      if (func.isConstructor && (!func.args || func.args.length == 0))
        score -= 1;
      let posArgCount = Math.min(argContext.nodesForPositionalArguments.length, argumentLength - argumentOffset);
      for (let posArg = 0; posArg < posArgCount; ++posArg) {
        let argnode = argContext.nodesForPositionalArguments[posArg];
        let argType = scriptfiles2.ResolveTypeFromExpression(context.scope, argnode);
        if (!argType)
          continue;
        let wantedType = typedb2.LookupType(func.namespace, func.args[posArg].typename);
        if (!wantedType)
          continue;
        score += ScoreTypeMatch(wantedType, argType);
      }
      return [score, activeArg];
    }
    function SortMethodsBasedOnArgumentTypes(methods, asmodule, offset) {
      let context = GenerateCompletionContext(asmodule, offset - 1);
      let argContext = GenerateCompletionArguments(context);
      context.subOuterArgumentIndex = argContext.nodesForPositionalArguments.length - 1;
      let scoredFunctions = new Array();
      for (let func of methods)
        scoredFunctions.push([func, ScoreMethodOverload(context, func, argContext)[0]]);
      scoredFunctions.sort((first, second) => {
        if (first[1] > second[1])
          return -1;
        else if (first[1] < second[1])
          return 1;
        else
          return 0;
      });
      methods.splice(0, methods.length);
      for (let [func, score] of scoredFunctions)
        methods.push(func);
    }
    exports2.SortMethodsBasedOnArgumentTypes = SortMethodsBasedOnArgumentTypes;
    function GetDetermineTypeFromArguments(asmodule, offset, argumentIndex) {
      if (argumentIndex < 0)
        return null;
      let context = GenerateCompletionContext(asmodule, offset - 1);
      let argContext = GenerateCompletionArguments(context);
      if (argContext && argumentIndex < argContext.nodesForPositionalArguments.length) {
        let argnode = argContext.nodesForPositionalArguments[argumentIndex];
        let argType = scriptfiles2.ResolveTypeFromExpression(context.scope, argnode);
        return argType;
      }
      return null;
    }
    exports2.GetDetermineTypeFromArguments = GetDetermineTypeFromArguments;
    function Signature(asmodule, position) {
      if (!asmodule)
        return null;
      let completions = new Array();
      let offset = asmodule.getOffset(position);
      let context = GenerateCompletionContext(asmodule, offset - 1);
      if (!context.subOuterFunctions)
        return null;
      if (context.subOuterFunctions.length == 0)
        return null;
      let argContext = GenerateCompletionArguments(context);
      let sigHelp = {
        signatures: new Array(),
        activeSignature: 0,
        activeParameter: 0
      };
      let bestFunction = -1;
      let bestFunctionScore = 0;
      let bestFunctionActiveArg = -1;
      for (let i = 0; i < context.subOuterFunctions.length; ++i) {
        let func = context.subOuterFunctions[i];
        let determineType = null;
        if (func.determinesOutputTypeArgumentIndex != -1) {
          if (argContext && func.determinesOutputTypeArgumentIndex < argContext.nodesForPositionalArguments.length) {
            let argnode = argContext.nodesForPositionalArguments[func.determinesOutputTypeArgumentIndex];
            determineType = scriptfiles2.ResolveTypeFromExpression(context.scope, argnode);
          }
        }
        let [score, activeArg] = ScoreMethodOverload(context, func, argContext);
        if (score > bestFunctionScore || bestFunction == -1) {
          bestFunctionScore = score;
          bestFunction = i;
          if (argContext.currentArgumentName && activeArg != -1)
            bestFunctionActiveArg = activeArg;
          else if (argContext.isAfterNamedArgument)
            activeArg = bestFunctionActiveArg = -1;
          else
            activeArg = bestFunctionActiveArg = context.subOuterArgumentIndex;
        }
        let skipFirstArg = false;
        if (func.isMixin)
          skipFirstArg = true;
        let params = new Array();
        if (func.args) {
          for (let a = skipFirstArg ? 1 : 0; a < func.args.length; ++a) {
            if (determineType && a == func.determinesOutputTypeArgumentIndex) {
              params.push({
                label: func.args[a].format(determineType.name)
              });
            } else {
              params.push({
                label: func.args[a].format()
              });
            }
          }
        }
        let sig = {
          label: func.format(null, skipFirstArg, false, null, determineType),
          parameters: params
        };
        let doc = func.findAvailableDocumentation(true, false);
        if (doc) {
          sig.documentation = {
            kind: node_12.MarkupKind.Markdown,
            value: (0, documentation_1.FormatFunctionDocumentation)(doc, func, activeArg)
          };
        }
        sigHelp.signatures.push(sig);
      }
      if (bestFunction != -1) {
        sigHelp.activeSignature = bestFunction;
        sigHelp.activeParameter = bestFunctionActiveArg;
      }
      return sigHelp.signatures.length == 0 ? null : sigHelp;
    }
    exports2.Signature = Signature;
    function AddCompletionsFromCallSignature(context, completions) {
      if (context.subOuterFunctions.length == 0)
        return;
      let argContext = GenerateCompletionArguments(context);
      let activeMethod = null;
      let bestScore = 0;
      for (let func of context.subOuterFunctions) {
        let [score, activeArg] = ScoreMethodOverload(context, func, argContext);
        if (score > bestScore || !activeMethod) {
          activeMethod = func;
          bestScore = score;
        }
      }
      if (activeMethod.args) {
        let completeDefinition = false;
        if (context.scope && activeMethod.containingType && context.isFunctionDeclaration) {
          let typeOfScope = context.scope ? context.scope.getParentType() : null;
          if (typeOfScope != null && typeOfScope.canOverrideFromParent(activeMethod.name)) {
            completeDefinition = true;
            let supertype = typeOfScope.getSuperType();
            if (supertype) {
              let supersymbol = supertype.findFirstSymbol(activeMethod.name, typedb2.DBAllowSymbol.Functions);
              if (supersymbol instanceof typedb2.DBMethod)
                activeMethod = supersymbol;
            }
          }
        }
        if (completeDefinition) {
          let argumentIndex = context.subOuterArgumentIndex;
          if (activeMethod.isMixin)
            argumentIndex += 1;
          if (argumentIndex < activeMethod.args.length) {
            let arg = activeMethod.args[argumentIndex];
            let complStr = arg.typename + " " + arg.name;
            if (CanCompleteTo(context, complStr)) {
              completions.push({
                label: complStr,
                documentation: {
                  kind: node_12.MarkupKind.Markdown,
                  value: "```angelscript_snippet\n" + complStr + "\n\n```"
                },
                kind: node_12.CompletionItemKind.Snippet,
                sortText: Sort.Snippet
              });
            }
          }
        } else {
          for (let arg of activeMethod.args) {
            if (argContext.usedArgumentNames.indexOf(arg.name) != -1)
              continue;
            let complStr = arg.name + " =";
            if (CanCompleteTo(context, complStr)) {
              completions.push({
                label: complStr,
                insertText: complStr + " ",
                documentation: {
                  kind: node_12.MarkupKind.Markdown,
                  value: "```angelscript_snippet\n" + complStr + "\n\n```"
                },
                kind: node_12.CompletionItemKind.Snippet,
                sortText: Sort.Snippet
              });
            }
          }
        }
      }
    }
    function AddCompletionsFromKeywordList(context, keywords, completions, expectedIf = null) {
      for (let kw of keywords) {
        if (CanCompleteTo(context, kw)) {
          completions.push({
            label: kw,
            kind: node_12.CompletionItemKind.Keyword,
            sortText: context.isTypeExpected(expectedIf) ? Sort.Keyword_Expected : Sort.Keyword
          });
        }
      }
    }
    function AddCompletionsFromSpecifiers(context, specifiers2, completions) {
      for (let spec in specifiers2) {
        if (!context.completingSymbol || CanCompleteTo(context, spec)) {
          completions.push({
            label: spec,
            documentation: specifiers2[spec],
            kind: node_12.CompletionItemKind.Keyword,
            sortText: Sort.Keyword
          });
        }
      }
    }
    function AddCompletionsForNamingSomethingNew(context, completions) {
      if (!context.scope)
        return false;
      if (!context.scope.module)
        return false;
      let filebasename = path.basename(context.scope.module.filename, ".as");
      let proposedNames = [];
      if (context.isNamingNewClass) {
        proposedNames.push("U" + filebasename);
        proposedNames.push("A" + filebasename);
      } else if (context.isNamingNewStruct) {
        proposedNames.push("F" + filebasename);
      }
      if (proposedNames.length == 0)
        return false;
      for (let proposed of proposedNames) {
        if (!CanCompleteToOnlyStart(context, proposed))
          continue;
        let hasType = false;
        for (let existingType of context.scope.module.types) {
          if (existingType.name == proposed) {
            hasType = true;
            break;
          }
        }
        if (hasType)
          continue;
        completions.push({
          label: proposed,
          kind: node_12.CompletionItemKind.Text
        });
      }
      return true;
    }
    function AddCompletionsFromImportStatement(context, completions) {
      if (context.statement && context.statement.ast && context.statement.ast.type == scriptfiles2.node_types.ImportStatement) {
        let complString = "";
        if (context.completingSymbol)
          complString = context.completingSymbol;
        let untilDot = "";
        let dotPos = complString.lastIndexOf(".");
        if (dotPos != -1)
          untilDot = complString.substr(0, dotPos + 1);
        for (let asmodule of scriptfiles2.GetAllLoadedModules()) {
          if (CanCompleteStringTo(complString, asmodule.modulename)) {
            completions.push({
              label: asmodule.modulename,
              kind: node_12.CompletionItemKind.File,
              filterText: asmodule.modulename.substr(untilDot.length),
              insertText: asmodule.modulename.substr(untilDot.length),
              sortText: Sort.ImportModule
            });
          }
        }
        return true;
      }
      return false;
    }
    function AddCompletionsFromUnrealMacro(context, completions) {
      if (context.isSubExpression) {
        if (context.outerAssignIdentifier) {
          let subspecifiers = [];
          let isInsideMacro = false;
          let macroContent = null;
          if (context.baseStatement.ast && context.baseStatement.ast.macro) {
            let macro_start = context.baseStatement.start_offset + context.baseStatement.ast.macro.start;
            let macro_end = context.baseStatement.start_offset + context.baseStatement.ast.macro.end;
            if (context.completeOffset >= macro_start && context.completeOffset < macro_end) {
              isInsideMacro = true;
              macroContent = context.baseStatement.content.substring(context.baseStatement.ast.macro.start, context.baseStatement.ast.macro.end);
            }
          }
          let isPropertySpec = false;
          if (/[\r\n\s]*UPROPERTY\s*\(.*\)[\r\n\s]*$/.test(context.baseStatement.content)) {
            subspecifiers.push(specifiers.ASPropertySubSpecifiers);
            isPropertySpec = true;
          } else if (/[\r\n\s]*UFUNCTION\s*\(.*\)[\r\n\s]*$/.test(context.baseStatement.content)) {
            subspecifiers.push(specifiers.ASFunctionSubSpecifiers);
          } else if (/[\r\n\s]*UCLASS\s*\(.*\)[\r\n\s]*$/.test(context.baseStatement.content)) {
            subspecifiers.push(specifiers.ASClassSubSpecifiers);
          } else if (/[\r\n\s]*USTRUCT\s*\(.*\)[\r\n\s]*$/.test(context.baseStatement.content)) {
            subspecifiers.push(specifiers.ASStructSubSpecifiers);
          } else if (isInsideMacro && /^\s*UPROPERTY\s*\(/.test(macroContent)) {
            subspecifiers.push(specifiers.ASPropertySubSpecifiers);
            isPropertySpec = true;
          } else if (isInsideMacro && /^\s*UFUNCTION\s*\(/.test(macroContent)) {
            subspecifiers.push(specifiers.ASFunctionSubSpecifiers);
          } else if (isInsideMacro && /^\s*UCLASS\s*\(/.test(macroContent)) {
            subspecifiers.push(specifiers.ASClassSubSpecifiers);
          } else if (isInsideMacro && /^\s*USTRUCT\s*\(/.test(macroContent)) {
            subspecifiers.push(specifiers.ASStructSubSpecifiers);
          }
          let foundSubSpecifier = false;
          let lowerIdentifier = context.outerAssignIdentifier.toLowerCase();
          for (let sublist of subspecifiers) {
            if (lowerIdentifier in sublist) {
              foundSubSpecifier = true;
              AddCompletionsFromSpecifiers(context, sublist[lowerIdentifier], completions);
            }
          }
          if (isPropertySpec && lowerIdentifier == "attach") {
            let dbtype = context.scope.getDatabaseType();
            if (dbtype && dbtype.inheritsFrom("AActor")) {
              dbtype.forEachSymbol(function(sym) {
                if (!(sym instanceof typedb2.DBProperty))
                  return;
                let prop = sym;
                if (!prop.declaredModule)
                  return;
                let propType = typedb2.LookupType(prop.namespace, prop.typename);
                if (!propType)
                  return;
                if (!propType.inheritsFrom("USceneComponent"))
                  return;
                if (!prop.macroSpecifiers || !prop.macroSpecifiers.has("DefaultComponent"))
                  return;
                if (!context.completingSymbol || CanCompleteTo(context, prop.name)) {
                  let documentation = "Attach this component to " + prop.name;
                  if (prop.documentation)
                    documentation += ":\n" + prop.documentation;
                  completions.push({
                    label: prop.name,
                    documentation,
                    kind: node_12.CompletionItemKind.Field,
                    sortText: Sort.Keyword
                  });
                }
              });
              foundSubSpecifier = true;
            }
          }
          if (foundSubSpecifier)
            return true;
        }
        if (/^\s*UCLASS\s*$/.test(context.subOuterStatement.content)) {
          AddCompletionsFromSpecifiers(context, specifiers.ASClassSpecifiers, completions);
          return true;
        }
        if (/^\s*USTRUCT\s*$/.test(context.subOuterStatement.content)) {
          AddCompletionsFromSpecifiers(context, specifiers.ASStructSpecifiers, completions);
          return true;
        }
        if (/^\s*UPROPERTY\s*$/.test(context.subOuterStatement.content)) {
          AddCompletionsFromSpecifiers(context, specifiers.ASPropertySpecifiers, completions);
          if (scriptfiles2.GetScriptSettings().useAngelscriptHaze)
            AddCompletionsFromSpecifiers(context, specifiers.ASPropertySpecifiers_HAZE, completions);
          else
            AddCompletionsFromSpecifiers(context, specifiers.ASPropertySpecifiers_NO_HAZE, completions);
          return true;
        }
        if (/^\s*UFUNCTION\s*$/.test(context.subOuterStatement.content)) {
          AddCompletionsFromSpecifiers(context, specifiers.ASFunctionSpecifiers, completions);
          if (scriptfiles2.GetScriptSettings().useAngelscriptHaze)
            AddCompletionsFromSpecifiers(context, specifiers.ASFunctionSpecifiers_HAZE, completions);
          else
            AddCompletionsFromSpecifiers(context, specifiers.ASFunctionSpecifiers_NO_HAZE, completions);
          return true;
        }
      }
      return false;
    }
    function AddCompletionsFromKeywords(context, completions) {
      let inFunctionBody = !context.scope || context.scope.isInFunctionBody();
      let scopeType = context.scope ? context.scope.getParentType() : null;
      let isInClass = context.scope && context.scope.scopetype == scriptfiles2.ASScopeType.Class && scopeType && !scopeType.isStruct;
      let isInStruct = context.scope && context.scope.scopetype == scriptfiles2.ASScopeType.Class && scopeType && scopeType.isStruct;
      let isInSwitch = false;
      let isInLoop = false;
      let checkScope = context.scope;
      while (checkScope) {
        if (checkScope.previous && checkScope.previous instanceof scriptfiles2.ASStatement) {
          let heading = checkScope.previous;
          if (heading.ast) {
            if (heading.ast.type == scriptfiles2.node_types.SwitchStatement) {
              isInSwitch = true;
            } else if (heading.ast.type == scriptfiles2.node_types.ForLoop || heading.ast.type == scriptfiles2.node_types.ForEachLoop || heading.ast.type == scriptfiles2.node_types.WhileLoop) {
              isInLoop = true;
            }
          }
        }
        if (checkScope.element_head && checkScope.element_head instanceof scriptfiles2.ASStatement) {
          let heading = checkScope.element_head;
          if (heading.ast) {
            if (heading.ast.type == scriptfiles2.node_types.ForLoop || heading.ast.type == scriptfiles2.node_types.ForEachLoop) {
              isInLoop = true;
              break;
            }
          }
        }
        checkScope = checkScope.parentscope;
      }
      AddCompletionsFromKeywordList(context, [
        "auto"
      ], completions);
      if (context.isRightExpression || context.isSubExpression) {
        AddCompletionsFromKeywordList(context, [
          "true",
          "false"
        ], completions, "bool");
        AddCompletionsFromKeywordList(context, [
          "nullptr"
        ], completions, "UObject");
        if (context.expectedType && !context.expectedType.isValueType()) {
          AddCompletionsFromKeywordList(context, [
            "Cast"
          ], completions);
        }
      }
      if (!context.isRightExpression && !context.isSubExpression) {
        AddCompletionsFromKeywordList(context, [
          "const"
        ], completions);
        if (isInSwitch) {
          if (CanCompleteTo(context, "case")) {
            completions.push({
              label: "case",
              kind: node_12.CompletionItemKind.Keyword,
              commitCharacters: [" "],
              sortText: Sort.Keyword
            });
          }
          if (CanCompleteTo(context, "fallthrough")) {
            completions.push({
              label: "fallthrough",
              kind: node_12.CompletionItemKind.Keyword,
              commitCharacters: [";"],
              sortText: Sort.Keyword
            });
          }
        }
        if (isInClass || isInSwitch) {
          if (CanCompleteTo(context, "default")) {
            completions.push({
              label: "default",
              kind: node_12.CompletionItemKind.Keyword,
              commitCharacters: [" ", ":"],
              sortText: Sort.Keyword
            });
          }
        }
      }
      if ((!context.scope || context.scope.scopetype == scriptfiles2.ASScopeType.Global || context.scope.scopetype == scriptfiles2.ASScopeType.Namespace) && (!context.isSubExpression && !context.isRightExpression)) {
        AddCompletionsFromKeywordList(context, [
          "delegate",
          "event",
          "class",
          "struct",
          "property"
        ], completions);
        if (CanCompleteTo(context, "UCLASS")) {
          completions.push({
            label: "UCLASS",
            kind: node_12.CompletionItemKind.Keyword,
            commitCharacters: ["("],
            sortText: Sort.Keyword
          });
        }
        if (CanCompleteTo(context, "USTRUCT")) {
          completions.push({
            label: "USTRUCT",
            kind: node_12.CompletionItemKind.Keyword,
            commitCharacters: ["("],
            sortText: Sort.Keyword
          });
        }
        if (CanCompleteToOnlyStart(context, "UENUM")) {
          completions.push({
            label: "UENUM",
            kind: node_12.CompletionItemKind.Keyword,
            commitCharacters: ["("],
            sortText: Sort.Keyword
          });
        }
      }
      if (context.scope && inFunctionBody) {
        if (!context.isRightExpression && !context.isSubExpression) {
          AddCompletionsFromKeywordList(context, [
            "if",
            "else",
            "while",
            "for",
            "switch"
          ], completions);
          if (isInLoop) {
            if (CanCompleteTo(context, "continue")) {
              completions.push({
                label: "continue",
                kind: node_12.CompletionItemKind.Keyword,
                commitCharacters: [";"],
                sortText: Sort.Keyword
              });
            }
          }
          if (isInSwitch || isInLoop) {
            if (CanCompleteTo(context, "break")) {
              completions.push({
                label: "break",
                kind: node_12.CompletionItemKind.Keyword,
                commitCharacters: [";"],
                sortText: Sort.Keyword
              });
            }
          }
          completions.push({
            label: "return",
            kind: node_12.CompletionItemKind.Keyword,
            commitCharacters: [" ", ";"],
            sortText: Sort.Keyword
          });
        }
      } else {
        if (!context.isRightExpression && !context.isSubExpression) {
          AddCompletionsFromKeywordList(context, [
            "void"
          ], completions);
        }
      }
      if (context.scope && context.scope.scopetype == scriptfiles2.ASScopeType.Class || context.baseStatement && context.baseStatement.ast && context.baseStatement.ast.type == scriptfiles2.node_types.FunctionDecl && context.scope.getParentType()) {
        if (!context.isRightExpression && !context.isSubExpression) {
          AddCompletionsFromKeywordList(context, [
            "override",
            "final",
            "property",
            "private",
            "protected",
            "access"
          ], completions);
          if (CanCompleteToOnlyStart(context, "UPROPERTY")) {
            if (!/[\r\n\s]*(UFUNCTION|UPROPERTY)\s*\(/.test(context.previousLineContent)) {
              completions.push({
                label: "UPROPERTY",
                kind: node_12.CompletionItemKind.Keyword,
                commitCharacters: ["("],
                sortText: Sort.Keyword
              });
              context.forceCaseInsensitive = true;
            }
          }
        }
        let scopeType2 = context.scope.getParentType();
        if (scopeType2 && !scopeType2.isStruct) {
          if (!context.isRightExpression && !context.isSubExpression) {
            if (CanCompleteToOnlyStart(context, "UFUNCTION")) {
              if (!/[\r\n\s]*(UFUNCTION|UPROPERTY)\s*\(/.test(context.previousLineContent)) {
                completions.push({
                  label: "UFUNCTION",
                  kind: node_12.CompletionItemKind.Keyword,
                  commitCharacters: ["("],
                  sortText: Sort.Keyword
                });
                context.forceCaseInsensitive = true;
              }
            }
          }
        }
      } else if (context.scope && context.scope.scopetype == scriptfiles2.ASScopeType.Global || context.scope.scopetype == scriptfiles2.ASScopeType.Namespace || context.baseStatement && context.baseStatement.ast && context.baseStatement.ast.type == scriptfiles2.node_types.FunctionDecl && !context.scope.getParentType()) {
        if (!context.isRightExpression && !context.isSubExpression) {
          AddCompletionsFromKeywordList(context, [
            "mixin",
            "property"
          ], completions);
          if (CanCompleteToOnlyStart(context, "UFUNCTION")) {
            if (!/[\r\n\s]*(UFUNCTION|UPROPERTY)\s*\(/.test(context.previousLineContent)) {
              completions.push({
                label: "UFUNCTION",
                kind: node_12.CompletionItemKind.Keyword,
                commitCharacters: ["("],
                sortText: Sort.Keyword
              });
              context.forceCaseInsensitive = true;
            }
          }
        }
      }
    }
    function GetTypenameCommitChars(context, typename, commitChars) {
      if (context.maybeTypename) {
        if (CommonTypenames.has(typename))
          commitChars.push(" ");
        if (CommonTemplateTypes.has(typename))
          commitChars.push("<");
      }
    }
    function AddShortcutCompletions(context, completions) {
      if (context.isInsideType || context.isIncompleteNamespace)
        return;
      if (CanCompleteTo(context, "FMath")) {
        let OldNamespace = typedb2.LookupNamespace(null, "FMath");
        let MathNamespace = typedb2.LookupNamespace(null, "Math");
        if (MathNamespace && !OldNamespace) {
          let commitChars = [":"];
          GetTypenameCommitChars(context, "FMath", commitChars);
          completions.push({
            label: "Math",
            kind: node_12.CompletionItemKind.Module,
            data: ["namespace", "Math"],
            commitCharacters: commitChars,
            insertText: "Math",
            filterText: "FMath",
            sortText: Sort.Typename
          });
        }
      }
    }
    function AddCompletionsFromClassKeywords(context, completions) {
      let insideType = context.scope.getParentType();
      if (!insideType)
        return;
      if (CanCompleteTo(context, "this")) {
        completions.push({
          label: "this",
          labelDetails: {
            description: insideType.name
          },
          kind: node_12.CompletionItemKind.Keyword,
          commitCharacters: [".", ";", ","],
          sortText: context.isTypeExpected(insideType.name) ? Sort.Keyword_Expected : Sort.Keyword
        });
      }
      if (context.scope.isInFunctionBody() && CanCompleteTo(context, "Super")) {
        let supertype = insideType.getSuperType();
        if (supertype && supertype.declaredModule) {
          completions.push({
            label: "Super",
            labelDetails: {
              description: insideType.supertype
            },
            kind: node_12.CompletionItemKind.Keyword,
            commitCharacters: [":"],
            sortText: Sort.Keyword
          });
        }
      }
    }
    exports2.AddCompletionsFromClassKeywords = AddCompletionsFromClassKeywords;
    function AddCompletionsFromLocalVariables(context, scope, completions) {
      for (let asvar of scope.variables) {
        if (CanCompleteTo(context, asvar.name)) {
          let complItem = {
            label: asvar.name,
            labelDetails: {
              description: asvar.typename
            },
            kind: node_12.CompletionItemKind.Variable,
            commitCharacters: [".", ";", ","],
            sortText: Sort.Local
          };
          if (context.isTypeExpected(asvar.typename)) {
            context.completionsMatchingExpected.push(complItem);
            complItem.sortText = Sort.Local_Expected;
          }
          completions.push(complItem);
        }
      }
    }
    exports2.AddCompletionsFromLocalVariables = AddCompletionsFromLocalVariables;
    function AddCompletionsFromType(context, curtype, completions, showEvents = true) {
      let scopeType = context.scope ? context.scope.getParentType() : null;
      let props = /* @__PURE__ */ new Set();
      let expectedSubclassOf = null;
      if (context.expectedType && context.expectedType.templateBaseType && context.expectedType.templateBaseType == "TSubclassOf") {
        if (context.expectedType.templateSubTypes && context.expectedType.templateSubTypes[0])
          expectedSubclassOf = context.expectedType.templateSubTypes[0];
      } else if (context.expectedType && context.expectedType.name == "UClass") {
        expectedSubclassOf = "UObject";
      }
      let propertyIndex = 0;
      curtype.forEachSymbol(function(symbol) {
        if (symbol instanceof typedb2.DBProperty) {
          if (!CanCompleteSymbol(context, symbol))
            return;
          let prop = symbol;
          propertyIndex += 1;
          if (!isPropertyAccessibleFromScope(curtype, prop, context.scope))
            return;
          props.add(prop.name);
          let compl = {
            label: prop.name,
            kind: node_12.CompletionItemKind.Field,
            labelDetails: {
              description: prop.typename
            },
            commitCharacters: [".", ";", ","],
            filterText: GetSymbolFilterText(context, prop)
          };
          if (prop.containingType) {
            if (prop.containingType.isEnum) {
              let sortNumber = propertyIndex.toString().padStart(3, "0");
              if (prop.name.includes("MAX"))
                compl.sortText = Sort.EnumValue_Max + sortNumber;
              else
                compl.sortText = Sort.EnumValue + sortNumber;
            } else if (prop.containingType == scopeType)
              compl.sortText = Sort.MemberProp_Direct;
            else
              compl.sortText = Sort.MemberProp_Parent;
            compl.data = ["prop", prop.containingType.name, prop.name];
          } else {
            compl.sortText = Sort.GlobalProp;
            compl.data = ["global_prop", prop.namespace.getQualifiedNamespace(), prop.name];
          }
          if (context.isTypeExpected(prop.typename)) {
            if (prop.containingType || !prop.namespace.isRootNamespace())
              context.completionsMatchingExpected.push(compl);
            if (prop.containingType && prop.containingType.isEnum) {
              let sortNumber = propertyIndex.toString().padStart(3, "0");
              if (prop.name.includes("MAX"))
                compl.sortText = Sort.EnumValue_Max_Expected + sortNumber;
              else
                compl.sortText = Sort.EnumValue_Expected + sortNumber;
            } else if (prop.containingType && prop.containingType == scopeType)
              compl.sortText = Sort.MemberProp_Direct_Expected;
            else if (prop.containingType)
              compl.sortText = Sort.MemberProp_Parent_Expected;
            else
              compl.sortText = Sort.GlobalProp_Expected;
          }
          if (context.isIncompleteNamespace)
            compl.insertText = ":" + compl.label;
          completions.push(compl);
        } else if (symbol instanceof typedb2.DBMethod) {
          let func = symbol;
          if (func.isMixin)
            return;
          if (!CanCompleteSymbol(context, func))
            return;
          if (!isFunctionAccessibleFromScope(curtype, func, context.scope))
            return;
          if (func.isOverride || func.isBlueprintOverride)
            return;
          if (!func.isCallable)
            return;
          if (func.isTemplateInstantiation && func.containingType != curtype)
            return;
          if (func.isConstructor && (context.maybeTypename || expectedSubclassOf && !func.returnType.startsWith("TSubclassOf")))
            return;
          if (func.isProperty) {
            if (func.name.startsWith("Get")) {
              let propname = func.name.substring(3);
              if (!props.has(propname) && func.args.length == 0) {
                let compl = {
                  label: propname,
                  kind: node_12.CompletionItemKind.Field,
                  labelDetails: {
                    description: func.returnType
                  },
                  commitCharacters: [".", ";", ","],
                  filterText: GetSymbolFilterText(context, func)
                };
                if (func.containingType) {
                  if (func.containingType == scopeType)
                    compl.sortText = Sort.MemberProp_Direct;
                  else
                    compl.sortText = Sort.MemberProp_Parent;
                  compl.data = ["accessor", func.containingType.name, propname];
                } else {
                  compl.sortText = Sort.GlobalProp;
                  compl.data = ["global_accessor", func.namespace.getQualifiedNamespace(), propname];
                }
                if (context.isTypeExpected(func.returnType)) {
                  if (func.containingType || !func.namespace.isRootNamespace())
                    context.completionsMatchingExpected.push(compl);
                  if (func.containingType && func.containingType == scopeType)
                    compl.sortText = Sort.MemberProp_Direct_Expected;
                  else if (func.containingType)
                    compl.sortText = Sort.MemberProp_Parent_Expected;
                  else
                    compl.sortText = Sort.GlobalProp_Expected;
                }
                if (context.isIncompleteNamespace)
                  compl.insertText = ":" + compl.label;
                completions.push(compl);
                props.add(propname);
              }
            }
            if (func.name.startsWith("Set")) {
              let propname = func.name.substring(3);
              if (!props.has(propname) && func.args.length == 1 && func.returnType == "void") {
                let compl = {
                  label: propname,
                  kind: node_12.CompletionItemKind.Field,
                  labelDetails: {
                    description: func.args[0].typename
                  },
                  commitCharacters: [".", ";", ","],
                  filterText: GetSymbolFilterText(context, func),
                  sortText: func.containingType == scopeType ? "a" : "b"
                };
                if (func.containingType) {
                  if (func.containingType == scopeType)
                    compl.sortText = Sort.MemberProp_Direct;
                  else
                    compl.sortText = Sort.MemberProp_Parent;
                  compl.data = ["accessor", func.containingType.name, propname];
                } else {
                  compl.sortText = Sort.GlobalProp;
                  compl.data = ["global_accessor", func.namespace.getQualifiedNamespace(), propname];
                }
                if (context.isTypeExpected(func.args[0].typename)) {
                  if (func.containingType || !func.namespace.isRootNamespace())
                    context.completionsMatchingExpected.push(compl);
                  if (func.containingType && func.containingType == scopeType)
                    compl.sortText = Sort.MemberProp_Direct_Expected;
                  else if (func.containingType)
                    compl.sortText = Sort.MemberProp_Parent_Expected;
                  else
                    compl.sortText = Sort.GlobalProp_Expected;
                }
                if (context.isIncompleteNamespace)
                  compl.insertText = ":" + compl.label;
                completions.push(compl);
                props.add(propname);
              }
            }
          }
          if (!func.name.startsWith("op") && (!func.isBlueprintEvent || showEvents)) {
            let commitChars = ["("];
            if (func.isConstructor)
              GetTypenameCommitChars(context, func.name, commitChars);
            let compl = {
              label: func.name,
              kind: func.isBlueprintEvent ? node_12.CompletionItemKind.Event : node_12.CompletionItemKind.Method,
              commitCharacters: commitChars,
              filterText: GetSymbolFilterText(context, func),
              sortText: func.containingType == scopeType ? "a" : "b"
            };
            if (func.containingType) {
              if (func.containingType == scopeType)
                compl.sortText = Sort.Method_Direct;
              else
                compl.sortText = Sort.Method_Parent;
              compl.data = ["func", func.containingType.name, func.name, func.id];
            } else {
              compl.sortText = Sort.Global;
              compl.data = ["global_func", func.namespace.getQualifiedNamespace(), func.name, func.id];
            }
            if (context.isTypeExpected(func.returnType)) {
              if (func.containingType || !func.namespace.isRootNamespace() || func.isConstructor)
                context.completionsMatchingExpected.push(compl);
              if (func.containingType && func.containingType == scopeType)
                compl.sortText = Sort.Method_Direct_Expected;
              else if (func.containingType)
                compl.sortText = Sort.Method_Parent_Expected;
              else
                compl.sortText = Sort.Global_Expected;
            }
            if (context.isIncompleteNamespace)
              compl.insertText = ":" + compl.label;
            compl.labelDetails = {
              detail: func.args && func.args.length > 0 ? FunctionLabelWithParamsSuffix : FunctionLabelSuffix
            };
            compl.command = {
              title: "",
              command: "angelscript.paren"
            };
            if (func.returnType && func.returnType != "void") {
              if (func.determinesOutputTypeArgumentIndex != -1)
                compl.labelDetails.description = "auto";
              else
                compl.labelDetails.description = func.returnType;
              if (!typedb2.IsPrimitive(func.returnType))
                compl.commitCharacters.push(".");
            }
            completions.push(compl);
          }
        } else if (symbol instanceof typedb2.DBType) {
          let dbtype = symbol;
          if (dbtype.isTemplateInstantiation)
            return;
          let kind = node_12.CompletionItemKind.Class;
          if (dbtype.isEnum) {
            if (context.isInsideType && !context.priorTypeWasNamespace)
              return;
            if (expectedSubclassOf)
              return;
          } else {
            if (context.isInsideType && !context.priorTypeWasNamespace)
              return;
            if (!context.maybeTypename && !expectedSubclassOf && (context.isSubExpression || context.isRightExpression) && !dbtype.isPrimitive)
              return;
          }
          if (dbtype.isEnum) {
            if (!isTypeAccessibleFromScope(dbtype, context.scope))
              return;
            let canCompleteEnum = CanCompleteSymbol(context, dbtype);
            if (context.isSubExpression && !context.isFunctionDeclaration || context.isRightExpression) {
              if (context.expectedType == dbtype) {
                let enumIndex = 0;
                dbtype.forEachSymbol(function(sym) {
                  if (!(sym instanceof typedb2.DBProperty))
                    return;
                  enumIndex += 1;
                  let enumvalue = sym;
                  let canCompleteValue = CanCompleteTo(context, enumvalue.name);
                  if (!canCompleteEnum && !canCompleteValue)
                    return;
                  let enumstr = dbtype.name + "::" + enumvalue.name;
                  let complItem = {
                    label: enumstr,
                    kind: node_12.CompletionItemKind.EnumMember,
                    data: ["enum", dbtype.name, enumvalue.name]
                  };
                  let isMaxValue = enumvalue.name.includes("MAX");
                  let sortNumber = enumIndex.toString().padStart(3, "0");
                  if (context.expectedType == dbtype) {
                    if (isMaxValue) {
                      complItem.sortText = Sort.EnumValue_Max_Expected + sortNumber;
                    } else {
                      complItem.preselect = true;
                      complItem.sortText = Sort.EnumValue_Expected + sortNumber;
                      context.havePreselection = true;
                    }
                  } else {
                    if (isMaxValue)
                      complItem.sortText = Sort.EnumValue_Max + sortNumber;
                    else
                      complItem.sortText = Sort.EnumValue + sortNumber;
                  }
                  if (context.isIncompleteNamespace)
                    complItem.insertText = ":" + complItem.label;
                  if (canCompleteEnum)
                    completions.push(complItem);
                  if (canCompleteValue && context.expectedType == dbtype && !isMaxValue) {
                    completions.push({
                      ...complItem,
                      filterText: enumvalue.name
                    });
                  }
                });
              }
            }
            if (canCompleteEnum) {
              if (!context.expectedType || !context.expectedType.isEnum || context.expectedType == dbtype) {
                let commitChars = [];
                if (!context.isIncompleteNamespace)
                  commitChars.push(":");
                let complItem = {
                  label: dbtype.name,
                  kind: node_12.CompletionItemKind.Enum,
                  data: ["type", dbtype.name],
                  commitCharacters: commitChars,
                  filterText: GetSymbolFilterText(context, dbtype),
                  sortText: GetTypenamePriority(context, dbtype)
                };
                if (context.expectedType == dbtype) {
                  complItem.sortText = Sort.EnumName_Expected;
                  complItem.preselect = true;
                  context.havePreselection = true;
                }
                if (context.isIncompleteNamespace)
                  complItem.insertText = ":" + complItem.label;
                completions.push(complItem);
              }
            }
          } else {
            if (expectedSubclassOf) {
              if (!dbtype.inheritsFrom(expectedSubclassOf))
                return;
            }
            if (CanCompleteSymbol(context, dbtype)) {
              if (!isTypeAccessibleFromScope(dbtype, context.scope))
                return;
              let commitChars = [];
              GetTypenameCommitChars(context, dbtype.name, commitChars);
              if (dbtype.isShadowingNamespace() && !context.isIncompleteNamespace)
                commitChars.push(":");
              let complItem = {
                label: dbtype.name,
                kind,
                data: ["type", dbtype.name],
                commitCharacters: commitChars,
                filterText: GetSymbolFilterText(context, dbtype),
                sortText: GetTypenamePriority(context, dbtype)
              };
              if (context.maybeTypename && context.typenameExpected && context.typenameExpected == dbtype.name || expectedSubclassOf) {
                complItem.sortText = Sort.Typename_Expected;
                complItem.preselect = true;
                context.havePreselection = true;
              }
              if (context.isIncompleteNamespace)
                complItem.insertText = ":" + complItem.label;
              completions.push(complItem);
            }
          }
        }
      });
      if (curtype instanceof typedb2.DBNamespace) {
        for (let [_, namespace] of curtype.childNamespaces) {
          if (!namespace.name || namespace.name.length == 0)
            continue;
          let kind = node_12.CompletionItemKind.Module;
          if (!context.isSubExpression && !context.isRightExpression || context.maybeTypename || expectedSubclassOf) {
            if (namespace.isShadowingType())
              continue;
          }
          if (CanCompleteSymbol(context, namespace)) {
            if (!isNamespaceAccessibleFromScope(namespace, context.scope))
              continue;
            let commitChars = [];
            if (!context.isIncompleteNamespace)
              commitChars.push(":");
            let complItem = {
              label: namespace.name,
              kind,
              data: ["namespace", namespace.getQualifiedNamespace()],
              commitCharacters: commitChars,
              sortText: GetNamespacePriority(context, namespace)
            };
            if (namespace.isShadowingType() && context.expectedType && context.expectedType.name == namespace.name) {
              if (context.expectedType.inheritsFrom("UActorComponent")) {
                complItem.sortText = Sort.Typename_Expected;
                complItem.preselect = true;
                context.havePreselection = true;
              }
            } else if (context.maybeTypename && context.typenameExpected && context.typenameExpected == namespace.name) {
              complItem.sortText = Sort.Typename_Expected;
              complItem.preselect = true;
              context.havePreselection = true;
            }
            if (context.isIncompleteNamespace)
              complItem.insertText = ":" + complItem.label;
            completions.push(complItem);
          }
        }
      }
    }
    exports2.AddCompletionsFromType = AddCompletionsFromType;
    function AddMixinCompletions(context, completions) {
      if (!context.scope)
        return;
      if (context.priorType instanceof typedb2.DBNamespace)
        return;
      let mixinsForType = context.priorType;
      if (!mixinsForType)
        mixinsForType = context.scope.getParentType();
      let checkNamespace = context.scope.getNamespace();
      while (checkNamespace) {
        checkNamespace.forEachSymbol(function(sym) {
          if (sym instanceof typedb2.DBMethod) {
            if (!sym.isMixin)
              return;
            if (!CanCompleteSymbol(context, sym))
              return;
            if (!isFunctionAccessibleFromScope(null, sym, context.scope))
              return;
            if (sym.args && sym.args.length != 0 && mixinsForType.inheritsFrom(sym.args[0].typename)) {
              let compl = {
                label: sym.name,
                kind: sym.isBlueprintEvent ? node_12.CompletionItemKind.Event : node_12.CompletionItemKind.Method,
                data: ["func_mixin", sym.namespace.getQualifiedNamespace(), sym.name, sym.id],
                commitCharacters: ["("],
                filterText: GetSymbolFilterText(context, sym),
                sortText: Sort.Method_Parent
              };
              compl.labelDetails = {
                detail: sym.args && sym.args.length > 0 ? FunctionLabelWithParamsSuffix : FunctionLabelSuffix
              };
              compl.command = {
                title: "",
                command: "angelscript.paren"
              };
              if (context.isTypeExpected(sym.returnType)) {
                if (!checkNamespace.isRootNamespace() || sym.isConstructor)
                  context.completionsMatchingExpected.push(compl);
              }
              if (sym.returnType && sym.returnType != "void") {
                compl.labelDetails.description = sym.returnType;
                if (!typedb2.IsPrimitive(sym.returnType))
                  compl.commitCharacters.push(".");
              }
              completions.push(compl);
            }
          }
        });
        checkNamespace = checkNamespace.parentNamespace;
      }
    }
    exports2.AddMixinCompletions = AddMixinCompletions;
    function CanCompleteStringTo(completing, suggestion) {
      if (completing.length == 0)
        return true;
      if (completing.startsWith("Get")) {
        if (suggestion.startsWith("Get"))
          return suggestion.substr(3).toLowerCase().indexOf(completing.substr(3).toLowerCase()) != -1;
      } else if (completing.startsWith("Set")) {
        if (suggestion.startsWith("Set"))
          return suggestion.substr(3).toLowerCase().indexOf(completing.substr(3).toLowerCase()) != -1;
      }
      return suggestion.toLowerCase().indexOf(completing.toLowerCase()) != -1;
    }
    function CanCompleteTo(context, suggestion) {
      if (context.completingSymbolLowerCase.length == 0)
        return true;
      if (context.completingSymbolGetter) {
        if (suggestion.startsWith("Get"))
          return suggestion.substr(3).toLowerCase().indexOf(context.completingSymbolGetter) != -1;
      } else if (context.completingSymbolSetter) {
        if (suggestion.startsWith("Set"))
          return suggestion.substr(3).toLowerCase().indexOf(context.completingSymbolSetter) != -1;
      }
      return suggestion.toLowerCase().indexOf(context.completingSymbolLowerCase) != -1;
    }
    function CanCompleteToOnlyStart(context, suggestion) {
      if (context.completingSymbolLowerCase.length == 0)
        return true;
      if (context.completingSymbolGetter) {
        if (suggestion.startsWith("Get"))
          return suggestion.substr(3).toLowerCase().startsWith(context.completingSymbolGetter);
      } else if (context.completingSymbolSetter) {
        if (suggestion.startsWith("Set"))
          return suggestion.substr(3).toLowerCase().startsWith(context.completingSymbolSetter);
      }
      return suggestion.toLowerCase().startsWith(context.completingSymbolLowerCase);
    }
    function CanCompleteSymbol(context, symbol) {
      if (symbol instanceof typedb2.DBType) {
        if (symbol.keywords)
          return CanCompleteToOnlyStart(context, GetSymbolFilterText(context, symbol));
        return CanCompleteToOnlyStart(context, symbol.name);
      } else if (symbol instanceof typedb2.DBNamespace) {
        return CanCompleteToOnlyStart(context, symbol.name);
      } else if (!symbol.containingType && symbol.namespace.isRootNamespace() && !context.priorType) {
        if (symbol.keywords)
          return CanCompleteToOnlyStart(context, GetSymbolFilterText(context, symbol));
        return CanCompleteToOnlyStart(context, symbol.name);
      } else {
        if (symbol.keywords)
          return CanCompleteTo(context, GetSymbolFilterText(context, symbol));
        return CanCompleteTo(context, symbol.name);
      }
    }
    function GetSymbolFilterText(context, symbol) {
      if (!symbol.keywords)
        return void 0;
      return [symbol.name, ...symbol.keywords].join(" ");
    }
    function GetTypenamePriority(context, type) {
      if (CommonTypenames.has(type.name))
        return Sort.Typename_Common;
      if (type.declaredModule == context.scope.module.modulename)
        return Sort.Typename_SameFile;
      if (context.nearbyTypenames.has(type.name))
        return Sort.Typename_NearbyUsage;
      if (CommonObjectTypes.has(type.name))
        return Sort.Typename_CommonObject;
      return Sort.Typename;
    }
    function GetNamespacePriority(context, namespace) {
      if (context.scope && context.scope.scopetype == scriptfiles2.ASScopeType.Class)
        return Sort.Namespace_Unexpected;
      if (CommonNamespaces.has(namespace.name))
        return Sort.Typename_Common;
      let shadowType = namespace.getShadowedType();
      if (shadowType) {
        if (shadowType.declaredModule == context.scope.module.modulename)
          return Sort.Typename_SameFile;
        if (context.nearbyTypenames.has(shadowType.name))
          return Sort.Typename_NearbyUsage;
      }
      return Sort.Typename;
    }
    function GenerateCompletionContext(asmodule, offset) {
      let context = new CompletionContext();
      let contentOffset = 0;
      context.baseStatement = asmodule.getStatementAt(offset);
      context.completeOffset = offset;
      let content = null;
      if (context.baseStatement) {
        content = context.baseStatement.content;
        contentOffset = context.baseStatement.start_offset;
        if (context.baseStatement.ast) {
          switch (context.baseStatement.ast.type) {
            case scriptfiles2.node_types.FunctionDecl:
            case scriptfiles2.node_types.EventDecl:
            case scriptfiles2.node_types.DelegateDecl:
            case scriptfiles2.node_types.ConstructorDecl:
            case scriptfiles2.node_types.DestructorDecl:
              context.isFunctionDeclaration = true;
              break;
          }
        }
      } else {
        content = asmodule.content;
        contentOffset = 0;
      }
      let ignoreTable = GetCodeOffsetIgnoreTable(content);
      let offsetInTable = offset - contentOffset;
      for (let i = 0; i < ignoreTable.length; i += 2) {
        if (offsetInTable >= ignoreTable[i] && offsetInTable < ignoreTable[i + 1]) {
          context.isIgnoredCode = true;
          break;
        }
      }
      let candidates = ExtractExpressionPreceding(content, offset - contentOffset, ignoreTable);
      context.scope = asmodule.getScopeAt(offset);
      let currentLine = asmodule.getPosition(offset).line;
      if (currentLine > 0) {
        context.previousLineContent = asmodule.textDocument.getText(node_12.Range.create(node_12.Position.create(currentLine - 1, 0), node_12.Position.create(currentLine - 1, 99999)));
      }
      if (!context.previousLineContent)
        context.previousLineContent = "";
      context.statement = new scriptfiles2.ASStatement();
      for (let i = candidates.length - 1; i >= 0; --i) {
        let candidate = candidates[i];
        context.statement.content = candidate.code;
        context.statement.end_offset = offset + 1;
        context.statement.start_offset = offset + 1 - candidate.code.length;
        context.isRightExpression = candidate.isRightExpression;
        context.rightOperator = candidate.rightOperator;
        context.priorType = null;
        context.priorTypeWasNamespace = false;
        context.expectedType = null;
        context.statement.ast = null;
        context.requiresPriorType = false;
        let baseType = context.scope.scopetype;
        if (context.baseStatement && context.baseStatement.ast && context.baseStatement.ast.type == scriptfiles2.node_types.DefaultStatement)
          baseType = scriptfiles2.ASScopeType.Code;
        if (context.isRightExpression)
          baseType = scriptfiles2.ASScopeType.Code;
        scriptfiles2.ParseStatement(baseType, context.statement);
        if (!context.statement.ast) {
          if (context.baseStatement && context.scope.declaration == context.baseStatement)
            scriptfiles2.ParseStatement(context.scope.parentscope.scopetype, context.statement);
        }
        if (!context.statement.ast && baseType != scriptfiles2.ASScopeType.Code)
          scriptfiles2.ParseStatement(scriptfiles2.ASScopeType.Code, context.statement);
        if (!context.statement.ast)
          continue;
        let haveTerm = ExtractPriorExpressionAndSymbol(context, context.statement.ast);
        if (haveTerm)
          break;
        else
          context.statement.ast = null;
      }
      if (!context.statement.ast) {
        for (let i = candidates.length - 1; i >= 0; --i) {
          let candidate = candidates[i];
          context.statement.content = candidate.code;
          context.statement.end_offset = offset + 1;
          context.statement.start_offset = offset + 1 - candidate.code.length;
          context.isRightExpression = candidate.isRightExpression;
          context.rightOperator = candidate.rightOperator;
          context.priorType = null;
          context.priorTypeWasNamespace = false;
          context.expectedType = null;
          context.statement.ast = null;
          context.requiresPriorType = false;
          scriptfiles2.ParseStatement(context.scope.scopetype, context.statement);
          if (!context.statement.ast)
            scriptfiles2.ParseStatement(scriptfiles2.ASScopeType.Code, context.statement);
          if (!context.statement.ast)
            continue;
          ExtractPriorExpressionAndSymbol(context, context.statement.ast);
          break;
        }
      }
      let [subExprOffset, argumentIndex] = ScanOffsetStartOfOuterExpression(content, offset - contentOffset, ignoreTable);
      if (subExprOffset != -1) {
        context.isSubExpression = true;
        context.subOuterStatement = new scriptfiles2.ASStatement();
        context.subOuterArgumentIndex = argumentIndex;
        let subCandidates = ExtractExpressionPreceding(content, subExprOffset, ignoreTable);
        for (let i = subCandidates.length - 1; i >= 0; --i) {
          let candidate = subCandidates[i];
          context.subOuterStatement.content = candidate.code;
          context.subOuterStatement.ast = null;
          context.subOuterStatement.end_offset = subExprOffset + 1 + contentOffset;
          context.subOuterStatement.start_offset = context.subOuterStatement.end_offset - candidate.code.length;
          let baseType = context.scope.scopetype;
          if (context.baseStatement && context.baseStatement.ast && context.baseStatement.ast.type == scriptfiles2.node_types.DefaultStatement)
            baseType = scriptfiles2.ASScopeType.Code;
          scriptfiles2.ParseStatement(baseType, context.subOuterStatement);
          if (!context.subOuterStatement.ast)
            scriptfiles2.ParseStatement(scriptfiles2.ASScopeType.Code, context.subOuterStatement);
          if (!context.subOuterStatement.ast)
            continue;
          context.subOuterFunctions = new Array();
          scriptfiles2.ResolveFunctionOverloadsFromExpression(context.scope, context.subOuterStatement.ast, context.subOuterFunctions);
          if (context.subOuterFunctions.length != 0)
            break;
          if (context.subOuterStatement.ast.type == scriptfiles2.node_types.VariableDecl) {
            let dbVarType = typedb2.LookupType(context.scope.getNamespace(), context.subOuterStatement.ast.typename.value);
            if (dbVarType && i == subCandidates.length - 1 && (!context.baseStatement || !context.baseStatement.ast || context.baseStatement.ast.type != scriptfiles2.node_types.FunctionDecl || !(context.baseStatement.next instanceof scriptfiles2.ASScope))) {
              if (context.subOuterStatement.ast.name || !context.scope.isInFunctionBody()) {
                scriptfiles2.ResolveFunctionOverloadsFromIdentifier(context.scope, dbVarType.name, context.subOuterFunctions);
                if (context.subOuterFunctions.length != 0)
                  break;
              }
            }
          }
        }
        if (!context.subOuterStatement.ast)
          context.outerAssignIdentifier = ExtractAssignmentIdentifierPreceding(content, subExprOffset);
        scriptfiles2.DisambiguateFunctionOverloadsFromOverriddenFunctions(context.subOuterFunctions);
      }
      if (context.subOuterStatement) {
        let subEndOffset = ScanOffsetEndOfOuterExpression(content, offset - contentOffset, ignoreTable);
        if (subEndOffset != -1) {
          let entireExpression = content.substring(context.subOuterStatement.start_offset - contentOffset, subEndOffset + 1);
          context.fullOuterStatement = new scriptfiles2.ASStatement();
          context.fullOuterStatement.content = entireExpression;
          context.fullOuterStatement.ast = null;
          context.fullOuterStatement.end_offset = context.subOuterStatement.start_offset;
          context.fullOuterStatement.start_offset = subEndOffset + 1 + contentOffset;
          scriptfiles2.ParseStatement(context.scope.scopetype, context.fullOuterStatement);
          if (!context.fullOuterStatement.ast)
            scriptfiles2.ParseStatement(scriptfiles2.ASScopeType.Code, context.fullOuterStatement);
        }
      }
      if (context.subOuterFunctions && context.subOuterFunctions.length > 1 && context.fullOuterStatement) {
        let argContext = GenerateCompletionArguments(context);
        let scoredFunctions = new Array();
        for (let func of context.subOuterFunctions)
          scoredFunctions.push([func, ScoreMethodOverload(context, func, argContext)[0]]);
        scoredFunctions.sort((first, second) => {
          if (first[1] > second[1])
            return -1;
          else if (first[1] < second[1])
            return 1;
          else
            return 0;
        });
        context.subOuterFunctions = [];
        for (let [func, score] of scoredFunctions)
          context.subOuterFunctions.push(func);
      }
      if (context.subOuterFunctions && context.subOuterFunctions.length != 0 && context.subOuterArgumentIndex != -1 && !context.expectedType && (!context.isRightExpression || context.rightOperator == "=" && context.isSubExpression)) {
        let argContext = GenerateCompletionArguments(context);
        for (let candidateFunction of context.subOuterFunctions) {
          if (!candidateFunction.args)
            continue;
          if (argContext.currentArgumentName) {
            for (let arg of candidateFunction.args) {
              if (arg.name == argContext.currentArgumentName) {
                let argType2 = typedb2.LookupType(candidateFunction.namespace, arg.typename);
                if (argType2 && !context.expectedType) {
                  context.expectedType = argType2;
                  if (context.isRightExpression && context.rightOperator == "=") {
                    context.isRightExpression = false;
                  }
                }
              }
            }
          }
          let candidateArgumentIndex = context.subOuterArgumentIndex;
          if (candidateFunction.isMixin)
            candidateArgumentIndex += 1;
          if (candidateFunction.args.length <= candidateArgumentIndex)
            continue;
          let argType = typedb2.LookupType(candidateFunction.namespace, candidateFunction.args[candidateArgumentIndex].typename);
          if (argType && !context.expectedType)
            context.expectedType = argType;
        }
      }
      context.isAssignment = context.isRightExpression && !context.isSubExpression && context.rightOperator == "=";
      if (context.isRightExpression && context.statement && context.rightOperator && (context.rightOperator != "=" || !context.isSubExpression)) {
        context.leftStatement = new scriptfiles2.ASStatement();
        let assignLeftOffset = context.statement.start_offset - 1 - contentOffset - context.rightOperator.length;
        if (context.statement.ast && context.statement.ast.type == scriptfiles2.node_types.BinaryOperation)
          assignLeftOffset = context.statement.start_offset + context.statement.ast.children[0].end - contentOffset - 1;
        let lvalueCandidates = ExtractExpressionPreceding(content, assignLeftOffset, ignoreTable, true);
        for (let i = lvalueCandidates.length - 1; i >= 0; --i) {
          let candidate = lvalueCandidates[i];
          context.leftStatement.content = candidate.code;
          context.leftStatement.ast = null;
          context.leftStatement.end_offset = assignLeftOffset + 1 + contentOffset;
          context.leftStatement.start_offset = context.leftStatement.end_offset - candidate.code.length;
          scriptfiles2.ParseStatement(scriptfiles2.ASScopeType.Code, context.leftStatement);
          if (!context.leftStatement.ast && context.scope)
            scriptfiles2.ParseStatement(context.scope.scopetype, context.leftStatement);
          if (!context.leftStatement.ast)
            continue;
          if (context.leftStatement.ast.type == scriptfiles2.node_types.VariableDecl) {
            context.leftType = typedb2.LookupType(context.scope.getNamespace(), context.leftStatement.ast.typename.value);
            if (context.leftType)
              break;
          }
          switch (context.leftStatement.ast.type) {
            case scriptfiles2.node_types.ReturnStatement:
            case scriptfiles2.node_types.DefaultStatement:
            case scriptfiles2.node_types.ElseStatement:
              {
                let subNode = context.leftStatement.ast.children[0];
                if (subNode)
                  context.leftType = scriptfiles2.ResolveTypeFromExpression(context.scope, subNode);
              }
              break;
          }
          if (context.leftType)
            break;
          context.leftType = scriptfiles2.ResolveTypeFromExpression(context.scope, context.leftStatement.ast);
          if (context.leftType)
            break;
        }
        if (!context.expectedType) {
          if (context.rightOperator == "&&" || context.rightOperator == "||" || context.rightOperator == "!") {
            context.expectedType = typedb2.GetTypeByName("bool");
          }
        }
        if (context.leftType && !context.expectedType) {
          if (context.rightOperator == "==" || context.rightOperator == "=" || context.rightOperator == "!=") {
            context.expectedType = context.leftType;
          } else if (context.leftType.isPrimitive || context.leftType.isEnum) {
            context.expectedType = context.leftType;
          } else {
            let overloadMethod = scriptfiles2.GetOverloadMethodForOperator(context.rightOperator);
            if (overloadMethod) {
              let overloadFunc = context.leftType.findFirstSymbol(overloadMethod, typedb2.DBAllowSymbol.Functions);
              if (overloadFunc instanceof typedb2.DBMethod) {
                if (overloadFunc.args && overloadFunc.args.length >= 1) {
                  context.expectedType = typedb2.LookupType(overloadFunc.namespace, overloadFunc.args[0].typename);
                }
              }
            }
          }
        }
      } else if (context.isRightExpression && context.rightOperator == "=") {
        let assignLeftOffset = context.statement.start_offset - contentOffset;
        context.outerAssignIdentifier = ExtractAssignmentIdentifierPreceding(content, assignLeftOffset);
      }
      if (context.fullOuterStatement && context.fullOuterStatement.ast) {
        if (context.fullOuterStatement.ast.type == scriptfiles2.node_types.IfStatement || context.fullOuterStatement.ast.type == scriptfiles2.node_types.WhileStatement) {
          if (!context.isRightExpression && !context.expectedType) {
            context.expectedType = typedb2.GetTypeByName("bool");
          }
        }
      }
      if (context.fullOuterStatement && context.fullOuterStatement.ast && context.fullOuterStatement.ast.type == scriptfiles2.node_types.ForLoop) {
        let outerNode = context.fullOuterStatement.ast;
        if (outerNode.children[0] && !outerNode.children[1] && !outerNode.children[2] && !outerNode.children[3]) {
          if (outerNode.children[0].type == scriptfiles2.node_types.Identifier)
            context.maybeTypename = true;
        }
      }
      if (context.completingNode) {
        if (context.completingNode.type == scriptfiles2.node_types.Typename)
          context.maybeTypename = true;
        if (context.isFunctionDeclaration && context.isSubExpression && context.completingNode == context.statement.ast)
          context.maybeTypename = true;
        if (context.completingNode == context.statement.ast && !context.isRightExpression && !context.isSubExpression && !context.isNamingSomethingNew)
          context.maybeTypename = true;
      }
      if (context.statement.ast && context.statement.ast.type == scriptfiles2.node_types.CastOperation) {
        context.isRightExpression = false;
        context.maybeTypename = true;
        if (context.expectedType)
          context.typenameExpected = context.expectedType.name;
      }
      if (context.priorType)
        context.isInsideType = true;
      else if (context.statement.ast && context.statement.ast.type == scriptfiles2.node_types.MemberAccess)
        context.isInsideType = true;
      else if (context.statement.ast && context.statement.ast.type == scriptfiles2.node_types.NamespaceAccess)
        context.isInsideType = true;
      if (context.isRightExpression && context.rightOperator == "<" && context.leftStatement) {
        let leftNode = context.leftStatement.ast;
        let leftAsType = null;
        let isCast = false;
        if (leftNode) {
          if (leftNode.type == scriptfiles2.node_types.Typename) {
            leftAsType = typedb2.LookupType(context.scope.getNamespace(), leftNode.value);
          } else if (leftNode.type == scriptfiles2.node_types.VariableDecl) {
            if (!leftNode.name)
              leftAsType = typedb2.LookupType(context.scope.getNamespace(), leftNode.typename.value);
          } else if (leftNode.type == scriptfiles2.node_types.CastOperation) {
            isCast = true;
          }
          if (leftAsType && leftAsType.isTemplateType() || isCast) {
            context.isRightExpression = false;
            context.maybeTypename = true;
          }
        }
      }
      if (context.statement && context.statement.ast && context.statement.ast.type == scriptfiles2.node_types.CaseStatement) {
        if (context.scope) {
          let prevStatement = context.scope.previous;
          if (prevStatement instanceof scriptfiles2.ASStatement) {
            if (prevStatement.ast && prevStatement.ast.type == scriptfiles2.node_types.SwitchStatement) {
              if (!context.expectedType && prevStatement.ast.children[0]) {
                context.expectedType = scriptfiles2.ResolveTypeFromExpression(context.scope.parentscope, prevStatement.ast.children[0]);
              }
            }
          }
        }
      }
      let completionCharacter = content[offset - contentOffset];
      if (completionCharacter == ".") {
        context.completingDot = true;
        context.requiresPriorType = true;
      } else if (completionCharacter == ":") {
        context.completingNamespace = true;
        context.requiresPriorType = true;
      }
      if (context.completingSymbol) {
        context.completingSymbolLowerCase = context.completingSymbol.toLowerCase();
        if (context.completingSymbolLowerCase.startsWith("get"))
          context.completingSymbolGetter = context.completingSymbolLowerCase.substr(3);
        else if (context.completingSymbolLowerCase.startsWith("set"))
          context.completingSymbolSetter = context.completingSymbolLowerCase.substr(3);
      } else {
        context.completingSymbolLowerCase = "";
      }
      if (context.scope) {
        let inClass = context.scope.getParentType();
        if (inClass) {
          inClass.forEachSymbol(function(symbol) {
            if (symbol instanceof typedb2.DBProperty)
              context.nearbyTypenames.add(symbol.typename);
          }, false);
        }
        let functionScope = context.scope.getParentFunctionScope();
        if (functionScope) {
          for (let localVariable of functionScope.variables)
            context.nearbyTypenames.add(localVariable.typename);
        }
      }
      return context;
    }
    function ExtractPriorExpressionAndSymbol(context, node) {
      if (!node)
        return false;
      switch (node.type) {
        case scriptfiles2.node_types.Identifier:
          {
            context.priorExpression = null;
            context.completingSymbol = node.value;
            context.completingNode = node;
            context.priorType = null;
            return true;
          }
          break;
        case scriptfiles2.node_types.MemberAccess:
          {
            context.priorExpression = node.children[0];
            if (node.children[1])
              context.completingSymbol = node.children[1].value;
            else
              context.completingSymbol = "";
            context.completingNode = node.children[1];
            context.priorType = scriptfiles2.ResolveTypeFromExpression(context.scope, node.children[0]);
            context.priorTypeWasNamespace = false;
            context.requiresPriorType = true;
            if (context.priorType) {
              if (context.priorType.isEnum)
                context.priorType = null;
              return true;
            } else {
              return false;
            }
          }
          break;
        case scriptfiles2.node_types.NamespaceAccess:
          {
            if (!node.children[0])
              return false;
            context.priorExpression = node.children[0];
            if (node.children[1])
              context.completingSymbol = node.children[1].value;
            else
              context.completingSymbol = "";
            context.completingNode = node.children[1];
            let fullNamespace = scriptfiles2.CollapseNamespaceFromNode(node.children[0]);
            if (fullNamespace == "Super" && context.scope.getParentType())
              context.priorType = context.scope.getParentType().getSuperType();
            if (!context.priorType) {
              let enumType = typedb2.LookupType(context.scope.getNamespace(), fullNamespace);
              if (enumType && enumType.isEnum)
                context.priorType = enumType;
            }
            if (!context.priorType)
              context.priorType = typedb2.LookupNamespace(context.scope.getNamespace(), fullNamespace);
            context.priorTypeWasNamespace = true;
            context.requiresPriorType = true;
            if (context.priorType) {
              if (node.incomplete_colon)
                context.isIncompleteNamespace = true;
              context.completingNamespace = true;
              return true;
            } else {
              return false;
            }
          }
          break;
        case scriptfiles2.node_types.BinaryOperation:
          context.isRightExpression = true;
          context.rightOperator = node.operator;
          return ExtractPriorExpressionAndSymbol(context, node.children[1]);
          break;
        case scriptfiles2.node_types.UnaryOperation:
          if (scriptfiles2.IsPrimitiveLiteralNode(node.children[0])) {
            context.isRightExpression = false;
            context.rightOperator = null;
          } else {
            context.isRightExpression = true;
            context.rightOperator = node.operator;
          }
          return ExtractPriorExpressionAndSymbol(context, node.children[0]);
        case scriptfiles2.node_types.PostfixOperation:
          context.isRightExpression = true;
          context.rightOperator = node.operator;
          return ExtractPriorExpressionAndSymbol(context, node.children[0]);
        case scriptfiles2.node_types.ElseStatement:
        case scriptfiles2.node_types.DefaultCaseStatement:
          return ExtractPriorExpressionAndSymbol(context, node.children[0]);
        case scriptfiles2.node_types.ReturnStatement:
          context.isRightExpression = true;
          if (context.scope) {
            let dbFunc = context.scope.getParentFunction();
            if (dbFunc && dbFunc.returnType)
              context.expectedType = typedb2.LookupType(dbFunc.namespace, dbFunc.returnType);
          }
          return ExtractPriorExpressionAndSymbol(context, node.children[0]);
        case scriptfiles2.node_types.CaseStatement:
          if (node.children[1]) {
            return ExtractPriorExpressionAndSymbol(context, node.children[1]);
          } else {
            if (node.has_statement && node.children[0] && node.children[0].type == scriptfiles2.node_types.NamespaceAccess) {
              let nsNode = node.children[0];
              if (nsNode.children[1]) {
                context.priorExpression = nsNode.children[0];
                context.completingSymbol = "";
                context.completingNode = null;
                let typeName = nsNode.children[0].value;
                if (nsNode.children[1].value)
                  typeName += "::" + nsNode.children[1].value;
                context.priorType = typedb2.LookupType(context.scope.getNamespace(), typeName);
                context.priorTypeWasNamespace = true;
                context.requiresPriorType = true;
                context.isIncompleteNamespace = true;
                context.isRightExpression = !!context.priorType;
                return true;
              }
            }
            context.isRightExpression = true;
            return ExtractPriorExpressionAndSymbol(context, node.children[0]);
          }
          break;
        case scriptfiles2.node_types.VariableDecl:
          {
            if (node.typename) {
              let declType = typedb2.LookupType(context.scope.getNamespace(), node.typename.value);
              context.priorExpression = null;
              if (node.name) {
                context.isNamingSomethingNew = !!declType;
                context.completingSymbol = node.name.value;
                context.completingNode = node.name;
              } else {
                context.completingSymbol = node.typename.value;
                context.completingNode = node.typename;
              }
              context.priorType = null;
              return true;
            }
          }
          break;
        case scriptfiles2.node_types.FunctionDecl:
          {
            context.isNamingSomethingNew = true;
            context.priorExpression = null;
            if (node.name)
              context.completingSymbol = node.name.value;
            else
              context.completingSymbol = "";
            context.completingNode = node.name;
            context.priorType = null;
            return true;
          }
          break;
        case scriptfiles2.node_types.ClassDefinition:
          {
            context.priorExpression = null;
            context.priorType = null;
            if (node.superclass) {
              context.maybeTypename = true;
              context.isRightExpression = false;
              context.completingNode = node.superclass;
              context.completingSymbol = node.superclass.value;
            } else {
              context.isNamingSomethingNew = true;
              context.isNamingNewClass = true;
              context.completingNode = node.name;
              if (node.name)
                context.completingSymbol = node.name.value;
              else
                context.completingSymbol = "";
            }
            return true;
          }
          break;
        case scriptfiles2.node_types.StructDefinition:
        case scriptfiles2.node_types.EnumDefinition:
        case scriptfiles2.node_types.NamespaceDefinition:
          {
            context.priorExpression = null;
            context.priorType = null;
            context.isNamingSomethingNew = true;
            if (node.type == scriptfiles2.node_types.StructDefinition)
              context.isNamingNewStruct = true;
            context.completingNode = node.name;
            if (node.name)
              context.completingSymbol = node.name.value;
            else
              context.completingSymbol = "";
            return true;
          }
          break;
        case scriptfiles2.node_types.ImportStatement:
          {
            context.priorExpression = null;
            context.priorType = null;
            context.isNamingSomethingNew = false;
            if (node.children && node.children[0]) {
              context.completingNode = node.children[0];
              context.completingSymbol = node.children[0].value;
            }
            return true;
          }
          break;
        case scriptfiles2.node_types.IncompleteAccessSpecifier:
          {
            context.priorExpression = null;
            context.priorType = null;
            context.isNamingSomethingNew = false;
            context.isTypingAccessSpecifier = true;
            return true;
          }
          break;
        case scriptfiles2.node_types.AccessDeclaration:
          {
            if (!node.children || node.children.length == 0) {
              context.priorExpression = null;
              context.priorType = null;
              context.isNamingSomethingNew = true;
              context.completingNode = node.name;
              context.completingSymbol = node.name.value;
              return true;
            }
          }
          break;
        case scriptfiles2.node_types.CastOperation:
          {
            if (node.children && node.children[0] && !node.children[1]) {
              context.priorExpression = null;
              context.completingSymbol = node.children[0].value;
              context.completingNode = node.children[0];
              context.priorType = null;
              context.maybeTypename = true;
              return true;
            }
          }
          break;
      }
      return false;
    }
    function ExtractExpressionPreceding(content, offset, ignoreTable, initialExpectingTerm = false) {
      let candidates = [];
      let exprEndOffset = offset + 1;
      let exprStartOffset = offset;
      let lastExprStartOffset = offset;
      function addCandidate(shiftCurrent = 0) {
        let candidate = null;
        if (exprStartOffset < lastExprStartOffset) {
          let code = content.substring(exprStartOffset + shiftCurrent, exprEndOffset);
          if (!IsCodeEmpty(code)) {
            candidate = new CompletionExpressionCandidate();
            candidate.start = exprStartOffset;
            candidate.end = exprEndOffset;
            candidate.code = code;
            candidates.push(candidate);
          }
          lastExprStartOffset = exprStartOffset;
        }
        return candidate;
      }
      let depth_paren = 0;
      let depth_sqbracket = 0;
      let depth_anglebracket = 0;
      let expectingTerm = initialExpectingTerm;
      let haveFirstIdentifier = false;
      let ignoreTableIndex = ignoreTable ? ignoreTable.length - 2 : -1;
      for (; exprStartOffset >= 0; --exprStartOffset) {
        let char = content[exprStartOffset];
        let endParse = false;
        while (ignoreTableIndex >= 0 && exprStartOffset < ignoreTable[ignoreTableIndex])
          ignoreTableIndex -= 2;
        if (ignoreTableIndex >= 0) {
          let ignoreStart = ignoreTable[ignoreTableIndex];
          let ignoreEnd = ignoreTable[ignoreTableIndex + 1];
          if (exprStartOffset >= ignoreStart && exprStartOffset < ignoreEnd)
            continue;
        }
        let wasExpectingTerm = expectingTerm;
        if (expectingTerm && char != " " && char != "	" && char != "\r" && char != "\n")
          expectingTerm = false;
        switch (char) {
          case ";":
            {
              let c = addCandidate(1);
              endParse = true;
            }
            break;
          case "(":
            {
              if (depth_sqbracket == 0) {
                if (depth_paren == 0) {
                  let c = addCandidate(1);
                  endParse = true;
                } else {
                  depth_paren -= 1;
                  if (depth_paren == 0)
                    expectingTerm = true;
                }
              }
            }
            break;
          case ")":
            {
              if (depth_sqbracket == 0) {
                if (!wasExpectingTerm && depth_paren == 0) {
                  let c = addCandidate(1);
                  endParse = true;
                } else {
                  depth_paren += 1;
                }
              }
            }
            break;
          case "[":
            {
              if (depth_paren == 0) {
                if (depth_sqbracket == 0) {
                  let c = addCandidate(1);
                  endParse = true;
                } else {
                  depth_sqbracket -= 1;
                }
              }
            }
            break;
          case "]":
            {
              if (depth_paren == 0) {
                if (!wasExpectingTerm && depth_sqbracket == 0) {
                  let c = addCandidate(1);
                  endParse = true;
                } else {
                  depth_sqbracket += 1;
                  if (depth_sqbracket == 0)
                    expectingTerm = true;
                }
              }
            }
            break;
          case "<":
            {
              if (depth_paren == 0 && depth_sqbracket == 0) {
                if (depth_anglebracket == 0) {
                  let c = addCandidate(1);
                  if (c) {
                    c.isRightExpression = true;
                    c.rightOperator = "<";
                  }
                  if (exprStartOffset >= 4 && content[exprStartOffset - 4] == "C" && content[exprStartOffset - 3] == "a" && content[exprStartOffset - 2] == "s" && content[exprStartOffset - 1] == "t") {
                  } else {
                    endParse = true;
                  }
                } else {
                  depth_anglebracket -= 1;
                }
              }
            }
            break;
          case ">":
            {
              if (depth_paren == 0 && depth_sqbracket == 0) {
                let c = addCandidate(1);
                if (c) {
                  c.isRightExpression = true;
                  c.rightOperator = ">";
                }
                depth_anglebracket += 1;
              }
            }
            break;
          case ",":
            if (depth_paren == 0 && depth_sqbracket == 0 && depth_anglebracket == 0) {
              let c = addCandidate(1);
              endParse = true;
            }
            break;
          case "\n":
            addCandidate(1);
            break;
          case ":":
            if (depth_paren == 0 && depth_sqbracket == 0 && depth_anglebracket == 0) {
              let c = addCandidate(1);
              if (c) {
                c.isRightExpression = true;
                c.rightOperator = ":";
              }
              expectingTerm = true;
            }
            break;
          case ".":
            expectingTerm = true;
            break;
          case "{":
          case "}":
            {
              if (depth_paren == 0 && depth_sqbracket == 0 && depth_anglebracket == 0) {
                let c = addCandidate(1);
                endParse = true;
              }
            }
            break;
          case "?":
          case "/":
          case "+":
          case "-":
          case "=":
          case "*":
          case "@":
          case "!":
          case "&":
          case "|":
          case "^":
            {
              if (depth_paren == 0 && depth_sqbracket == 0 && depth_anglebracket == 0) {
                let c = addCandidate(1);
                if (c) {
                  c.isRightExpression = true;
                  c.rightOperator = char;
                  if (exprStartOffset > 0) {
                    let prevChar = content[exprStartOffset - 1];
                    switch (prevChar) {
                      case "+":
                      case "-":
                      case "*":
                      case "/":
                      case "=":
                      case ">":
                      case "<":
                      case "!":
                      case "%":
                      case "^":
                      case "&":
                      case "|":
                        c.rightOperator = prevChar + c.rightOperator;
                        break;
                    }
                  }
                  switch (c.rightOperator) {
                    case "+":
                    case "-":
                      {
                        lastExprStartOffset += 1;
                        let unary = addCandidate(0);
                        unary.isRightExpression = true;
                        unary.rightOperator = c.rightOperator;
                      }
                      break;
                  }
                }
                endParse = true;
              }
            }
            break;
          case " ":
          case "	":
            {
              if (!haveFirstIdentifier) {
                haveFirstIdentifier = true;
                let c = addCandidate(1);
              }
            }
            break;
        }
        if (endParse)
          break;
      }
      if (exprStartOffset < lastExprStartOffset)
        addCandidate(0);
      return candidates;
    }
    function ScanOffsetStartOfOuterExpression(content, offset, ignoreTable) {
      let depth_paren = 0;
      let depth_sqbracket = 0;
      let depth_anglebracket = 0;
      let sq_string = false;
      let dq_string = false;
      let argumentIndex = 0;
      let ignoreTableIndex = ignoreTable ? ignoreTable.length - 2 : -1;
      for (let curOffset = offset; curOffset > 0; --curOffset) {
        let char = content[curOffset];
        while (ignoreTableIndex >= 0 && curOffset < ignoreTable[ignoreTableIndex])
          ignoreTableIndex -= 2;
        if (ignoreTableIndex >= 0) {
          let ignoreStart = ignoreTable[ignoreTableIndex];
          let ignoreEnd = ignoreTable[ignoreTableIndex + 1];
          if (curOffset >= ignoreStart && curOffset < ignoreEnd)
            continue;
        }
        switch (char) {
          case ";":
            {
              if (!sq_string && !dq_string) {
                return [-1, 0];
              }
            }
            break;
          case "(":
            {
              if (depth_sqbracket == 0) {
                if (depth_paren == 0) {
                  return [curOffset - 1, argumentIndex];
                } else {
                  depth_paren -= 1;
                }
              }
            }
            break;
          case ")":
            {
              if (depth_sqbracket == 0) {
                depth_paren += 1;
              }
            }
            break;
          case "[":
            {
              if (depth_paren == 0) {
                if (depth_sqbracket == 0) {
                  return [-1, 0];
                } else {
                  depth_sqbracket -= 1;
                }
              }
            }
            break;
          case "]":
            {
              if (depth_paren == 0) {
                depth_sqbracket += 1;
              }
            }
            break;
          case "<":
            {
              if (depth_paren == 0 && depth_sqbracket == 0) {
                if (depth_anglebracket != 0) {
                  depth_anglebracket -= 1;
                }
              }
            }
            break;
          case ">":
            {
              if (depth_paren == 0 && depth_sqbracket == 0) {
                depth_anglebracket += 1;
              }
            }
            break;
          case ",":
            if (depth_paren == 0 && depth_sqbracket == 0 && depth_anglebracket == 0) {
              argumentIndex += 1;
            }
            break;
          case "{":
          case "}":
            {
              if (depth_paren == 0 && depth_sqbracket == 0 && depth_anglebracket == 0) {
                return [-1, 0];
              }
            }
            break;
        }
      }
      return [-1, 0];
    }
    function ExtractIdentifierPreceding(content, offset) {
      let identifierEndOffset = -1;
      let identifierStartOffset = offset - 1;
      for (; identifierStartOffset >= 0; --identifierStartOffset) {
        let char = content[identifierStartOffset];
        let charCode = content.charCodeAt(identifierStartOffset);
        let isIdentifierChar = false;
        if (charCode > 47 && charCode < 58)
          isIdentifierChar = true;
        else if (charCode > 64 && charCode < 91)
          isIdentifierChar = true;
        else if (charCode > 96 && charCode < 123)
          isIdentifierChar = true;
        else if (charCode == 95)
          isIdentifierChar = true;
        if (identifierEndOffset == -1) {
          if (char == " " || char == "	")
            continue;
          if (isIdentifierChar)
            identifierEndOffset = identifierStartOffset + 1;
          else
            return null;
        } else {
          if (!isIdentifierChar)
            return content.substring(identifierStartOffset + 1, identifierEndOffset);
        }
      }
      return null;
    }
    function ExtractAssignmentIdentifierPreceding(content, offset) {
      let scanOffset = offset - 1;
      for (; scanOffset >= 0; --scanOffset) {
        let char = content[scanOffset];
        if (char == " " || char == "	")
          continue;
        if (char == "=") {
          return ExtractIdentifierPreceding(content, scanOffset);
        } else {
          return null;
        }
      }
      return null;
    }
    function ScanOffsetEndOfOuterExpression(content, offset, ignoreTable) {
      let depth_paren = 0;
      let depth_sqbracket = 0;
      let depth_anglebracket = 0;
      let sq_string = false;
      let dq_string = false;
      let argumentIndex = 0;
      let ignoreTableIndex = 0;
      for (let curOffset = offset; curOffset < content.length; ++curOffset) {
        let char = content[curOffset];
        while (ignoreTableIndex < ignoreTable.length && curOffset > ignoreTable[ignoreTableIndex + 1])
          ignoreTableIndex += 2;
        if (ignoreTableIndex < ignoreTable.length) {
          let ignoreStart = ignoreTable[ignoreTableIndex];
          let ignoreEnd = ignoreTable[ignoreTableIndex + 1];
          if (curOffset >= ignoreStart && curOffset < ignoreEnd)
            continue;
        }
        switch (char) {
          case ";":
            {
              if (!sq_string && !dq_string) {
                return -1;
              }
            }
            break;
          case ")":
            {
              if (depth_sqbracket == 0) {
                if (depth_paren == 0) {
                  return curOffset;
                } else {
                  depth_paren -= 1;
                }
              }
            }
            break;
          case "(":
            {
              if (depth_sqbracket == 0) {
                depth_paren += 1;
              }
            }
            break;
          case "]":
            {
              if (depth_paren == 0) {
                if (depth_sqbracket == 0) {
                  return -1;
                } else {
                  depth_sqbracket -= 1;
                }
              }
            }
            break;
          case "[":
            {
              if (depth_paren == 0) {
                depth_sqbracket += 1;
              }
            }
            break;
          case ">":
            {
              if (depth_paren == 0 && depth_sqbracket == 0) {
                if (depth_anglebracket != 0) {
                  depth_anglebracket -= 1;
                }
              }
            }
            break;
          case "<":
            {
              if (depth_paren == 0 && depth_sqbracket == 0) {
                depth_anglebracket += 1;
              }
            }
            break;
          case "{":
          case "}":
            {
              if (depth_paren == 0 && depth_sqbracket == 0 && depth_anglebracket == 0) {
                return -1;
              }
            }
            break;
        }
      }
      return -1;
    }
    function isEditScope(inScope) {
      if (!inScope)
        return false;
      let funcScope = inScope.getParentFunctionScope();
      if (funcScope != null) {
        let dbFunc = funcScope.getDatabaseFunction();
        if (!dbFunc || dbFunc.name != "ConstructionScript")
          return false;
      } else if (inScope.scopetype == scriptfiles2.ASScopeType.LiteralAsset) {
        return true;
      } else if (inScope.scopetype != scriptfiles2.ASScopeType.Class) {
        return false;
      }
      return true;
    }
    function resolveModuleIsolation(module3) {
      let existing = ResolvedModuleDependencyIsolations.get(module3);
      if (existing === void 0) {
        let isolate = "";
        for (let restriction of IsolateRegexes) {
          let match = restriction.exec(module3);
          if (match) {
            isolate = match[0];
            break;
          }
        }
        for (let restriction of UnisolateRegexes) {
          let match = restriction.exec(module3);
          if (match) {
            isolate += "__unisolate";
            break;
          }
        }
        ResolvedModuleDependencyIsolations.set(module3, isolate);
        return isolate;
      } else {
        return existing;
      }
    }
    exports2.resolveModuleIsolation = resolveModuleIsolation;
    function isValidModuleDependency(module3, dependencyModule) {
      if (!dependencyModule)
        return true;
      let dependencyIsolation = resolveModuleIsolation(dependencyModule);
      if (dependencyIsolation) {
        let moduleIsolation = resolveModuleIsolation(module3);
        if (dependencyIsolation != moduleIsolation) {
          if (moduleIsolation.endsWith("__unisolate"))
            return true;
          if (!moduleIsolation.startsWith(dependencyIsolation))
            return false;
        }
      }
      return true;
    }
    exports2.isValidModuleDependency = isValidModuleDependency;
    function isPropertyAccessibleFromScope(curtype, prop, inScope) {
      if (curtype instanceof typedb2.DBNamespace) {
        if (curtype === typedb2.GetRootNamespace() && prop.declaredModule && prop.declaredModule != inScope.module.modulename) {
          return false;
        }
        if (prop.declaredModule && !isValidModuleDependency(inScope.module.modulename, prop.declaredModule))
          return false;
        return true;
      }
      if (!prop.containingType)
        return true;
      if (prop.isPrivate || prop.isProtected) {
        if (!inScope)
          return false;
        let dbtype = inScope.getParentType();
        if (!dbtype)
          return false;
        if (prop.isPrivate) {
          if (!curtype || dbtype.name != prop.containingType.name)
            return false;
        } else if (prop.isProtected) {
          if (!curtype || !dbtype.inheritsFrom(prop.containingType.name))
            return false;
        }
      } else if (prop.accessSpecifier) {
        let [readable, writable, editable] = prop.accessSpecifier.getAccess(inScope.getParentType(), inScope.getParentFunction());
        if (!readable && !editable)
          return false;
        else if (!readable && !isEditScope(inScope))
          return false;
        else if (!editable && isEditScope(inScope))
          return false;
      }
      if (prop.isEditOnly) {
        if (!isEditScope(inScope))
          return false;
      }
      if (prop.isNoEdit) {
        if (isEditScope(inScope))
          return false;
      }
      return true;
    }
    function isFunctionAccessibleFromScope(curtype, func, inScope) {
      if (!func.containingType && !func.isConstructor) {
        if (func.declaredModule) {
          if (func.isLocal || func.namespace.isRootNamespace() && !scriptfiles2.GetScriptSettings().exposeGlobalFunctions && !func.isMixin) {
            if (func.declaredModule != inScope.module.modulename)
              return false;
          }
          if (!isValidModuleDependency(inScope.module.modulename, func.declaredModule))
            return false;
        }
        return true;
      }
      if (func.isPrivate || func.isProtected) {
        if (!inScope)
          return false;
        let dbtype = inScope.getParentType();
        if (!dbtype)
          return false;
        if (func.isPrivate) {
          if (!curtype || dbtype.name != func.containingType.name)
            return false;
        } else if (func.isProtected) {
          if (!curtype || !dbtype.inheritsFrom(func.containingType.name))
            return false;
        }
      } else if (func.accessSpecifier) {
        let [readable, writable, editable] = func.accessSpecifier.getAccess(inScope.getParentType(), inScope.getParentFunction());
        if (!readable && !editable && !writable)
          return false;
        else if (!editable && isEditScope(inScope))
          return false;
        else if (!readable && !writable && !isEditScope(inScope))
          return false;
        else if (!writable && !func.isConst)
          return false;
      }
      if (func.isDefaultsOnly) {
        if (!isEditScope(inScope))
          return false;
      }
      return true;
    }
    function isTypeAccessibleFromScope(type, inScope) {
      if (!type.declaredModule)
        return true;
      if (!isValidModuleDependency(inScope.module.modulename, type.declaredModule))
        return false;
      return true;
    }
    function isNamespaceAccessibleFromScope(namespace, inScope) {
      let allowedNamespace = false;
      if (!namespace.declarations)
        return true;
      for (let decl of namespace.declarations) {
        if (!decl.declaredModule || isValidModuleDependency(inScope.module.modulename, decl.declaredModule))
          allowedNamespace = true;
      }
      if (!allowedNamespace)
        return false;
      return true;
    }
    function IsCodeEmpty(code) {
      return /^[\t \r\n]*$/.test(code);
    }
    function GetCodeOffsetIgnoreTable(code) {
      let ignoreTable = new Array();
      let inLineComment = false;
      let inBlockComment = false;
      let inPreproc = false;
      let sq_string = false;
      let dq_string = false;
      let escape_sequence = false;
      let inFormatString = false;
      let inFormatExpression = false;
      for (let index = 0, count = code.length; index < count; ++index) {
        let char = code[index];
        if (inLineComment) {
          if (char == "\n") {
            ignoreTable.push(index);
            inLineComment = false;
          }
          continue;
        }
        if (inBlockComment) {
          if (char == "*" && index + 1 < code.length && code[index + 1] == "/") {
            ignoreTable.push(index + 2);
            inBlockComment = false;
            index += 1;
          }
          continue;
        }
        if (inPreproc) {
          if (char == "\n") {
            ignoreTable.push(index);
            inPreproc = false;
          }
          continue;
        }
        if (inFormatString) {
          if (inFormatExpression) {
            if (char == "}") {
              inFormatExpression = false;
              ignoreTable.push(index);
            }
          } else {
            if (char == "{") {
              if (index + 1 < count && code[index + 1] == "{") {
                ++index;
                continue;
              }
              inFormatExpression = true;
              ignoreTable.push(index);
            }
          }
        }
        if (char == '"' && !sq_string) {
          if (dq_string) {
            if (!escape_sequence) {
              if (!inFormatExpression)
                ignoreTable.push(index + 1);
              dq_string = false;
              inFormatString = false;
              inFormatExpression = false;
            } else {
              escape_sequence = false;
            }
          } else {
            ignoreTable.push(index);
            dq_string = true;
            if (index > 0 && code[index - 1] == "f")
              inFormatString = true;
          }
        } else if (dq_string) {
          if (char == "\\")
            escape_sequence = !escape_sequence;
          else
            escape_sequence = false;
          continue;
        }
        if (char == "'" && !dq_string) {
          if (sq_string) {
            if (!escape_sequence) {
              ignoreTable.push(index + 1);
              sq_string = false;
            } else {
              escape_sequence = false;
            }
          } else {
            ignoreTable.push(index);
            sq_string = true;
          }
        } else if (sq_string) {
          if (char == "\\")
            escape_sequence = !escape_sequence;
          else
            escape_sequence = false;
          continue;
        }
        if (char == "/") {
          if (index + 1 < code.length) {
            let nextchar = code[index + 1];
            if (nextchar == "/") {
              ignoreTable.push(index);
              inLineComment = true;
              continue;
            } else if (nextchar == "*") {
              ignoreTable.push(index);
              index += 1;
              inBlockComment = true;
              continue;
            }
          }
        }
        if (char == "#") {
          ignoreTable.push(index);
          inPreproc = true;
          continue;
        }
      }
      if (inLineComment || inBlockComment || inPreproc || sq_string || dq_string)
        ignoreTable.push(code.length);
      return ignoreTable;
    }
    function AddMethodOverrideSnippets(context, completions, position) {
      let typeOfScope = context.scope ? context.scope.getDatabaseType() : null;
      if (!typeOfScope || !typeOfScope.supertype)
        return;
      let prevLineText = position.line == 0 ? "" : context.scope.module.textDocument.getText(node_12.Range.create(node_12.Position.create(position.line - 1, 0), node_12.Position.create(position.line, 0)));
      let curLineText = context.scope.module.textDocument.getText(node_12.Range.create(node_12.Position.create(position.line, 0), node_12.Position.create(position.line + 1, 0)));
      let hasUFunctionMacro = prevLineText.indexOf("UFUNCTION") != -1;
      let textEdits = new Array();
      let currentIndent = "";
      for (let char of curLineText) {
        if (char == " " || char == "	")
          currentIndent += char;
        else
          break;
      }
      let hasReturnType = curLineText.trim().indexOf(context.completingSymbol) != 0;
      textEdits.push(node_12.TextEdit.insert(node_12.Position.create(position.line + 1, 0), currentIndent + "}\n"));
      let textEditsForEvent = new Array();
      if (!hasUFunctionMacro) {
        textEditsForEvent.push(node_12.TextEdit.insert(node_12.Position.create(position.line, 0), currentIndent + "UFUNCTION(BlueprintOverride)\n"));
      }
      let foundOverrides = /* @__PURE__ */ new Set();
      typeOfScope.forEachSymbol(function(sym) {
        if (!(sym instanceof typedb2.DBMethod))
          return;
        let method = sym;
        let parentMethod = null;
        if (method.containingType == typeOfScope) {
          let parentType = typeOfScope.getSuperType();
          if (parentType) {
            let parentSymbol = parentType.findFirstSymbol(method.name, typedb2.DBAllowSymbol.Functions);
            if (parentSymbol instanceof typedb2.DBMethod)
              parentMethod = parentSymbol;
          }
        } else {
          parentMethod = method;
        }
        let includeReturnType = false;
        let includeParamsOnly = false;
        if (method.containingType == typeOfScope && !parentMethod)
          return;
        if (method.name && CanCompleteTo(context, method.name))
          includeParamsOnly = true;
        if (method.returnType && CanCompleteTo(context, method.returnType))
          includeReturnType = true;
        if (method.isPrivate)
          return;
        if (!includeParamsOnly && !includeReturnType)
          return;
        if (sym.containingType.isUnrealType() && !method.isBlueprintEvent)
          return;
        if (foundOverrides.has(method.name))
          return;
        foundOverrides.add(method.name);
        if (method.isFinal)
          return;
        let complStr = GetDeclarationSnippet(method, currentIndent, false);
        let complEdits = textEdits;
        if (method.isBlueprintEvent)
          complEdits = complEdits.concat(textEditsForEvent);
        let superStr = "";
        if (parentMethod && parentMethod.declaredModule && (!parentMethod.returnType || parentMethod.returnType == "void" || parentMethod.hasMetaData("RequireSuperCall"))) {
          superStr += "Super::" + method.name + "(";
          for (let i = 0; i < method.args.length; ++i) {
            if (i != 0)
              superStr += ", ";
            superStr += method.args[i].name;
          }
          superStr += ");";
          if (parentMethod.returnType && parentMethod.returnType != "void")
            superStr = "return " + superStr;
          else
            superStr += "\n" + currentIndent;
        }
        if (includeParamsOnly) {
          if (!hasReturnType) {
            complEdits = complEdits.concat(node_12.TextEdit.replace(node_12.Range.create(node_12.Position.create(position.line, 0), node_12.Position.create(position.line, position.character - context.completingSymbol.length)), currentIndent + method.returnType + " "));
          }
          completions.push({
            label: method.returnType + " " + method.name + "(...)",
            filterText: method.name,
            insertText: complStr + "{\n" + currentIndent + superStr,
            kind: node_12.CompletionItemKind.Snippet,
            data: ["decl_snippet", method.containingType.name, method.name, method.id],
            additionalTextEdits: complEdits,
            sortText: Sort.Method_Override_Snippet
          });
        } else if (includeReturnType) {
          completions.push({
            label: method.returnType + " " + method.name + "(...)",
            insertText: method.returnType + " " + complStr + "{\n" + currentIndent + superStr,
            kind: node_12.CompletionItemKind.Snippet,
            data: ["decl_snippet", method.containingType.name, method.name, method.id],
            additionalTextEdits: complEdits,
            sortText: Sort.Method_Override_Snippet
          });
        }
      });
    }
    function GetDeclarationSnippet(method, indent, includeReturnType) {
      let preambleLength = method.name.length + 2;
      if (method.returnType)
        preambleLength += method.returnType.length;
      else
        preambleLength += 4;
      let complStr = "";
      if (includeReturnType)
        complStr += method.returnType + " ";
      complStr += method.name + "(";
      let lineLength = preambleLength;
      if (indent)
        lineLength += indent.length;
      if (method.args) {
        for (let i = 0; i < method.args.length; ++i) {
          let arg = method.args[i];
          let argLength = arg.typename.length;
          if (arg.name)
            argLength += arg.name.length + 1;
          if (lineLength + argLength > 100 && indent != null) {
            if (i != 0) {
              complStr += ",";
              lineLength += 1;
            }
            complStr += "\n" + " ".repeat(preambleLength);
            lineLength = indent.length + preambleLength;
          } else if (i != 0) {
            complStr += ", ";
            lineLength += 2;
          }
          complStr += arg.typename;
          if (arg.name) {
            complStr += " ";
            complStr += arg.name;
          }
          lineLength += argLength;
        }
      }
      complStr += ")";
      if (method.isConst)
        complStr += " const";
      if (!method.isBlueprintEvent)
        complStr += " override";
      if (!method.isBlueprintEvent && method.isProperty && method.declaredModule)
        complStr += " property";
      complStr += "\n";
      return complStr;
    }
    function NoBreakingSpaces(decl) {
      return decl.replace(/ /g, "\xA0");
    }
    function NicifyDefinition(func, def) {
      if (def.length < 40 || !func.args || func.args.length == 0)
        return def;
      def = def.replace("(", "(\n	");
      def = def.replace(/, /g, ",\n	");
      return def;
    }
    function Resolve(item) {
      if (!item.data)
        return null;
      let dataArray = item.data;
      let kind = dataArray[0];
      if (kind == "type") {
        let type = typedb2.GetTypeByName(dataArray[1]);
        if (type == null)
          return null;
        if (type.documentation)
          item.documentation = type.documentation.replace(/\n/g, "\n\n");
        return item;
      } else if (kind == "namespace") {
        let type = typedb2.LookupNamespace(null, dataArray[1]);
        if (type == null)
          return null;
        if (type.documentation)
          item.documentation = type.documentation.replace(/\n/g, "\n\n");
        return item;
      } else if (kind == "enum" || kind == "prop" || kind == "global_prop") {
        let type;
        if (kind == "global_prop")
          type = typedb2.LookupNamespace(null, dataArray[1]);
        else
          type = typedb2.GetTypeByName(dataArray[1]);
        if (type == null)
          return null;
        if (type == null)
          return null;
        let prop = type.findFirstSymbol(dataArray[2], typedb2.DBAllowSymbol.Properties);
        if (prop instanceof typedb2.DBProperty) {
          item.documentation = {
            kind: node_12.MarkupKind.Markdown,
            value: "```angelscript_snippet\n" + NoBreakingSpaces(prop.format()) + "\n```\n\n"
          };
          if (prop.documentation)
            item.documentation.value += "\n\n" + (0, documentation_1.FormatPropertyDocumentation)(prop.documentation) + "\n\n";
          if (kind == "prop") {
            item.labelDetails = {
              description: prop.typename
            };
          }
        }
      } else if (kind == "accessor" || kind == "global_accessor") {
        let type;
        if (kind == "global_accessor")
          type = typedb2.LookupNamespace(null, dataArray[1]);
        else
          type = typedb2.GetTypeByName(dataArray[1]);
        if (type == null)
          return null;
        let getFunc = type.findFirstSymbol("Get" + dataArray[2], typedb2.DBAllowSymbol.Functions);
        let setFunc = type.findFirstSymbol("Set" + dataArray[2], typedb2.DBAllowSymbol.Functions);
        let docStr = "";
        if (getFunc) {
          docStr += "```angelscript_snippet\n" + getFunc.returnType + "\xA0" + dataArray[2] + "\n```\n\n";
          item.labelDetails = {
            description: getFunc.returnType
          };
        } else if (setFunc && setFunc.args && setFunc.args.length >= 1) {
          docStr += "```angelscript_snippet\n" + setFunc.args[0].typename + "\xA0" + dataArray[2] + "\n```\n\n";
          item.labelDetails = {
            description: setFunc.args[0].typename
          };
        }
        let doc = null;
        if (getFunc)
          doc = getFunc.findAvailableDocumentation();
        if (!doc && setFunc)
          doc = setFunc.findAvailableDocumentation();
        if (doc)
          docStr += "\n" + doc.replace(/\n/g, "\n\n") + "\n\n";
        item.documentation = {
          kind: node_12.MarkupKind.Markdown,
          value: docStr
        };
      } else if (kind == "func" || kind == "func_mixin" || kind == "global_func") {
        let type;
        if (kind == "global_func" || kind == "func_mixin")
          type = typedb2.LookupNamespace(null, dataArray[1]);
        else
          type = typedb2.GetTypeByName(dataArray[1]);
        if (type == null)
          return null;
        let func = null;
        for (let checkMethod of type.findSymbols(dataArray[2])) {
          if (checkMethod instanceof typedb2.DBMethod) {
            if (checkMethod.id == dataArray[3]) {
              func = checkMethod;
              break;
            } else if (!func) {
              func = checkMethod;
            }
          }
        }
        if (func) {
          let isMixin = kind == "func_mixin";
          let complStr = NoBreakingSpaces(NicifyDefinition(func, func.format(null, isMixin)));
          item.documentation = {
            kind: node_12.MarkupKind.Markdown,
            value: "```angelscript_snippet\n" + complStr + "\n```\n\n"
          };
          let doc = func.findAvailableDocumentation();
          if (doc)
            item.documentation.value += "\n\n" + (0, documentation_1.FormatFunctionDocumentation)(doc, func, null, false);
          item.labelDetails = {
            detail: func.args && func.args.length > 0 ? FunctionLabelWithParamsSuffix : FunctionLabelSuffix
          };
          item.command = {
            title: "",
            command: "angelscript.paren"
          };
          if (func.returnType && func.returnType != "void")
            item.labelDetails.description = func.returnType;
        }
      } else if (kind == "decl_snippet") {
        let type = typedb2.GetTypeByName(dataArray[1]);
        if (type == null)
          return null;
        let func = type.getMethodWithIdHint(dataArray[2], dataArray[3]);
        if (func) {
          let complStr = NoBreakingSpaces(GetDeclarationSnippet(func, null, true));
          item.documentation = {
            kind: node_12.MarkupKind.Markdown,
            value: "```angelscript_snippet\n" + complStr + "\n```\n\n"
          };
          let doc = func.findAvailableDocumentation();
          if (doc)
            item.documentation.value += "\n\n" + (0, documentation_1.FormatFunctionDocumentation)(doc, func, null, false);
        }
      }
      return item;
    }
    exports2.Resolve = Resolve;
    function AddSuperCallSnippet(context, completions) {
      if (!context.statement || !context.statement.ast)
        return;
      let nsNode = context.statement.ast;
      if (context.statement.ast.type == scriptfiles2.node_types.ReturnStatement)
        nsNode = context.statement.ast.children[0];
      if (nsNode.type != scriptfiles2.node_types.NamespaceAccess)
        return;
      if (!nsNode.children[0] || nsNode.children[0].value != "Super")
        return;
      let scopeFunction = context.scope.getParentFunction();
      let scopeType = context.scope.getParentType();
      if (!scopeType || !scopeFunction)
        return;
      let superType = scopeType.getSuperType();
      if (!superType)
        return;
      let superFunction = superType.findFirstSymbol(scopeFunction.name, typedb2.DBAllowSymbol.Functions);
      if (!(superFunction instanceof typedb2.DBMethod))
        return;
      let insertText = "";
      if (context.isIncompleteNamespace)
        insertText += ":";
      insertText += superFunction.name;
      insertText += "(";
      if (scopeFunction.args) {
        for (let i = 0; i < scopeFunction.args.length; ++i) {
          if (i != 0)
            insertText += ", ";
          insertText += scopeFunction.args[i].name;
        }
      }
      insertText += ");";
      context.havePreselection = true;
      completions.push({
        label: "Super::" + scopeFunction.name + "(...)",
        filterText: scopeFunction.name + "(...)",
        insertText,
        kind: node_12.CompletionItemKind.Snippet,
        preselect: true,
        sortText: Sort.Snippet
      });
    }
    function AddMathShortcutCompletions(context, completions) {
      if (!CompletionSettings.mathCompletionShortcuts)
        return;
      let mathNamespace = typedb2.LookupNamespace(null, "Math");
      if (!mathNamespace)
        mathNamespace = typedb2.LookupNamespace(null, "FMath");
      if (!mathNamespace)
        return;
      if (context.isIncompleteNamespace)
        return;
      let unexpectedCompletions = new Array();
      let completionNames = /* @__PURE__ */ new Set();
      mathNamespace.forEachSymbol(function(symbol) {
        if (!(symbol instanceof typedb2.DBMethod))
          return;
        let func = symbol;
        if (!CanCompleteToOnlyStart(context, func.name))
          return;
        let commitChars = ["("];
        let compl = {
          label: mathNamespace.name + "::" + func.name,
          kind: node_12.CompletionItemKind.Method,
          data: ["global_func", mathNamespace.name, func.name, func.id],
          commitCharacters: commitChars,
          filterText: func.name,
          sortText: Sort.Math_Shortcut
        };
        compl.labelDetails = {
          detail: func.args && func.args.length > 0 ? FunctionLabelWithParamsSuffix : FunctionLabelSuffix
        };
        compl.command = {
          title: "",
          command: "angelscript.paren"
        };
        if (func.returnType && func.returnType != "void") {
          compl.labelDetails.description = func.returnType;
          if (!typedb2.IsPrimitive(func.returnType))
            compl.commitCharacters.push(".");
        }
        if (context.expectedType && !context.isTypeExpected(func.returnType)) {
          unexpectedCompletions.push(compl);
          return;
        }
        completions.push(compl);
        completionNames.add(compl.label);
      });
      for (let compl of unexpectedCompletions) {
        if (completionNames.has(compl.label))
          continue;
        completions.push(compl);
      }
    }
    exports2.AddMathShortcutCompletions = AddMathShortcutCompletions;
    function AddCompletionsFromAccessSpecifiers(context, completions) {
      if (context.isTypingAccessSpecifier) {
        let scopeType = context.scope.getParentType();
        if (scopeType && scopeType.acccessSpecifiers) {
          for (let spec of scopeType.acccessSpecifiers) {
            let compl = {
              label: spec.name,
              kind: node_12.CompletionItemKind.Keyword
            };
            completions.push(compl);
          }
        }
        return true;
      } else if (context.baseStatement && context.baseStatement.ast && context.baseStatement.ast.type == scriptfiles2.node_types.AccessDeclaration) {
        AddCompletionsFromKeywordList(context, [
          "private",
          "protected",
          "readonly",
          "editdefaults",
          "inherited"
        ], completions);
        for (let [_, dbtype] of typedb2.GetAllTypesById()) {
          if (dbtype.isTemplateInstantiation)
            continue;
          if (dbtype.isEnum)
            continue;
          if (CanCompleteSymbol(context, dbtype)) {
            let complItem = {
              label: dbtype.name,
              kind: node_12.CompletionItemKind.Class,
              data: ["type", dbtype.name],
              commitCharacters: [",", ";"],
              sortText: Sort.Typename
            };
            completions.push(complItem);
          }
        }
        for (let [_, ns] of typedb2.GetRootNamespace().childNamespaces) {
          if (CanCompleteSymbol(context, ns)) {
            let complItem = {
              label: ns.name,
              kind: node_12.CompletionItemKind.Module,
              data: ["namespace", ns.getQualifiedNamespace()],
              commitCharacters: [",", ";"],
              sortText: Sort.Typename
            };
            completions.push(complItem);
          }
        }
        let checkNamespace = context.scope.getNamespace();
        while (checkNamespace) {
          checkNamespace.forEachSymbol(function(sym) {
            if (sym instanceof typedb2.DBMethod) {
              let compl = {
                label: sym.name,
                kind: node_12.CompletionItemKind.Method,
                data: ["global_func", sym.namespace.getQualifiedNamespace(), sym.name, sym.id],
                commitCharacters: [",", ";"],
                sortText: Sort.Unimported
              };
              compl.labelDetails = {
                detail: sym.args && sym.args.length > 0 ? FunctionLabelWithParamsSuffix : FunctionLabelSuffix
              };
              if (sym.returnType && sym.returnType != "void")
                compl.labelDetails.description = sym.returnType;
              completions.push(compl);
            }
          });
          checkNamespace = checkNamespace.parentNamespace;
        }
        return true;
      } else {
        return false;
      }
    }
    function HandleFloatLiteralHelper(asmodule) {
      if (asmodule.lastEditStart == -1)
        return;
      if (!CompletionSettings.correctFloatLiteralsWhenExpectingDoublePrecision)
        return;
      let areaStart = Math.max(asmodule.lastEditStart - 10, 0);
      let editedString = asmodule.content.substring(areaStart, Math.min(asmodule.lastEditEnd, asmodule.content.length));
      let matches = Array.from(editedString.matchAll(/([0-9]+)\.([0-9])*f/g));
      if (!matches || matches.length == 0)
        return;
      let match = matches[matches.length - 1];
      let matchStart = areaStart + match.index;
      let matchEnd = matchStart + match[0].length;
      if (matchEnd < asmodule.lastEditStart)
        return;
      return new Promise(function(resolve, reject) {
        asmodule.onResolved(() => {
          if (asmodule.content.substring(matchStart, matchEnd) != match[0]) {
            reject();
            return;
          }
          let context = GenerateCompletionContext(asmodule, matchStart);
          let expectingDoubleFloat = false;
          if (context.expectedType) {
            if (typedb2.ArePrimitiveTypesEquivalent(context.expectedType.name, "float64"))
              expectingDoubleFloat = true;
            else if (context.expectedType.name == "FVector")
              expectingDoubleFloat = true;
          }
          if (expectingDoubleFloat) {
            let edit = {};
            edit.changes = {};
            if (match[2] && match[2].length != 0) {
              edit.changes[asmodule.displayUri] = [
                node_12.TextEdit.del(asmodule.getRange(matchEnd - 1, matchEnd))
              ];
            } else {
              edit.changes[asmodule.displayUri] = [
                node_12.TextEdit.replace(asmodule.getRange(matchEnd - 1, matchEnd), "0")
              ];
            }
            resolve(edit);
          } else {
            resolve(null);
          }
        });
      });
    }
    exports2.HandleFloatLiteralHelper = HandleFloatLiteralHelper;
    function GetExpectedTypeAtOffset(asmodule, offset) {
      if (!asmodule)
        return null;
      let context = GenerateCompletionContext(asmodule, offset);
      return context.expectedType;
    }
    exports2.GetExpectedTypeAtOffset = GetExpectedTypeAtOffset;
  }
});

// unreal-angelscript-lsp/language-server/out/references.js
var require_references = __commonJS({
  "unreal-angelscript-lsp/language-server/out/references.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PerformRename = exports2.PrepareRename = exports2.FindReferences = void 0;
    var scriptfiles2 = require_as_parser();
    var typedb2 = require_database();
    var vscode_languageserver_1 = require_main4();
    function* FindReferences(uri, position) {
      let references = new Array();
      let asmodule = scriptfiles2.GetModuleByUri(uri);
      if (!asmodule)
        return references;
      scriptfiles2.ParseModuleAndDependencies(asmodule);
      scriptfiles2.PostProcessModuleTypesAndDependencies(asmodule);
      scriptfiles2.ResolveModule(asmodule);
      let offset = asmodule.getOffset(position);
      let findSymbol = asmodule.getSymbolAtOrBefore(offset);
      if (!findSymbol)
        return references;
      if (findSymbol.type == scriptfiles2.ASSymbolType.UnknownError)
        return references;
      if (findSymbol.type == scriptfiles2.ASSymbolType.LocalVariable || findSymbol.type == scriptfiles2.ASSymbolType.Parameter) {
        let declaredScope = asmodule.getScopeDeclaringLocalSymbol(findSymbol);
        if (!declaredScope)
          return references;
        for (let symbol of asmodule.semanticSymbols) {
          if (symbol.type != findSymbol.type)
            continue;
          if (symbol.container_type != findSymbol.container_type)
            continue;
          if (symbol.symbol_name != findSymbol.symbol_name)
            continue;
          if (symbol.start >= declaredScope.end_offset)
            continue;
          if (symbol.end < declaredScope.start_offset)
            continue;
          references.push(asmodule.getLocationRange(symbol.start, symbol.end));
        }
        return references;
      }
      let alternateType = scriptfiles2.ASSymbolType.NoSymbol;
      if (findSymbol.type == scriptfiles2.ASSymbolType.MemberAccessor)
        alternateType = scriptfiles2.ASSymbolType.MemberFunction;
      else if (findSymbol.type == scriptfiles2.ASSymbolType.GlobalAccessor)
        alternateType = scriptfiles2.ASSymbolType.GlobalFunction;
      else if (findSymbol.type == scriptfiles2.ASSymbolType.MemberFunction)
        alternateType = scriptfiles2.ASSymbolType.MemberAccessor;
      else if (findSymbol.type == scriptfiles2.ASSymbolType.GlobalFunction)
        alternateType = scriptfiles2.ASSymbolType.GlobalAccessor;
      let considerModules = null;
      if (findSymbol.type == scriptfiles2.ASSymbolType.AccessSpecifier)
        considerModules = [asmodule];
      else
        considerModules = scriptfiles2.GetModulesPotentiallyImportingSymbol(asmodule, findSymbol);
      let searchForTypes = /* @__PURE__ */ new Set();
      searchForTypes.add(findSymbol.container_type);
      if (findSymbol.type == scriptfiles2.ASSymbolType.MemberFunction || findSymbol.type == scriptfiles2.ASSymbolType.MemberAccessor) {
        let checkParent = typedb2.GetTypeByName(findSymbol.container_type);
        while (checkParent) {
          let nextParent = checkParent.getSuperType();
          if (nextParent && nextParent.findFirstSymbol(findSymbol.symbol_name, typedb2.DBAllowSymbol.Functions)) {
            checkParent = nextParent;
            continue;
          } else {
            break;
          }
        }
        if (checkParent && checkParent.name != findSymbol.container_type) {
          if (checkParent.declaredModule)
            considerModules = scriptfiles2.GetModulesPotentiallyImporting(checkParent.declaredModule);
          else
            considerModules = scriptfiles2.GetAllLoadedModules();
        }
        searchForTypes.add(checkParent.name);
        let lastTypeCount = 0;
        while (lastTypeCount != searchForTypes.size) {
          lastTypeCount = searchForTypes.size;
          for (let [_, searchType] of typedb2.GetAllTypesById()) {
            if (searchType && searchForTypes.has(searchType.supertype))
              searchForTypes.add(searchType.name);
          }
        }
      }
      let auxSymbols = null;
      {
        if (findSymbol.type == scriptfiles2.ASSymbolType.GlobalFunction || findSymbol.type == scriptfiles2.ASSymbolType.GlobalVariable || findSymbol.type == scriptfiles2.ASSymbolType.GlobalAccessor) {
          let insideNamespace = typedb2.LookupNamespace(null, findSymbol.container_type);
          if (insideNamespace) {
            let findDbSym = insideNamespace.findFirstSymbol(findSymbol.symbol_name);
            if (findDbSym)
              auxSymbols = findDbSym.auxiliarySymbols;
          }
        } else {
          let insideType = typedb2.GetTypeByName(findSymbol.container_type);
          if (insideType) {
            let findDbSym = insideType.findFirstSymbol(findSymbol.symbol_name);
            if (findDbSym)
              auxSymbols = findDbSym.auxiliarySymbols;
          }
        }
        if (auxSymbols) {
          for (let auxSym of auxSymbols)
            searchForTypes.add(auxSym.container_type);
        }
      }
      let parseCount = 0;
      for (let checkmodule of considerModules) {
        parseCount += 1;
        scriptfiles2.ParseModuleAndDependencies(checkmodule);
        scriptfiles2.PostProcessModuleTypesAndDependencies(checkmodule);
        scriptfiles2.ResolveModule(checkmodule);
        if (auxSymbols) {
          for (let symbol of checkmodule.semanticSymbols) {
            if (!searchForTypes.has(symbol.container_type))
              continue;
            let matchesSymbol = false;
            if ((symbol.type == findSymbol.type || symbol.type == alternateType) && symbol.symbol_name == findSymbol.symbol_name && searchForTypes.has(symbol.container_type)) {
              matchesSymbol = true;
            } else {
              for (let auxSym of auxSymbols) {
                if (symbol.symbol_name == auxSym.symbol_name && symbol.container_type == auxSym.container_type) {
                  matchesSymbol = true;
                  break;
                }
              }
            }
            if (!matchesSymbol)
              continue;
            references.push(checkmodule.getLocationRange(symbol.start, symbol.end));
          }
        } else {
          for (let symbol of checkmodule.semanticSymbols) {
            if (symbol.type != findSymbol.type && symbol.type != alternateType)
              continue;
            if (symbol.symbol_name != findSymbol.symbol_name)
              continue;
            if (!searchForTypes.has(symbol.container_type))
              continue;
            references.push(checkmodule.getLocationRange(symbol.start, symbol.end));
          }
        }
        if (parseCount >= 100) {
          parseCount = 0;
          yield null;
        }
      }
      return references;
    }
    exports2.FindReferences = FindReferences;
    function PrepareRename(uri, position) {
      let asmodule = scriptfiles2.GetModuleByUri(uri);
      if (!asmodule)
        return null;
      scriptfiles2.ParseModuleAndDependencies(asmodule);
      scriptfiles2.PostProcessModuleTypesAndDependencies(asmodule);
      scriptfiles2.ResolveModule(asmodule);
      let offset = asmodule.getOffset(position);
      let findSymbol = asmodule.getSymbolAtOrBefore(offset);
      if (!findSymbol)
        return null;
      if (findSymbol.type == scriptfiles2.ASSymbolType.UnknownError)
        return null;
      switch (findSymbol.type) {
        case scriptfiles2.ASSymbolType.Typename:
        case scriptfiles2.ASSymbolType.TemplateBaseType:
          {
            let dbtype = typedb2.GetTypeByName(findSymbol.symbol_name);
            if (!dbtype.declaredModule)
              return new vscode_languageserver_1.ResponseError(0, "Cannot rename symbols declared in C++");
          }
          break;
        case scriptfiles2.ASSymbolType.Namespace:
          {
            let namespace = typedb2.LookupNamespace(null, findSymbol.symbol_name);
            if (namespace.getCppDeclaration())
              return new vscode_languageserver_1.ResponseError(0, "Cannot rename symbols declared in C++");
          }
          break;
        case scriptfiles2.ASSymbolType.GlobalFunction:
        case scriptfiles2.ASSymbolType.GlobalAccessor:
          {
            let namespace = typedb2.LookupNamespace(null, findSymbol.container_type);
            if (!namespace)
              return null;
            let dbmethod = namespace.findFirstSymbol(findSymbol.symbol_name, typedb2.DBAllowSymbol.FunctionsAndMixins);
            if (!(dbmethod instanceof typedb2.DBMethod))
              return null;
            if (!dbmethod.declaredModule)
              return new vscode_languageserver_1.ResponseError(0, "Cannot rename symbols declared in C++");
            if (dbmethod.isAutoGenerated)
              return new vscode_languageserver_1.ResponseError(0, "Cannot rename autogenerated symbols.");
          }
          break;
        case scriptfiles2.ASSymbolType.MemberFunction:
        case scriptfiles2.ASSymbolType.MemberAccessor:
          {
            let dbtype = typedb2.GetTypeByName(findSymbol.container_type);
            if (!dbtype)
              return null;
            let dbmethod = dbtype.findFirstSymbol(findSymbol.symbol_name, typedb2.DBAllowSymbol.FunctionsAndMixins);
            if (!(dbmethod instanceof typedb2.DBMethod))
              return null;
            if (!dbmethod.declaredModule)
              return new vscode_languageserver_1.ResponseError(0, "Cannot rename symbols declared in C++");
            if (dbmethod.isAutoGenerated)
              return new vscode_languageserver_1.ResponseError(0, "Cannot rename autogenerated symbols.");
          }
          break;
        case scriptfiles2.ASSymbolType.GlobalVariable:
          {
            let namespace = typedb2.LookupNamespace(null, findSymbol.container_type);
            if (!namespace)
              return null;
            let dbprop = namespace.findFirstSymbol(findSymbol.symbol_name, typedb2.DBAllowSymbol.Properties);
            if (!(dbprop instanceof typedb2.DBProperty))
              return null;
            if (!dbprop.declaredModule)
              return new vscode_languageserver_1.ResponseError(0, "Cannot rename symbols declared in C++");
            if (dbprop.isAutoGenerated)
              return new vscode_languageserver_1.ResponseError(0, "Cannot rename autogenerated symbols.");
          }
          break;
        case scriptfiles2.ASSymbolType.MemberVariable:
          {
            let dbtype = typedb2.GetTypeByName(findSymbol.container_type);
            if (!dbtype)
              return null;
            let dbprop = dbtype.findFirstSymbol(findSymbol.symbol_name, typedb2.DBAllowSymbol.Properties);
            if (!(dbprop instanceof typedb2.DBProperty))
              return null;
            if (!dbprop.declaredModule)
              return new vscode_languageserver_1.ResponseError(0, "Cannot rename symbols declared in C++");
            if (dbprop.isAutoGenerated)
              return new vscode_languageserver_1.ResponseError(0, "Cannot rename autogenerated symbols.");
          }
          break;
      }
      return asmodule.getRange(findSymbol.start, findSymbol.end);
    }
    exports2.PrepareRename = PrepareRename;
    function* PerformRename(uri, position, baseReplaceWith) {
      let edits = /* @__PURE__ */ new Map();
      let asmodule = scriptfiles2.GetModuleByUri(uri);
      if (!asmodule)
        return edits;
      scriptfiles2.ParseModuleAndDependencies(asmodule);
      scriptfiles2.PostProcessModuleTypesAndDependencies(asmodule);
      scriptfiles2.ResolveModule(asmodule);
      let offset = asmodule.getOffset(position);
      let findSymbol = asmodule.getSymbolAtOrBefore(offset);
      if (!findSymbol)
        return edits;
      if (findSymbol.type == scriptfiles2.ASSymbolType.UnknownError)
        return edits;
      switch (findSymbol.type) {
        case scriptfiles2.ASSymbolType.Typename:
        case scriptfiles2.ASSymbolType.TemplateBaseType:
          {
            let dbtype = typedb2.GetTypeByName(findSymbol.symbol_name);
            if (!dbtype.declaredModule)
              return edits;
          }
          break;
        case scriptfiles2.ASSymbolType.Namespace:
          let namespace = typedb2.LookupNamespace(null, findSymbol.symbol_name);
          if (namespace.getCppDeclaration())
            return edits;
          break;
        case scriptfiles2.ASSymbolType.MemberFunction:
        case scriptfiles2.ASSymbolType.MemberAccessor:
          {
            let dbtype = typedb2.GetTypeByName(findSymbol.container_type);
            if (!dbtype)
              return edits;
            let dbmethod = dbtype.findFirstSymbol(findSymbol.symbol_name, typedb2.DBAllowSymbol.FunctionsAndMixins);
            if (!(dbmethod instanceof typedb2.DBMethod))
              return edits;
            if (!dbmethod.declaredModule)
              return edits;
            if (dbmethod.isAutoGenerated)
              return edits;
          }
          break;
        case scriptfiles2.ASSymbolType.GlobalFunction:
        case scriptfiles2.ASSymbolType.GlobalAccessor:
          {
            let namespace2 = typedb2.LookupNamespace(null, findSymbol.container_type);
            if (!namespace2)
              return edits;
            let dbmethod = namespace2.findFirstSymbol(findSymbol.symbol_name, typedb2.DBAllowSymbol.FunctionsAndMixins);
            if (!(dbmethod instanceof typedb2.DBMethod))
              return edits;
            if (!dbmethod.declaredModule)
              return edits;
            if (dbmethod.isAutoGenerated)
              return edits;
          }
          break;
        case scriptfiles2.ASSymbolType.GlobalVariable:
          {
            let namespace2 = typedb2.LookupNamespace(null, findSymbol.container_type);
            if (!namespace2)
              return edits;
            let dbprop = namespace2.findFirstSymbol(findSymbol.symbol_name, typedb2.DBAllowSymbol.Properties);
            if (!(dbprop instanceof typedb2.DBProperty))
              return edits;
            if (!dbprop.declaredModule)
              return edits;
            if (dbprop.isAutoGenerated)
              return edits;
          }
          break;
        case scriptfiles2.ASSymbolType.MemberVariable:
          {
            let dbtype = typedb2.GetTypeByName(findSymbol.container_type);
            if (!dbtype)
              return edits;
            let dbprop = dbtype.findFirstSymbol(findSymbol.symbol_name, typedb2.DBAllowSymbol.Properties);
            if (!(dbprop instanceof typedb2.DBProperty))
              return edits;
            if (!dbprop.declaredModule)
              return edits;
            if (dbprop.isAutoGenerated)
              return edits;
          }
          break;
      }
      let replaceText = baseReplaceWith;
      switch (findSymbol.type) {
        case scriptfiles2.ASSymbolType.MemberAccessor:
        case scriptfiles2.ASSymbolType.GlobalAccessor:
          {
            if (findSymbol.symbol_name.startsWith("Get"))
              replaceText = "Get" + replaceText;
            else if (findSymbol.symbol_name.startsWith("Set"))
              replaceText = "Set" + replaceText;
          }
          break;
      }
      let accessorReplaceText = replaceText;
      if (accessorReplaceText.startsWith("Get") || accessorReplaceText.startsWith("Set"))
        accessorReplaceText = accessorReplaceText.substr(3);
      let scopeLimited = false;
      let considerScopes = [];
      if (findSymbol.type == scriptfiles2.ASSymbolType.LocalVariable)
        scopeLimited = true;
      else if (findSymbol.type == scriptfiles2.ASSymbolType.Parameter)
        scopeLimited = true;
      if (scopeLimited) {
        let fileEdits = new Array();
        edits.set(asmodule.displayUri, fileEdits);
        let declaredScope = asmodule.getScopeDeclaringLocalSymbol(findSymbol);
        if (!declaredScope)
          return edits;
        for (let symbol of asmodule.semanticSymbols) {
          if (symbol.type != findSymbol.type)
            continue;
          if (symbol.container_type != findSymbol.container_type)
            continue;
          if (symbol.symbol_name != findSymbol.symbol_name)
            continue;
          if (symbol.isAuto)
            continue;
          if (symbol.start >= declaredScope.end_offset)
            continue;
          if (symbol.end < declaredScope.start_offset)
            continue;
          fileEdits.push(vscode_languageserver_1.TextEdit.replace(asmodule.getRange(symbol.start, symbol.end), replaceText));
        }
      } else {
        let alternateType = scriptfiles2.ASSymbolType.NoSymbol;
        if (findSymbol.type == scriptfiles2.ASSymbolType.MemberAccessor)
          alternateType = scriptfiles2.ASSymbolType.MemberFunction;
        else if (findSymbol.type == scriptfiles2.ASSymbolType.GlobalAccessor)
          alternateType = scriptfiles2.ASSymbolType.GlobalFunction;
        else if (findSymbol.type == scriptfiles2.ASSymbolType.MemberFunction)
          alternateType = scriptfiles2.ASSymbolType.MemberAccessor;
        else if (findSymbol.type == scriptfiles2.ASSymbolType.GlobalFunction)
          alternateType = scriptfiles2.ASSymbolType.GlobalAccessor;
        let parseCount = 0;
        let considerModules = null;
        if (findSymbol.type == scriptfiles2.ASSymbolType.AccessSpecifier)
          considerModules = [asmodule];
        else
          considerModules = scriptfiles2.GetModulesPotentiallyImportingSymbol(asmodule, findSymbol);
        for (let checkmodule of considerModules) {
          if (!checkmodule.exists)
            continue;
          parseCount += 1;
          scriptfiles2.ParseModuleAndDependencies(checkmodule);
          scriptfiles2.PostProcessModuleTypesAndDependencies(checkmodule);
          scriptfiles2.ResolveModule(checkmodule);
          let fileEdits = null;
          for (let symbol of checkmodule.semanticSymbols) {
            if (symbol.type != findSymbol.type && symbol.type != alternateType)
              continue;
            if (symbol.container_type != findSymbol.container_type)
              continue;
            if (symbol.symbol_name != findSymbol.symbol_name)
              continue;
            if (symbol.isAuto)
              continue;
            if (!fileEdits) {
              fileEdits = new Array();
              edits.set(checkmodule.displayUri, fileEdits);
            }
            let symbolRange = checkmodule.getRange(symbol.start, symbol.end);
            if (checkmodule.textDocument) {
              let originalText = checkmodule.textDocument.getText(symbolRange);
              if (symbol.type == scriptfiles2.ASSymbolType.Typename && originalText == "Super")
                continue;
            }
            let isAccessor = symbol.type == scriptfiles2.ASSymbolType.MemberAccessor || symbol.type == scriptfiles2.ASSymbolType.GlobalAccessor;
            fileEdits.push(vscode_languageserver_1.TextEdit.replace(symbolRange, isAccessor ? accessorReplaceText : replaceText));
          }
          if (fileEdits) {
            checkmodule.resolved = false;
          }
          if (parseCount >= 100) {
            parseCount = 0;
            yield null;
          }
        }
      }
      return edits;
    }
    exports2.PerformRename = PerformRename;
  }
});

// unreal-angelscript-lsp/language-server/out/highlight_occurances.js
var require_highlight_occurances = __commonJS({
  "unreal-angelscript-lsp/language-server/out/highlight_occurances.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HighlightOccurances = void 0;
    var scriptfiles2 = require_as_parser();
    var vscode_languageserver_1 = require_main4();
    function HighlightOccurances(uri, position) {
      let matches = new Array();
      let asmodule = scriptfiles2.GetModuleByUri(uri);
      if (!asmodule)
        return null;
      scriptfiles2.ParseModuleAndDependencies(asmodule);
      scriptfiles2.PostProcessModuleTypesAndDependencies(asmodule);
      scriptfiles2.ResolveModule(asmodule);
      let offset = asmodule.getOffset(position);
      let findSymbol = asmodule.getSymbolAtOrBefore(offset);
      if (!findSymbol)
        return null;
      if (findSymbol.type == scriptfiles2.ASSymbolType.UnknownError)
        return null;
      let scopeLimited = false;
      if (findSymbol.type == scriptfiles2.ASSymbolType.LocalVariable)
        scopeLimited = true;
      else if (findSymbol.type == scriptfiles2.ASSymbolType.Parameter)
        scopeLimited = true;
      let declaredScope = null;
      if (scopeLimited) {
        declaredScope = asmodule.getScopeDeclaringLocalSymbol(findSymbol);
        if (!declaredScope)
          return null;
      }
      for (let symbol of asmodule.semanticSymbols) {
        if (symbol.type != findSymbol.type)
          continue;
        if (symbol.container_type != findSymbol.container_type)
          continue;
        if (symbol.symbol_name != findSymbol.symbol_name)
          continue;
        if (scopeLimited) {
          if (symbol.start >= declaredScope.end_offset)
            continue;
          if (symbol.end < declaredScope.start_offset)
            continue;
        }
        let highlight = vscode_languageserver_1.DocumentHighlight.create(asmodule.getRange(symbol.start, symbol.end), symbol.isWriteAccess ? vscode_languageserver_1.DocumentHighlightKind.Write : vscode_languageserver_1.DocumentHighlightKind.Read);
        matches.push(highlight);
      }
      return matches;
    }
    exports2.HighlightOccurances = HighlightOccurances;
  }
});

// unreal-angelscript-lsp/language-server/out/semantic_highlighting.js
var require_semantic_highlighting = __commonJS({
  "unreal-angelscript-lsp/language-server/out/semantic_highlighting.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HighlightSymbolsDelta = exports2.HighlightSymbols = exports2.SemanticTypeList = exports2.SemanticTypes = void 0;
    var typedb2 = require_database();
    var scriptfiles2 = require_as_parser();
    var vscode_languageserver_1 = require_main4();
    exports2.SemanticTypes = {};
    exports2.SemanticTypeList = [
      "namespace",
      "template_base_type",
      "parameter",
      "local_variable",
      "member_variable",
      "member_accessor",
      "global_variable",
      "global_accessor",
      "member_function",
      "global_function",
      "unknown_error",
      "typename",
      "typename_actor",
      "typename_component",
      "typename_struct",
      "typename_event",
      "typename_delegate",
      "typename_primitive",
      "unimported_symbol",
      "access_specifier"
    ];
    for (let i = 0, Count = exports2.SemanticTypeList.length; i < Count; ++i)
      exports2.SemanticTypes[exports2.SemanticTypeList[i]] = i;
    var PrevTokens = null;
    function HighlightSymbols(asmodule) {
      let builder = new vscode_languageserver_1.SemanticTokensBuilder();
      BuildSymbols(asmodule, builder);
      let tokens = builder.build();
      PrevTokens = tokens;
      return tokens;
    }
    exports2.HighlightSymbols = HighlightSymbols;
    function HighlightSymbolsDelta(asmodule, previousId = null) {
      let builder = new vscode_languageserver_1.SemanticTokensBuilder();
      BuildSymbols(asmodule, builder);
      let newTokens = builder.build();
      return newTokens;
      if (previousId && PrevTokens.resultId == previousId) {
        let identicalToPrevious = true;
        if (PrevTokens.data.length != newTokens.data.length) {
          identicalToPrevious = false;
        } else {
          for (let i = 0; i < newTokens.data.length; ++i) {
            if (PrevTokens.data[i] != newTokens.data[i]) {
              identicalToPrevious = false;
              break;
            }
          }
        }
        if (identicalToPrevious) {
          return {
            edits: [],
            resultId: newTokens.resultId
          };
        }
      }
      PrevTokens = newTokens;
      return newTokens;
    }
    exports2.HighlightSymbolsDelta = HighlightSymbolsDelta;
    function BuildSymbols(asmodule, builder) {
      for (let symbol of asmodule.semanticSymbols) {
        if (symbol.noColor)
          continue;
        let pos = asmodule.getPosition(symbol.start);
        let length = symbol.end - symbol.start;
        let type = -1;
        if (symbol.isUnimported) {
          type = exports2.SemanticTypes.unimported_symbol;
        } else if (symbol.type == scriptfiles2.ASSymbolType.Typename || symbol.type == scriptfiles2.ASSymbolType.Namespace) {
          let symName = symbol.symbol_name;
          let classification = typedb2.DBTypeClassification.Other;
          if (symbol.type == scriptfiles2.ASSymbolType.Typename) {
            let dbtype = typedb2.GetTypeByName(symbol.symbol_name);
            if (dbtype)
              classification = dbtype.getTypeClassification();
          } else if (symbol.type == scriptfiles2.ASSymbolType.Namespace) {
            let namespace = typedb2.LookupNamespace(null, symbol.symbol_name);
            if (namespace) {
              let dbtype = namespace.getShadowedType();
              if (dbtype)
                classification = dbtype.getTypeClassification();
            }
          } else if (symbol.symbol_name == "auto") {
            classification = typedb2.DBTypeClassification.Primitive;
          }
          switch (classification) {
            case typedb2.DBTypeClassification.Component:
              type = exports2.SemanticTypes.typename_component;
              break;
            case typedb2.DBTypeClassification.Actor:
              type = exports2.SemanticTypes.typename_actor;
              break;
            case typedb2.DBTypeClassification.Struct:
              type = exports2.SemanticTypes.typename_struct;
              break;
            case typedb2.DBTypeClassification.Event:
              type = exports2.SemanticTypes.typename_event;
              break;
            case typedb2.DBTypeClassification.Delegate:
              type = exports2.SemanticTypes.typename_delegate;
              break;
            case typedb2.DBTypeClassification.Primitive:
              type = exports2.SemanticTypes.typename_primitive;
              break;
            case typedb2.DBTypeClassification.Other:
            default:
              if (symbol.type == scriptfiles2.ASSymbolType.Namespace)
                type = exports2.SemanticTypes.namespace;
              else
                type = exports2.SemanticTypes.typename;
              break;
          }
        } else
          switch (symbol.type) {
            case scriptfiles2.ASSymbolType.UnknownError:
              type = exports2.SemanticTypes.unknown_error;
              break;
            case scriptfiles2.ASSymbolType.TemplateBaseType:
              type = exports2.SemanticTypes.template_base_type;
              break;
            case scriptfiles2.ASSymbolType.Parameter:
              type = exports2.SemanticTypes.parameter;
              break;
            case scriptfiles2.ASSymbolType.LocalVariable:
              type = exports2.SemanticTypes.local_variable;
              break;
            case scriptfiles2.ASSymbolType.MemberVariable:
              type = exports2.SemanticTypes.member_variable;
              break;
            case scriptfiles2.ASSymbolType.MemberAccessor:
              type = exports2.SemanticTypes.member_accessor;
              break;
            case scriptfiles2.ASSymbolType.GlobalVariable:
              type = exports2.SemanticTypes.global_variable;
              break;
            case scriptfiles2.ASSymbolType.GlobalAccessor:
              type = exports2.SemanticTypes.global_accessor;
              break;
            case scriptfiles2.ASSymbolType.MemberFunction:
              type = exports2.SemanticTypes.member_function;
              break;
            case scriptfiles2.ASSymbolType.GlobalFunction:
              type = exports2.SemanticTypes.global_function;
              break;
            case scriptfiles2.ASSymbolType.AccessSpecifier:
              type = exports2.SemanticTypes.access_specifier;
              break;
          }
        if (type == -1)
          continue;
        let modifiers = 0;
        builder.push(pos.line, pos.character, length, type, modifiers);
      }
    }
  }
});

// unreal-angelscript-lsp/language-server/out/symbols.js
var require_symbols = __commonJS({
  "unreal-angelscript-lsp/language-server/out/symbols.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResolveWorkspaceSymbol = exports2.WorkspaceSymbols = exports2.DocumentSymbols = exports2.GetHover = exports2.GetCppSymbol = exports2.GetUnrealTypeFor = exports2.GetSymbolDefinition = exports2.FindUnimportedSymbolOnLine = exports2.GetDefinition = void 0;
    var vscode_languageserver_1 = require_main4();
    var scriptfiles2 = require_as_parser();
    var parsedcompletion2 = require_parsed_completion();
    var typedb2 = require_database();
    var specifiers = require_specifiers();
    var documentation_1 = require_documentation();
    function GetDefinition(asmodule, position) {
      let locations = new Array();
      let offset = asmodule.getOffset(position);
      let findSymbol = asmodule.getSymbolAtOrBefore(offset);
      if (findSymbol) {
        let defs = GetSymbolDefinition(asmodule, findSymbol);
        if (defs) {
          for (let def of defs)
            locations.push(def.location);
        }
        return locations;
      }
      let statement = asmodule.getStatementAt(offset);
      if (statement && statement.ast && statement.ast.type == scriptfiles2.node_types.ImportStatement) {
        if (statement.ast.children[0].value) {
          let importedModule = scriptfiles2.GetModule(statement.ast.children[0].value);
          if (importedModule) {
            locations.push(importedModule.getLocation(0));
            return locations;
          }
        }
      }
      return locations;
    }
    exports2.GetDefinition = GetDefinition;
    function FindUnimportedSymbolOnLine(asmodule, position) {
      let offset = asmodule.getOffset(position);
      let findSymbol = asmodule.getSymbolAtOrBefore(offset);
      if (findSymbol && findSymbol.isUnimported)
        return findSymbol;
      let lineStartOffset = asmodule.getOffset(vscode_languageserver_1.Position.create(position.line, 0));
      let lineEndOffset = asmodule.getOffset(vscode_languageserver_1.Position.create(position.line, 1e4));
      for (let sym of asmodule.semanticSymbols) {
        if (!sym.overlapsRange(lineStartOffset, lineEndOffset))
          continue;
        if (sym.isUnimported)
          return sym;
      }
      return null;
    }
    exports2.FindUnimportedSymbolOnLine = FindUnimportedSymbolOnLine;
    function GetSymbolDefinition(asmodule, findSymbol) {
      let definitions = new Array();
      switch (findSymbol.type) {
        case scriptfiles2.ASSymbolType.Typename:
          {
            let dbtype = typedb2.GetTypeByName(findSymbol.symbol_name);
            if (dbtype && dbtype.declaredModule) {
              let symbolModule = scriptfiles2.GetModule(dbtype.declaredModule);
              if (symbolModule) {
                return [{
                  module: symbolModule,
                  location: symbolModule.getLocation(dbtype.moduleOffset)
                }];
              }
            }
          }
          break;
        case scriptfiles2.ASSymbolType.Namespace:
          {
            let namespace = typedb2.LookupNamespace(null, findSymbol.symbol_name);
            if (namespace) {
              for (let decl of namespace.declarations) {
                if (!decl.declaredModule)
                  continue;
                let declModule = scriptfiles2.GetModule(decl.declaredModule);
                if (declModule) {
                  definitions.push({
                    module: declModule,
                    location: declModule.getLocation(decl.declaredOffset)
                  });
                }
              }
            }
          }
          break;
        case scriptfiles2.ASSymbolType.LocalVariable:
        case scriptfiles2.ASSymbolType.Parameter:
          {
            if (!asmodule)
              return [];
            let scope = asmodule.getScopeAt(findSymbol.start);
            while (scope) {
              if (!scope.isInFunctionBody())
                break;
              for (let asvar of scope.variables) {
                if (asvar.name == findSymbol.symbol_name) {
                  return [{
                    module: asmodule,
                    location: asmodule.getLocationRange(asvar.start_offset_name, asvar.end_offset_name)
                  }];
                }
              }
              scope = scope.parentscope;
            }
          }
          break;
        case scriptfiles2.ASSymbolType.AccessSpecifier:
          {
            if (!asmodule)
              return [];
            let scope = asmodule.getScopeAt(findSymbol.start);
            let dbtype = scope.getParentType();
            if (!dbtype)
              return [];
            let spec = dbtype.getAccessSpecifier(findSymbol.symbol_name);
            if (!spec)
              return [];
            return [{
              module: asmodule,
              location: asmodule.getLocationRange(spec.moduleOffset, spec.moduleOffsetEnd)
            }];
          }
          break;
        case scriptfiles2.ASSymbolType.MemberVariable:
        case scriptfiles2.ASSymbolType.MemberFunction:
          {
            let insideType = typedb2.GetTypeByName(findSymbol.container_type);
            if (!insideType)
              return null;
            let dbSymbols = insideType.findSymbols(findSymbol.symbol_name);
            for (let sym of dbSymbols) {
              if (sym instanceof typedb2.DBMethod || sym instanceof typedb2.DBProperty) {
                if (!sym.declaredModule)
                  continue;
                let symbolModule = scriptfiles2.GetModule(sym.declaredModule);
                if (symbolModule) {
                  definitions.push({
                    module: symbolModule,
                    location: symbolModule.getLocation(sym.moduleOffset)
                  });
                }
              }
            }
          }
          break;
        case scriptfiles2.ASSymbolType.GlobalFunction:
        case scriptfiles2.ASSymbolType.GlobalVariable:
          {
            let namespace = typedb2.LookupNamespace(null, findSymbol.container_type);
            if (!namespace)
              return null;
            let dbSymbols = namespace.findSymbols(findSymbol.symbol_name);
            for (let sym of dbSymbols) {
              if (sym instanceof typedb2.DBMethod || sym instanceof typedb2.DBProperty) {
                if (!sym.declaredModule)
                  continue;
                let symbolModule = scriptfiles2.GetModule(sym.declaredModule);
                if (symbolModule) {
                  definitions.push({
                    module: symbolModule,
                    location: symbolModule.getLocation(sym.moduleOffset)
                  });
                }
              }
            }
          }
          break;
        case scriptfiles2.ASSymbolType.MemberAccessor:
          {
            let insideType = typedb2.GetTypeByName(findSymbol.container_type);
            if (!insideType)
              return null;
            let accessName = findSymbol.symbol_name;
            if (accessName.startsWith("Get") || accessName.startsWith("Set"))
              accessName = accessName.substring(3);
            let dbSymbols = [
              ...insideType.findSymbols("Get" + accessName),
              ...insideType.findSymbols("Set" + accessName)
            ];
            for (let sym of dbSymbols) {
              if (sym instanceof typedb2.DBMethod || sym instanceof typedb2.DBProperty) {
                if (!sym.declaredModule)
                  continue;
                let symbolModule = scriptfiles2.GetModule(sym.declaredModule);
                if (symbolModule) {
                  definitions.push({
                    module: symbolModule,
                    location: symbolModule.getLocation(sym.moduleOffset)
                  });
                }
              }
            }
          }
          break;
        case scriptfiles2.ASSymbolType.GlobalAccessor:
          {
            let namespace = typedb2.LookupNamespace(null, findSymbol.container_type);
            if (!namespace)
              return null;
            let accessName = findSymbol.symbol_name;
            if (accessName.startsWith("Get") || accessName.startsWith("Set"))
              accessName = accessName.substring(3);
            let dbSymbols = [
              ...namespace.findSymbols("Get" + accessName),
              ...namespace.findSymbols("Set" + accessName)
            ];
            for (let sym of dbSymbols) {
              if (sym instanceof typedb2.DBMethod || sym instanceof typedb2.DBProperty) {
                if (!sym.declaredModule)
                  continue;
                let symbolModule = scriptfiles2.GetModule(sym.declaredModule);
                if (symbolModule) {
                  definitions.push({
                    module: symbolModule,
                    location: symbolModule.getLocation(sym.moduleOffset)
                  });
                }
              }
            }
          }
          break;
      }
      return definitions;
    }
    exports2.GetSymbolDefinition = GetSymbolDefinition;
    function GetUnrealTypeFor(typename) {
      let type = typedb2.GetTypeByName(typename);
      while (type && type.declaredModule && type.supertype)
        type = type.getSuperType();
      if (!type)
        return null;
      return type.name;
    }
    exports2.GetUnrealTypeFor = GetUnrealTypeFor;
    function GetCppSymbol(asmodule, position) {
      let offset = asmodule.getOffset(position);
      let findSymbol = asmodule.getSymbolAtOrBefore(offset);
      if (!findSymbol)
        return null;
      switch (findSymbol.type) {
        case scriptfiles2.ASSymbolType.Typename:
        case scriptfiles2.ASSymbolType.Namespace:
          {
            let unrealType = GetUnrealTypeFor(findSymbol.symbol_name);
            if (unrealType)
              return ["", unrealType];
          }
          break;
        case scriptfiles2.ASSymbolType.MemberVariable:
        case scriptfiles2.ASSymbolType.MemberFunction:
        case scriptfiles2.ASSymbolType.GlobalFunction:
        case scriptfiles2.ASSymbolType.GlobalVariable:
        case scriptfiles2.ASSymbolType.MemberAccessor:
        case scriptfiles2.ASSymbolType.GlobalAccessor:
          {
            let unrealType = GetUnrealTypeFor(findSymbol.container_type);
            if (unrealType)
              return [unrealType, findSymbol.symbol_name];
          }
          break;
      }
      return null;
    }
    exports2.GetCppSymbol = GetCppSymbol;
    function GetHover(asmodule, position) {
      if (!asmodule)
        return null;
      let offset = asmodule.getOffset(position);
      let findSymbol = asmodule.getSymbolAt(offset);
      if (!findSymbol) {
        let word = GetWordAt(asmodule, offset);
        if (!word)
          return null;
        return GetWordHover(word);
      }
      switch (findSymbol.type) {
        case scriptfiles2.ASSymbolType.Typename:
          {
            let dbtype = typedb2.GetTypeByName(findSymbol.symbol_name);
            if (dbtype)
              return GetHoverForType(dbtype);
          }
          break;
        case scriptfiles2.ASSymbolType.Namespace:
          {
            let namespace = typedb2.LookupNamespace(null, findSymbol.symbol_name);
            if (namespace)
              return GetHoverForNamespace(namespace);
          }
          break;
        case scriptfiles2.ASSymbolType.LocalVariable:
        case scriptfiles2.ASSymbolType.Parameter:
          {
            let scope = asmodule.getScopeAt(offset);
            while (scope) {
              if (!scope.isInFunctionBody())
                break;
              for (let asvar of scope.variables) {
                if (asvar.name == findSymbol.symbol_name) {
                  return GetHoverForLocalVariable(scope, asvar);
                }
              }
              scope = scope.parentscope;
            }
          }
          break;
        case scriptfiles2.ASSymbolType.MemberFunction:
          {
            let insideType = typedb2.GetTypeByName(findSymbol.container_type);
            if (!insideType)
              return null;
            let symbols = insideType.findSymbols(findSymbol.symbol_name);
            let methods = [];
            for (let func of symbols) {
              if (func instanceof typedb2.DBMethod)
                methods.push(func);
            }
            if (methods.length > 1)
              parsedcompletion2.SortMethodsBasedOnArgumentTypes(methods, asmodule, findSymbol.end + 2);
            if (methods.length != 0)
              return GetHoverForFunction(asmodule, findSymbol.end + 2, insideType, methods[0], false);
          }
          break;
        case scriptfiles2.ASSymbolType.GlobalFunction:
          {
            let namespace = typedb2.LookupNamespace(null, findSymbol.container_type);
            if (!namespace)
              return null;
            let symbols = namespace.findSymbols(findSymbol.symbol_name);
            let methods = [];
            for (let func of symbols) {
              if (func instanceof typedb2.DBMethod)
                methods.push(func);
            }
            if (methods.length > 1)
              parsedcompletion2.SortMethodsBasedOnArgumentTypes(methods, asmodule, findSymbol.end + 2);
            if (methods.length != 0)
              return GetHoverForFunction(asmodule, findSymbol.end + 2, namespace, methods[0], false);
          }
          break;
        case scriptfiles2.ASSymbolType.MemberVariable:
          {
            let insideType = typedb2.GetTypeByName(findSymbol.container_type);
            if (!insideType)
              return null;
            let sym = insideType.findFirstSymbol(findSymbol.symbol_name, typedb2.DBAllowSymbol.Properties);
            if (sym instanceof typedb2.DBProperty) {
              return GetHoverForProperty(insideType, sym);
            }
          }
          break;
        case scriptfiles2.ASSymbolType.GlobalVariable:
          {
            let namespace = typedb2.LookupNamespace(null, findSymbol.container_type);
            if (!namespace)
              return null;
            let sym = namespace.findFirstSymbol(findSymbol.symbol_name, typedb2.DBAllowSymbol.Properties);
            if (sym instanceof typedb2.DBProperty) {
              return GetHoverForProperty(namespace, sym);
            }
          }
          break;
        case scriptfiles2.ASSymbolType.MemberAccessor:
          {
            let insideType = typedb2.GetTypeByName(findSymbol.container_type);
            if (!insideType)
              return null;
            let accessName = findSymbol.symbol_name;
            if (accessName.startsWith("Get") || accessName.startsWith("Set"))
              accessName = accessName.substring(3);
            let dbSymbols = [
              ...insideType.findSymbols("Get" + accessName),
              ...insideType.findSymbols("Set" + accessName)
            ];
            for (let sym of dbSymbols) {
              if (sym instanceof typedb2.DBMethod && sym.findAvailableDocumentation()) {
                return GetHoverForFunction(asmodule, findSymbol.end + 2, insideType, sym, true);
              }
            }
            for (let sym of dbSymbols) {
              if (sym instanceof typedb2.DBMethod) {
                return GetHoverForFunction(asmodule, findSymbol.end + 2, insideType, sym, true);
              }
            }
          }
          break;
        case scriptfiles2.ASSymbolType.GlobalAccessor:
          {
            let namespace = typedb2.LookupNamespace(null, findSymbol.container_type);
            if (!namespace)
              return null;
            let accessName = findSymbol.symbol_name;
            if (accessName.startsWith("Get") || accessName.startsWith("Set"))
              accessName = accessName.substring(3);
            let dbSymbols = [
              ...namespace.findSymbols("Get" + accessName),
              ...namespace.findSymbols("Set" + accessName)
            ];
            for (let sym of dbSymbols) {
              if (sym instanceof typedb2.DBMethod && sym.findAvailableDocumentation()) {
                return GetHoverForFunction(asmodule, findSymbol.end + 2, namespace, sym, true);
              }
            }
            for (let sym of dbSymbols) {
              if (sym instanceof typedb2.DBMethod) {
                return GetHoverForFunction(asmodule, findSymbol.end + 2, namespace, sym, true);
              }
            }
          }
          break;
        case scriptfiles2.ASSymbolType.AccessSpecifier:
          return { contents: {
            kind: "markdown",
            value: `Access specifier \`${findSymbol.symbol_name}\` restricts which other classes this can be used from`
          } };
          break;
      }
    }
    exports2.GetHover = GetHover;
    function IsIdentifierValid(content, index) {
      let charCode = content.charCodeAt(index);
      if (charCode > 47 && charCode < 58)
        return true;
      if (charCode > 64 && charCode < 91)
        return true;
      if (charCode > 96 && charCode < 123)
        return true;
      if (charCode == 95)
        return true;
      return false;
    }
    function GetWordAt(asmodule, offset) {
      let startOffset = offset;
      while (startOffset > 0) {
        if (!IsIdentifierValid(asmodule.content, startOffset)) {
          startOffset += 1;
          break;
        }
        startOffset -= 1;
      }
      let endOffset = offset + 1;
      while (endOffset > 0) {
        if (!IsIdentifierValid(asmodule.content, endOffset))
          break;
        endOffset += 1;
      }
      if (startOffset < endOffset)
        return asmodule.content.substring(startOffset, endOffset);
      return null;
    }
    function GetWordHover(word) {
      if (!word)
        return;
      let specifier_lists = [
        specifiers.ASPropertySpecifiers,
        specifiers.ASClassSpecifiers,
        specifiers.ASFunctionSpecifiers,
        specifiers.ASStructSpecifiers
      ];
      if (scriptfiles2.GetScriptSettings().useAngelscriptHaze) {
        specifier_lists.push(specifiers.ASPropertySpecifiers_HAZE);
        specifier_lists.push(specifiers.ASFunctionSpecifiers_HAZE);
      } else {
        specifier_lists.push(specifiers.ASPropertySpecifiers_NO_HAZE);
        specifier_lists.push(specifiers.ASFunctionSpecifiers_NO_HAZE);
      }
      let subspecifier_lists = [
        specifiers.ASPropertySubSpecifiers,
        specifiers.ASClassSubSpecifiers,
        specifiers.ASFunctionSubSpecifiers,
        specifiers.ASStructSubSpecifiers
      ];
      for (let sublist of subspecifier_lists) {
        for (let subspec in sublist)
          specifier_lists.push(sublist[subspec]);
      }
      let documentation = null;
      for (let speclist of specifier_lists) {
        if (word in speclist) {
          documentation = speclist[word];
          break;
        }
      }
      if (documentation) {
        return { contents: {
          kind: "markdown",
          value: documentation
        } };
      }
      return null;
    }
    function FormatHoverDocumentation(doc) {
      if (doc) {
        let outDoc = "*";
        outDoc += doc.replace(/\s*\r?\n\s*/g, "*\n\n*");
        outDoc += "*\n\n";
        return outDoc;
      }
      return "";
    }
    function GetHoverForType(hoveredType) {
      if (hoveredType.isPrimitive)
        return null;
      let hover = "";
      hover += FormatHoverDocumentation(hoveredType.documentation);
      hover += "```angelscript_snippet\n";
      if (hoveredType.isEnum) {
        hover += "enum " + hoveredType.name;
      } else if (hoveredType.isDelegate) {
        hover += "delegate ";
        let mth = hoveredType.getMethod("ExecuteIfBound");
        if (mth)
          hover += mth.format(null, false, false, hoveredType.name);
        else
          hover += hoveredType.name;
      } else if (hoveredType.isEvent) {
        hover += "event ";
        let mth = hoveredType.getMethod("Broadcast");
        if (mth)
          hover += mth.format(null, false, false, hoveredType.name);
        else
          hover += hoveredType.name;
      } else {
        if (hoveredType.isStruct)
          hover += "struct ";
        else
          hover += "class ";
        hover += hoveredType.name;
        if (hoveredType.supertype)
          hover += " : " + hoveredType.supertype;
        else if (hoveredType.unrealsuper)
          hover += " : " + hoveredType.unrealsuper;
      }
      hover += "\n```";
      return { contents: {
        kind: "markdown",
        value: hover
      } };
    }
    function GetHoverForNamespace(hoveredNamespace) {
      let hover = "";
      hover += FormatHoverDocumentation(hoveredNamespace.documentation);
      hover += "```angelscript_snippet\n";
      hover += "namespace " + hoveredNamespace.name;
      hover += "\n```";
      return { contents: {
        kind: "markdown",
        value: hover
      } };
    }
    function GetHoverForLocalVariable(scope, asvar) {
      let hover = "";
      if (asvar.documentation)
        hover += FormatHoverDocumentation(asvar.documentation);
      hover += "```angelscript_snippet\n" + asvar.typename + " " + asvar.name + "\n```";
      return { contents: {
        kind: "markdown",
        value: hover
      } };
    }
    function GetHoverForProperty(type, prop) {
      let prefix = null;
      if (type instanceof typedb2.DBNamespace) {
        if (!type.isRootNamespace())
          prefix = type.getQualifiedNamespace() + "::";
      }
      let hover = "";
      hover += (0, documentation_1.FormatPropertyDocumentation)(prop.documentation);
      hover += "```angelscript_snippet\n" + prop.format(prefix) + "\n```";
      return { contents: {
        kind: "markdown",
        value: hover
      } };
    }
    function GetHoverForFunction(asmodule, offset, type, func, isAccessor) {
      let prefix = "";
      let suffix = "";
      if (func.isMixin && func.args && func.args.length != 0) {
        prefix = func.args[0].typename + ".";
        suffix = " mixin";
      } else if (type instanceof typedb2.DBNamespace) {
        if (!type.isRootNamespace())
          prefix = type.getQualifiedNamespace() + "::";
      } else {
        prefix = type.name + ".";
      }
      let hover = "";
      let doc = func.findAvailableDocumentation();
      if (doc)
        hover += (0, documentation_1.FormatFunctionDocumentation)(doc, func);
      let determineType = null;
      if (func.determinesOutputTypeArgumentIndex != -1)
        determineType = parsedcompletion2.GetDetermineTypeFromArguments(asmodule, offset, func.determinesOutputTypeArgumentIndex);
      if (isAccessor) {
        if (func.name.startsWith("Get"))
          hover += "```angelscript_snippet\n" + func.returnType + " " + prefix + func.name.substring(3) + "\n```";
        else if (func.args && func.args.length > 0)
          hover += "```angelscript_snippet\n" + func.args[0].typename + " " + prefix + func.name.substring(3) + "\n```";
      } else {
        hover += "```angelscript_snippet\n" + func.format(prefix, func.isMixin, false, null, determineType) + suffix + "\n```";
      }
      return { contents: {
        kind: "markdown",
        value: hover
      } };
    }
    function DocumentSymbols(asmodule) {
      let symbols = new Array();
      if (!asmodule)
        return symbols;
      AddScopeSymbols(asmodule, asmodule.rootscope, symbols);
      return symbols;
    }
    exports2.DocumentSymbols = DocumentSymbols;
    function AddScopeSymbols(asmodule, scope, symbols) {
      if (!scope)
        return;
      if (scope.scopetype == scriptfiles2.ASScopeType.Class || scope.scopetype == scriptfiles2.ASScopeType.Global || scope.scopetype == scriptfiles2.ASScopeType.Namespace || scope.scopetype == scriptfiles2.ASScopeType.Enum) {
        let varKind = vscode_languageserver_1.SymbolKind.Variable;
        if (scope.scopetype == scriptfiles2.ASScopeType.Class || scope.scopetype == scriptfiles2.ASScopeType.Enum) {
          let dbtype = scope.getDatabaseType();
          if (dbtype) {
            let scopeSymbol = {};
            if (dbtype.moduleScopeEnd != -1)
              scopeSymbol.range = asmodule.getRange(dbtype.moduleOffset, dbtype.moduleScopeEnd);
            else if (dbtype.moduleOffsetEnd != -1)
              scopeSymbol.selectionRange = asmodule.getRange(dbtype.moduleOffset, dbtype.moduleOffsetEnd);
            else
              scopeSymbol.range = asmodule.getRange(dbtype.moduleOffset, dbtype.moduleOffset);
            if (dbtype.moduleOffsetEnd != -1)
              scopeSymbol.selectionRange = asmodule.getRange(dbtype.moduleOffset, dbtype.moduleOffsetEnd);
            else
              scopeSymbol.selectionRange = asmodule.getRange(dbtype.moduleOffset, dbtype.moduleOffset);
            scopeSymbol.name = dbtype.name;
            if (scope.scopetype == scriptfiles2.ASScopeType.Enum) {
              scopeSymbol.kind = vscode_languageserver_1.SymbolKind.Enum;
              varKind = vscode_languageserver_1.SymbolKind.EnumMember;
            } else {
              scopeSymbol.kind = vscode_languageserver_1.SymbolKind.Class;
              if (dbtype.isStruct)
                scopeSymbol.kind = vscode_languageserver_1.SymbolKind.Struct;
            }
            scopeSymbol.children = new Array();
            symbols.push(scopeSymbol);
            symbols = scopeSymbol.children;
          }
        } else if (scope.scopetype == scriptfiles2.ASScopeType.Namespace) {
          let namespace = scope.getNamespace();
          if (namespace && scope.previous instanceof scriptfiles2.ASStatement && scope.previous.ast && scope.previous.ast.type == scriptfiles2.node_types.NamespaceDefinition) {
            let nsdef = scope.previous.ast;
            let scopeSymbol = {};
            scopeSymbol.range = asmodule.getRange(scope.start_offset, scope.end_offset);
            scopeSymbol.kind = vscode_languageserver_1.SymbolKind.Namespace;
            scopeSymbol.selectionRange = asmodule.getRange(scope.previous.start_offset + nsdef.name.start, scope.previous.start_offset + nsdef.name.end);
            scopeSymbol.name = namespace.name;
            scopeSymbol.children = new Array();
            symbols.push(scopeSymbol);
            symbols = scopeSymbol.children;
          }
        }
        for (let classVar of scope.variables) {
          if (classVar.isArgument)
            continue;
          let signature = classVar.typename;
          if (classVar.accessSpecifier)
            signature = "access:" + classVar.accessSpecifier.name + " " + signature;
          else if (classVar.isPrivate)
            signature = "private " + signature;
          else if (classVar.isProtected)
            signature = "protected " + signature;
          symbols.push({
            name: classVar.name,
            kind: varKind,
            detail: signature,
            range: asmodule.getRange(classVar.start_offset_name, classVar.end_offset_name),
            selectionRange: asmodule.getRange(classVar.start_offset_name, classVar.end_offset_name)
          });
        }
      }
      let scopeFunc = scope.getDatabaseFunction();
      if (scopeFunc) {
        let scopeSymbol = {
          name: scopeFunc.name
        };
        if (scopeFunc.args.length != 0)
          scopeSymbol.name += "(\u2026)";
        else
          scopeSymbol.name += "()";
        if (scopeFunc.accessSpecifier)
          scopeSymbol.detail = "access:" + scopeFunc.accessSpecifier.name;
        else if (scopeFunc.isPrivate)
          scopeSymbol.detail = "private";
        else if (scopeFunc.isProtected)
          scopeSymbol.detail = "protected";
        if (scopeFunc.moduleScopeEnd != -1)
          scopeSymbol.range = asmodule.getRange(scopeFunc.moduleOffset, scopeFunc.moduleScopeEnd);
        else if (scopeFunc.moduleOffsetEnd != -1)
          scopeSymbol.range = asmodule.getRange(scopeFunc.moduleOffset, scopeFunc.moduleOffsetEnd);
        else
          scopeSymbol.range = asmodule.getRange(scopeFunc.moduleOffset, scopeFunc.moduleOffset);
        if (scopeFunc.moduleOffsetEnd != -1)
          scopeSymbol.selectionRange = asmodule.getRange(scopeFunc.moduleOffset, scopeFunc.moduleOffsetEnd);
        else
          scopeSymbol.selectionRange = asmodule.getRange(scopeFunc.moduleOffset, scopeFunc.moduleOffset);
        if (scope.scopetype == scriptfiles2.ASScopeType.Function) {
          if (scope.parentscope && scope.parentscope.scopetype == scriptfiles2.ASScopeType.Class)
            scopeSymbol.kind = vscode_languageserver_1.SymbolKind.Method;
          else
            scopeSymbol.kind = vscode_languageserver_1.SymbolKind.Function;
          symbols.push(scopeSymbol);
        }
      } else {
        for (let subscope of scope.scopes)
          AddScopeSymbols(asmodule, subscope, symbols);
      }
    }
    function WorkspaceSymbols(query) {
      let symbols = new Array();
      query = query.toLowerCase();
      if (query.length == 0)
        return symbols;
      let matchMembers = query.length >= 5;
      for (let [_, dbtype] of typedb2.GetAllTypesById()) {
        if (!dbtype.declaredModule)
          continue;
        let asmodule = scriptfiles2.GetModule(dbtype.declaredModule);
        if (!asmodule)
          continue;
        let displayTypename = dbtype.getDisplayName();
        let qualifiedTypename = dbtype.getQualifiedTypenameInNamespace(null);
        let typeIsMatching = displayTypename.toLowerCase().indexOf(query) != -1;
        if (typeIsMatching) {
          let symbol = {
            name: qualifiedTypename
          };
          symbol.location = { uri: asmodule.displayUri };
          if (dbtype.isEnum)
            symbol.kind = vscode_languageserver_1.SymbolKind.Enum;
          else
            symbol.kind = vscode_languageserver_1.SymbolKind.Class;
          symbol.data = dbtype.name;
          symbols.push(symbol);
        }
        if (matchMembers) {
          let memberPrefix = qualifiedTypename;
          if (dbtype.isEnum)
            memberPrefix += "::";
          else
            memberPrefix += ".";
          dbtype.forEachSymbol(function(sym) {
            if (sym instanceof typedb2.DBMethod) {
              let dbfunc = sym;
              if (dbfunc.isAutoGenerated)
                return;
              let funcIsMatching = dbfunc.name.toLowerCase().indexOf(query) != -1;
              if (!funcIsMatching && !typeIsMatching)
                return;
              let symbol = {};
              if (dbfunc.args && dbfunc.args.length != 0)
                symbol.name = memberPrefix + dbfunc.name + "(\u2026)";
              else
                symbol.name = memberPrefix + dbfunc.name + "()";
              symbol.data = [dbtype.name, dbfunc.name, dbfunc.id];
              symbol.location = { uri: asmodule.displayUri };
              if (dbfunc.isBlueprintEvent)
                symbol.kind = vscode_languageserver_1.SymbolKind.Event;
              else
                symbol.kind = vscode_languageserver_1.SymbolKind.Method;
              symbol.containerName = displayTypename;
              symbols.push(symbol);
            } else if (sym instanceof typedb2.DBProperty) {
              let dbprop = sym;
              if (dbprop.isAutoGenerated)
                return;
              let propIsMatching = dbprop.name.toLowerCase().indexOf(query) != -1;
              if (!propIsMatching && !typeIsMatching)
                return;
              let symbol = {};
              symbol.name = memberPrefix + dbprop.name;
              symbol.data = [dbtype.name, dbprop.name];
              symbol.location = { uri: asmodule.displayUri };
              symbol.kind = vscode_languageserver_1.SymbolKind.Field;
              symbol.containerName = displayTypename;
              symbols.push(symbol);
            }
          }, false);
        }
      }
      for (let [_, namespace] of typedb2.GetAllNamespaces()) {
        let displayName = namespace.name;
        let qualifiedName = namespace.getQualifiedNamespace();
        let typeIsMatching = false;
        if (!namespace.isRootNamespace()) {
          let scriptDecl = namespace.getFirstScriptDeclaration();
          if (!scriptDecl)
            continue;
          let asmodule = scriptfiles2.GetModule(scriptDecl.declaredModule);
          if (!asmodule)
            continue;
          typeIsMatching = displayName.toLowerCase().indexOf(query) != -1;
          if (typeIsMatching && !namespace.isShadowingType()) {
            let symbol = {
              name: qualifiedName
            };
            symbol.location = { uri: asmodule.displayUri };
            symbol.kind = vscode_languageserver_1.SymbolKind.Namespace;
            symbol.data = namespace.getQualifiedNamespace();
            symbols.push(symbol);
          }
        }
        if (matchMembers) {
          let memberPrefix = qualifiedName;
          if (memberPrefix.length != 0)
            memberPrefix += "::";
          namespace.forEachSymbol(function(dbsym) {
            if (!dbsym.declaredModule)
              return;
            if (dbsym instanceof typedb2.DBMethod) {
              if (dbsym.isAutoGenerated)
                return;
              let dbfunc = dbsym;
              if (dbfunc.isAutoGenerated)
                return;
              let funcIsMatching = dbfunc.name.toLowerCase().indexOf(query) != -1;
              if (!funcIsMatching && !typeIsMatching)
                return;
              let symbolModule = scriptfiles2.GetModule(dbsym.declaredModule);
              if (!symbolModule)
                return;
              let symbol = {};
              if (dbfunc.args && dbfunc.args.length != 0)
                symbol.name = memberPrefix + dbfunc.name + "(\u2026)";
              else
                symbol.name = memberPrefix + dbfunc.name + "()";
              symbol.data = [namespace.getQualifiedNamespace(), dbfunc.name, dbfunc.id];
              symbol.location = { uri: symbolModule.displayUri };
              if (dbfunc.isBlueprintEvent)
                symbol.kind = vscode_languageserver_1.SymbolKind.Event;
              else
                symbol.kind = vscode_languageserver_1.SymbolKind.Method;
              symbol.containerName = qualifiedName;
              symbols.push(symbol);
            } else if (dbsym instanceof typedb2.DBProperty) {
              if (dbsym.isAutoGenerated)
                return;
              let dbprop = dbsym;
              if (dbprop.isAutoGenerated)
                return;
              let propIsMatching = dbprop.name.toLowerCase().indexOf(query) != -1;
              if (!propIsMatching && !typeIsMatching)
                return;
              let symbolModule = scriptfiles2.GetModule(dbsym.declaredModule);
              if (!symbolModule)
                return;
              let symbol = {};
              symbol.name = memberPrefix + dbprop.name;
              symbol.data = [namespace.getQualifiedNamespace(), dbprop.name];
              symbol.location = { uri: symbolModule.displayUri };
              symbol.kind = vscode_languageserver_1.SymbolKind.Field;
              symbol.containerName = qualifiedName;
              symbols.push(symbol);
            }
          });
        }
      }
      return symbols;
    }
    exports2.WorkspaceSymbols = WorkspaceSymbols;
    function ResolveWorkspaceSymbol(symbol) {
      if (typeof symbol.data === "string") {
        {
          let dbtype = typedb2.GetTypeByName(symbol.data);
          if (dbtype && dbtype.declaredModule) {
            let asmodule = scriptfiles2.GetModule(dbtype.declaredModule);
            if (!asmodule)
              return;
            if (dbtype.moduleScopeStart != -1)
              symbol.location = asmodule.getLocationRange(dbtype.moduleOffset, dbtype.moduleScopeEnd);
            else
              symbol.location = asmodule.getLocation(dbtype.moduleOffset);
            return symbol;
          }
        }
        {
          let namespace = typedb2.LookupNamespace(null, symbol.data);
          if (namespace) {
            let scriptDecl = namespace.getFirstScriptDeclaration();
            if (scriptDecl) {
              let asmodule = scriptfiles2.GetModule(scriptDecl.declaredModule);
              if (!asmodule)
                return;
              if (scriptDecl.scopeOffsetStart != -1)
                symbol.location = asmodule.getLocationRange(scriptDecl.scopeOffsetStart, scriptDecl.scopeOffsetEnd);
              else
                symbol.location = asmodule.getLocation(scriptDecl.declaredOffset);
              return symbol;
            }
          }
        }
      } else {
        {
          let dbtype = typedb2.GetTypeByName(symbol.data[0]);
          if (dbtype && dbtype.declaredModule) {
            let asmodule = scriptfiles2.GetModule(dbtype.declaredModule);
            if (!asmodule)
              return;
            let allSymbols = dbtype.findSymbols(symbol.data[1]);
            let subSymbol = null;
            for (let checkSymbol of allSymbols) {
              if (checkSymbol instanceof typedb2.DBMethod) {
                if (symbol.data.length < 3 || checkSymbol.id == symbol.data[2]) {
                  subSymbol = checkSymbol;
                  break;
                }
              } else {
                subSymbol = checkSymbol;
                break;
              }
            }
            if (subSymbol) {
              if (subSymbol instanceof typedb2.DBMethod) {
                if (subSymbol.moduleScopeStart != -1)
                  symbol.location = asmodule.getLocationRange(subSymbol.moduleOffset, subSymbol.moduleScopeEnd);
                else
                  symbol.location = asmodule.getLocation(subSymbol.moduleOffset);
              } else if (subSymbol instanceof typedb2.DBProperty) {
                symbol.location = asmodule.getLocation(subSymbol.moduleOffset);
              }
              return symbol;
            }
          }
        }
        {
          let namespace = typedb2.LookupNamespace(null, symbol.data[0]);
          if (namespace) {
            let allSymbols = namespace.findSymbols(symbol.data[1]);
            let subSymbol = null;
            for (let checkSymbol of allSymbols) {
              if (!checkSymbol.declaredModule)
                continue;
              if (checkSymbol instanceof typedb2.DBMethod) {
                if (symbol.data.length < 3 || checkSymbol.id == symbol.data[2]) {
                  subSymbol = checkSymbol;
                  break;
                }
              } else {
                subSymbol = checkSymbol;
                break;
              }
            }
            if (subSymbol) {
              let symbolModule = scriptfiles2.GetModule(subSymbol.declaredModule);
              if (symbolModule) {
                if (subSymbol instanceof typedb2.DBMethod) {
                  if (subSymbol.moduleScopeStart != -1)
                    symbol.location = symbolModule.getLocationRange(subSymbol.moduleOffset, subSymbol.moduleScopeEnd);
                  else
                    symbol.location = symbolModule.getLocation(subSymbol.moduleOffset);
                } else if (subSymbol instanceof typedb2.DBProperty) {
                  symbol.location = symbolModule.getLocation(subSymbol.moduleOffset);
                }
                return symbol;
              }
            }
          }
        }
      }
      return symbol;
    }
    exports2.ResolveWorkspaceSymbol = ResolveWorkspaceSymbol;
  }
});

// unreal-angelscript-lsp/language-server/out/ls_diagnostics.js
var require_ls_diagnostics = __commonJS({
  "unreal-angelscript-lsp/language-server/out/ls_diagnostics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UpdateScriptModuleDiagnostics = exports2.OnDiagnosticsChanged = exports2.GetDiagnosticSettings = exports2.UpdateCompileDiagnostics = void 0;
    var node_12 = require_node3();
    var typedb2 = require_database();
    var scriptfiles2 = require_as_parser();
    var node_types = require_node_types();
    var DiagnosticSettings = {
      namingConventionDiagnostics: true,
      markUnreadVariablesAsUnused: false
    };
    var CompileDiagnostics = /* @__PURE__ */ new Map();
    var ParseDiagnostics = /* @__PURE__ */ new Map();
    var NotifyFunctions = new Array();
    function UpdateCompileDiagnostics(uri, diagnostics) {
      CompileDiagnostics.set(scriptfiles2.NormalizeUri(uri), diagnostics);
      NotifyDiagnostics(uri);
    }
    exports2.UpdateCompileDiagnostics = UpdateCompileDiagnostics;
    function GetDiagnosticSettings() {
      return DiagnosticSettings;
    }
    exports2.GetDiagnosticSettings = GetDiagnosticSettings;
    function NotifyDiagnostics(uri, notifyEmpty = true) {
      let allDiagnostics = [];
      let fromCompile = CompileDiagnostics.get(scriptfiles2.NormalizeUri(uri));
      if (fromCompile) {
        let asmodule = scriptfiles2.GetModuleByUri(uri);
        if (!asmodule || asmodule.exists)
          allDiagnostics = allDiagnostics.concat(fromCompile);
        if (asmodule && asmodule.loaded)
          TrimDiagnosticPositions(asmodule, allDiagnostics);
      }
      let fromParse = ParseDiagnostics.get(scriptfiles2.NormalizeUri(uri));
      if (fromParse)
        allDiagnostics = allDiagnostics.concat(fromParse);
      if (notifyEmpty || allDiagnostics.length != 0) {
        for (let func of NotifyFunctions)
          func(uri, allDiagnostics);
      }
    }
    function HasCompileDiagnostics(asmodule) {
      let fromCompile = CompileDiagnostics.get(asmodule.uri);
      return fromCompile && fromCompile.length != 0;
    }
    function OnDiagnosticsChanged(bindFunction) {
      NotifyFunctions.push(bindFunction);
    }
    exports2.OnDiagnosticsChanged = OnDiagnosticsChanged;
    function UpdateScriptModuleDiagnostics(asmodule, initialResolve = false, alwaysSend = false) {
      let diagnostics = new Array();
      if (!asmodule.rootscope)
        return;
      AddScopeDiagnostics(asmodule.rootscope, diagnostics);
      VerifyDelegateBinds(asmodule, diagnostics);
      AddSymbolDiagnostics(asmodule, diagnostics);
      AddNamingConventionDiagnostics(asmodule, diagnostics);
      let oldDiagnostics = ParseDiagnostics.get(asmodule.uri);
      ParseDiagnostics.set(asmodule.uri, diagnostics);
      if (initialResolve && diagnostics.length == 0)
        return;
      if (oldDiagnostics && AreDiagnosticsEqual(oldDiagnostics, diagnostics)) {
        if (!HasCompileDiagnostics(asmodule))
          return;
      }
      let notifyEmpty = false;
      if (oldDiagnostics && oldDiagnostics.length != 0)
        notifyEmpty = true;
      NotifyDiagnostics(asmodule.displayUri, notifyEmpty || alwaysSend);
    }
    exports2.UpdateScriptModuleDiagnostics = UpdateScriptModuleDiagnostics;
    function AddScopeDiagnostics(scope, diagnostics) {
      if (scope.isInFunctionBody() && scope.module.isOpened) {
        for (let asvar of scope.variables) {
          if (!asvar.isUnused)
            continue;
          if (!DiagnosticSettings.markUnreadVariablesAsUnused && asvar.hasAnyUsages)
            continue;
          diagnostics.push({
            severity: node_12.DiagnosticSeverity.Hint,
            tags: [node_12.DiagnosticTag.Unnecessary],
            range: scope.module.getRange(asvar.start_offset_name, asvar.end_offset_name),
            message: (asvar.isArgument ? "Parameter" : "Variable") + " " + asvar.name + " is unused.",
            source: "angelscript"
          });
          if (asvar.usages) {
            for (let usage of asvar.usages) {
              diagnostics.push({
                severity: node_12.DiagnosticSeverity.Hint,
                tags: [node_12.DiagnosticTag.Unnecessary],
                range: scope.module.getRange(usage.start, usage.end),
                message: (asvar.isArgument ? "Parameter" : "Variable") + " " + asvar.name + " is unused.",
                source: "angelscript"
              });
            }
          }
        }
      }
      if (scope.dbfunc)
        AddFunctionDiagnostics(scope, scope.dbfunc, diagnostics);
      for (let subscope of scope.scopes)
        AddScopeDiagnostics(subscope, diagnostics);
    }
    function VerifyDelegateBinds(asmodule, diagnostics) {
      for (let delegateBind of asmodule.delegateBinds) {
        if (!delegateBind.node_name)
          continue;
        if (!delegateBind.node_object)
          continue;
        if (asmodule.isEditingNode(delegateBind.statement, delegateBind.node_object))
          continue;
        if (delegateBind.node_name.type != node_types.ConstName && delegateBind.node_name.type != node_types.ConstString)
          continue;
        let funcName = delegateBind.node_name.value;
        if (!funcName)
          continue;
        if (delegateBind.node_name.type == node_types.ConstName)
          funcName = funcName.substring(2, funcName.length - 1);
        else
          funcName = funcName.substring(1, funcName.length - 1);
        let objType = scriptfiles2.ResolveTypeFromExpression(delegateBind.scope, delegateBind.node_object);
        if (!objType)
          continue;
        let foundFunc = objType.findFirstSymbol(funcName, typedb2.DBAllowSymbol.Functions);
        if (!foundFunc)
          foundFunc = objType.findMethodByUnrealName(funcName);
        if (!foundFunc || !(foundFunc instanceof typedb2.DBMethod)) {
          let classType = delegateBind.scope.getParentType();
          let delegateType2 = typedb2.GetTypeByName(delegateBind.delegateType);
          let data = null;
          if (delegateType2 && classType && classType.name == objType.name) {
            data = {
              type: "delegateBind",
              delegate: delegateType2.name,
              name: funcName
            };
            if (delegateBind.node_wildcard && delegateBind.wildcard_name) {
              let providedWildcardType2 = scriptfiles2.ResolveTypeFromExpression(delegateBind.scope, delegateBind.node_wildcard);
              if (providedWildcardType2) {
                data["wildcardType"] = providedWildcardType2.name;
                data["wildcardName"] = delegateBind.wildcard_name;
              }
            }
          }
          diagnostics.push({
            severity: node_12.DiagnosticSeverity.Error,
            range: asmodule.getRange(delegateBind.statement.start_offset + delegateBind.node_expression.start, delegateBind.statement.start_offset + delegateBind.node_expression.end),
            message: "Function " + funcName + " does not exist in type " + objType.name,
            source: "angelscript",
            data
          });
          continue;
        }
        if (!foundFunc.isUFunction) {
          let baseFunc = objType.getBaseMethod(funcName);
          if (!baseFunc || !baseFunc.isUFunction) {
            diagnostics.push({
              severity: node_12.DiagnosticSeverity.Error,
              range: asmodule.getRange(delegateBind.statement.start_offset + delegateBind.node_expression.start, delegateBind.statement.start_offset + delegateBind.node_expression.end),
              message: "Function " + foundFunc.name + " in " + foundFunc.containingType.name + " is not declared UFUNCTION() and cannot be bound as a delegate",
              source: "angelscript"
            });
            continue;
          }
        } else if (foundFunc.getUnrealName() != funcName) {
          diagnostics.push({
            severity: node_12.DiagnosticSeverity.Error,
            range: asmodule.getRange(delegateBind.statement.start_offset + delegateBind.node_expression.start, delegateBind.statement.start_offset + delegateBind.node_expression.end),
            message: "Function " + foundFunc.name + " in " + foundFunc.containingType.name + " is called " + foundFunc.getUnrealName() + " in C++ and must be bound using that name",
            source: "angelscript"
          });
          continue;
        }
        let delegateType = typedb2.GetTypeByName(delegateBind.delegateType);
        if (!delegateType || !delegateType.delegateArgs)
          continue;
        let providedWildcardType = null;
        let wildcardParameterName = null;
        if (delegateBind.node_wildcard && delegateBind.wildcard_name) {
          providedWildcardType = scriptfiles2.ResolveTypeFromExpression(delegateBind.scope, delegateBind.node_wildcard);
          wildcardParameterName = delegateBind.wildcard_name;
        }
        let signatureMatches = true;
        if (delegateType.delegateReturn != foundFunc.returnType)
          signatureMatches = false;
        if (delegateType.delegateArgs.length != foundFunc.args.length) {
          signatureMatches = false;
        } else {
          for (let i = 0; i < delegateType.delegateArgs.length; ++i) {
            let signatureArg = delegateType.delegateArgs[i].typename;
            let boundArg = foundFunc.args[i].typename;
            if (wildcardParameterName && providedWildcardType && delegateType.delegateArgs[i].name == wildcardParameterName)
              signatureArg = typedb2.TransferTypeQualifiers(signatureArg, providedWildcardType.name);
            let leftTypename = typedb2.CleanTypeName(signatureArg);
            let rightTypename = typedb2.CleanTypeName(boundArg);
            if (leftTypename != rightTypename) {
              if (!typedb2.ArePrimitiveTypesEquivalent(leftTypename, rightTypename)) {
                signatureMatches = false;
                break;
              }
            }
            if (signatureArg.endsWith("&out") != boundArg.endsWith("&out")) {
              signatureMatches = false;
              break;
            }
            let isReferenceInUnreal = false;
            if (signatureArg.endsWith("&in"))
              isReferenceInUnreal = true;
            else if (signatureArg.endsWith("&") && !signatureArg.startsWith("const "))
              isReferenceInUnreal = true;
            let isBindReference = false;
            if (boundArg.endsWith("&in"))
              isBindReference = true;
            else if (boundArg.endsWith("&") && !boundArg.startsWith("const "))
              isBindReference = true;
            if (isReferenceInUnreal != isBindReference) {
              signatureMatches = false;
              break;
            }
            if (isReferenceInUnreal && isBindReference) {
              if (signatureArg.startsWith("const ") && !boundArg.startsWith("const ")) {
                signatureMatches = false;
                break;
              }
            }
          }
        }
        if (!signatureMatches) {
          diagnostics.push({
            severity: node_12.DiagnosticSeverity.Error,
            range: asmodule.getRange(delegateBind.statement.start_offset + delegateBind.node_expression.start, delegateBind.statement.start_offset + delegateBind.node_expression.end),
            message: "Cannot bind function " + foundFunc.name + " in " + foundFunc.containingType.name + ".\nExpected Signature: " + delegateType.formatDelegateSignature(wildcardParameterName, providedWildcardType) + "\nGot Signature: " + foundFunc.format(),
            source: "angelscript"
          });
          continue;
        }
      }
    }
    function TrimDiagnosticPositions(asmodule, diagnostics) {
      if (!asmodule || !asmodule.loaded)
        return;
      for (let diag of diagnostics) {
        let orig_start = diag.range.start;
        let orig_end = diag.range.end;
        {
          let offset = asmodule.getOffset(node_12.Position.create(diag.range.start.line, 0));
          while (offset < asmodule.content.length) {
            let char = asmodule.content[offset];
            if (char == " " || char == "	") {
              offset += 1;
            } else {
              if (char != "\n" && char != "\r")
                diag.range.start = asmodule.getPosition(offset);
              break;
            }
          }
        }
        {
          let offset = asmodule.getOffset(node_12.Position.create(diag.range.end.line, 1e4)) - 1;
          let foundNewline = false;
          while (offset >= 0) {
            let char = asmodule.content[offset];
            if (char == "\n") {
              if (foundNewline)
                break;
              foundNewline = true;
              offset -= 1;
            } else if (char == "\r") {
              offset -= 1;
            } else
              break;
          }
          while (offset >= 0) {
            let char = asmodule.content[offset];
            if (char == " " || char == "	") {
              offset -= 1;
            } else {
              if (char != "\n" && char != "\r")
                diag.range.end = asmodule.getPosition(offset + 1);
              break;
            }
          }
        }
        if (diag.range.start.line == diag.range.end.line) {
          if (diag.range.end.character - diag.range.start.character <= 3) {
            diag.range.start = orig_start;
            diag.range.end = orig_end;
          }
        }
      }
    }
    function AreDiagnosticsEqual(oldList, newList) {
      if (!oldList && newList)
        return false;
      if (oldList && !newList)
        return false;
      if (oldList.length != newList.length)
        return false;
      for (let i = 0; i < oldList.length; ++i) {
        let oldDiag = oldList[i];
        let newDiag = newList[i];
        if (oldDiag.code != newDiag.code)
          return false;
        if (oldDiag.codeDescription != newDiag.codeDescription)
          return false;
        if (oldDiag.data != newDiag.data)
          return false;
        if (oldDiag.message != newDiag.message)
          return false;
        if (oldDiag.severity != newDiag.severity)
          return false;
        if (oldDiag.source != newDiag.source)
          return false;
        if (oldDiag.range.start.line != newDiag.range.start.line)
          return false;
        if (oldDiag.range.start.character != newDiag.range.start.character)
          return false;
        if (oldDiag.range.end.line != newDiag.range.end.line)
          return false;
        if (oldDiag.range.end.character != newDiag.range.end.character)
          return false;
        if (oldDiag.tags && newDiag.tags) {
          if (oldDiag.tags.length != newDiag.tags.length)
            return false;
          for (let j = 0; j < oldDiag.tags.length; ++j) {
            if (oldDiag.tags[j] != newDiag.tags[j])
              return false;
          }
        } else if (!!oldDiag.tags != !!newDiag.tags) {
          return false;
        }
      }
      return true;
    }
    function AddSymbolDiagnostics(asmodule, diagnostics) {
      if (!asmodule.isOpened)
        return;
      for (let symbol of asmodule.semanticSymbols) {
        if (!symbol.isUnimported)
          continue;
        let displayName = symbol.symbol_name;
        if (displayName.startsWith("__"))
          displayName = displayName.substr(2);
        diagnostics.push({
          severity: node_12.DiagnosticSeverity.Information,
          range: asmodule.getRange(symbol.start, symbol.end),
          message: displayName + " must be imported.",
          source: "angelscript",
          data: {
            type: "import",
            symbol: [symbol.type, symbol.container_type, symbol.symbol_name]
          }
        });
      }
    }
    function AddFunctionDiagnostics(scope, dbfunc, diagnostics) {
      if (dbfunc.containingType) {
        let parentType = dbfunc.containingType.getSuperType();
        if (parentType) {
          let parentMethod = parentType.findFirstSymbol(dbfunc.name, typedb2.DBAllowSymbol.Functions);
          if (parentMethod && parentMethod instanceof typedb2.DBMethod) {
            if (!dbfunc.hasSuperCall && (dbfunc.isBlueprintEvent && (!dbfunc.returnType || dbfunc.returnType == "void") && !parentMethod.isEmpty || parentMethod.hasMetaData("RequireSuperCall")) && parentMethod.declaredModule && !parentMethod.hasMetaData("NoSuperCall") && !dbfunc.hasMetaData("NoSuperCall")) {
              diagnostics.push({
                severity: node_12.DiagnosticSeverity.Warning,
                range: scope.module.getRange(scope.declaration.start_offset + scope.declaration.ast.start, scope.declaration.start_offset + scope.declaration.ast.end),
                message: "Overriding " + parentMethod.name + " from parent without calling Super::" + parentMethod.name + "(...)\n(Add 'NoSuperCall' meta to suppress warning)",
                source: "angelscript",
                data: {
                  type: "superCall",
                  inType: parentMethod.containingType.name,
                  name: parentMethod.name
                }
              });
            }
            if (!dbfunc.isOverride && !dbfunc.isBlueprintEvent && parentMethod.declaredModule) {
              let matchesParentSignature = false;
              let allBaseMethods = parentType.findSymbols(dbfunc.name);
              for (let baseMethod of allBaseMethods) {
                if (baseMethod instanceof typedb2.DBMethod) {
                  if (baseMethod.isSignatureEqual(dbfunc)) {
                    matchesParentSignature = true;
                    break;
                  }
                }
              }
              if (matchesParentSignature) {
                diagnostics.push({
                  severity: node_12.DiagnosticSeverity.Warning,
                  range: scope.module.getRange(scope.declaration.start_offset + scope.declaration.ast.start, scope.declaration.start_offset + scope.declaration.ast.end),
                  message: "Overriding script method " + parentMethod.name + " without `override` keyword",
                  source: "angelscript"
                });
              }
            }
          }
        }
      }
    }
    function AddNamingConventionDiagnostics(asmodule, diagnostics) {
      if (!DiagnosticSettings.namingConventionDiagnostics)
        return;
      AddScopeNamingConventionDiagnostics(asmodule.rootscope, diagnostics);
    }
    function IsMaybeActorType(dbtype) {
      let checkType = dbtype;
      let depth = 0;
      while (checkType && depth < 100) {
        if (checkType.name == "AActor")
          return true;
        if (checkType.supertype) {
          let superType = checkType.getSuperType();
          if (superType) {
            checkType = superType;
            depth += 1;
            continue;
          } else
            return checkType.supertype.startsWith("A");
        }
        if (checkType.unrealsuper) {
          let superType = typedb2.GetTypeByName(checkType.unrealsuper);
          if (superType) {
            checkType = superType;
            depth += 1;
            continue;
          } else
            return checkType.unrealsuper.startsWith("A");
        }
        return false;
      }
      return false;
    }
    function AddScopeNamingConventionDiagnostics(scope, diagnostics) {
      let scopeType = scope.getDatabaseType();
      if (scopeType) {
        let suggestedName = scopeType.getDisplayName();
        let hasSuggestion = false;
        if (scopeType.isEnum) {
          if (suggestedName.length >= 1 && suggestedName[0] != "E") {
            if (suggestedName[0] == "U" || suggestedName[0] == "A" || suggestedName[0] == "F")
              suggestedName = "E" + suggestedName.substring(1);
            else
              suggestedName = "E" + suggestedName;
            hasSuggestion = true;
          }
        } else if (scopeType.isStruct) {
          if (suggestedName.length >= 1 && suggestedName[0] != "F") {
            if (suggestedName[0] == "U" || suggestedName[0] == "A" || suggestedName[0] == "E")
              suggestedName = "F" + suggestedName.substring(1);
            else
              suggestedName = "F" + suggestedName;
            hasSuggestion = true;
          }
        } else if (IsMaybeActorType(scopeType)) {
          if (suggestedName.length >= 1 && suggestedName[0] != "A") {
            if (suggestedName[0] == "U" || suggestedName[0] == "F" || suggestedName[0] == "E")
              suggestedName = "A" + suggestedName.substring(1);
            else
              suggestedName = "A" + suggestedName;
            hasSuggestion = true;
          }
        } else {
          if (suggestedName.length >= 1 && suggestedName[0] != "U") {
            if (suggestedName[0] == "A" || suggestedName[0] == "F" || suggestedName[0] == "E")
              suggestedName = "U" + suggestedName.substring(1);
            else
              suggestedName = "U" + suggestedName;
            hasSuggestion = true;
          }
        }
        if (suggestedName.length >= 2) {
          let charCode = suggestedName.charCodeAt(1);
          if (charCode >= 97 && charCode <= 122) {
            suggestedName = suggestedName[0] + suggestedName[1].toUpperCase() + suggestedName.substr(2);
            hasSuggestion = true;
          }
        }
        if (hasSuggestion) {
          diagnostics.push({
            severity: node_12.DiagnosticSeverity.Warning,
            range: scope.module.getRange(scopeType.moduleOffset, scopeType.moduleOffsetEnd),
            message: `Type '${scopeType.getDisplayName()}' violates the Unreal naming convention. Suggested: ${suggestedName}`,
            source: "angelscript"
          });
        }
      }
      if (scope.module.isOpened) {
        let scopeFunc = scope.getDatabaseFunction();
        if (scopeFunc) {
          let suggestedName = scopeFunc.name;
          let hasSuggestion = false;
          if (suggestedName.length >= 1) {
            let charCode = suggestedName.charCodeAt(0);
            if (charCode >= 97 && charCode <= 122) {
              if (!suggestedName.startsWith("op") || suggestedName.startsWith("~")) {
                suggestedName = suggestedName[0].toUpperCase() + suggestedName.substr(1);
                hasSuggestion = true;
              }
            }
          }
          if (hasSuggestion) {
            diagnostics.push({
              severity: node_12.DiagnosticSeverity.Hint,
              range: scope.module.getRange(scopeFunc.moduleOffset, scopeFunc.moduleOffsetEnd),
              message: `Function '${scopeFunc.name}' violates the Unreal naming convention. Suggested: ${suggestedName}`,
              source: "angelscript"
            });
          }
        }
        for (let scopeVar of scope.variables) {
          let suggestedName = scopeVar.name;
          let hasSuggestion = false;
          if (typedb2.CleanTypeName(scopeVar.typename) == "bool") {
            if (suggestedName.length >= 1 && suggestedName[0] != "b") {
              if (scopeVar.isArgument && (suggestedName.startsWith("In") || suggestedName.startsWith("Out")))
                continue;
              suggestedName = "b" + suggestedName;
              hasSuggestion = true;
            }
            if (suggestedName.length >= 2) {
              let charCode = suggestedName.charCodeAt(1);
              if (charCode >= 97 && charCode <= 122) {
                suggestedName = suggestedName[0] + suggestedName[1].toUpperCase() + suggestedName.substr(2);
                hasSuggestion = true;
              }
            }
            if (hasSuggestion) {
              if (scope.scopetype == scriptfiles2.ASScopeType.Class || scope.scopetype == scriptfiles2.ASScopeType.Global || scope.scopetype == scriptfiles2.ASScopeType.Namespace) {
                if (scope.module.isEditingInside(scopeVar.start_offset_name, scopeVar.end_offset_name) && scopeVar.start_offset_expression == -1) {
                  hasSuggestion = false;
                }
              }
            }
          } else {
            if (suggestedName.length == 1 && scopeVar.isLoopVariable)
              continue;
            if (suggestedName.length >= 1) {
              let charCode = suggestedName.charCodeAt(0);
              if (charCode >= 97 && charCode <= 122) {
                suggestedName = suggestedName[0].toUpperCase() + suggestedName.substr(1);
                hasSuggestion = true;
              }
            }
          }
          if (hasSuggestion) {
            diagnostics.push({
              severity: node_12.DiagnosticSeverity.Hint,
              range: scope.module.getRange(scopeVar.start_offset_name, scopeVar.end_offset_name),
              message: `Variable '${scopeVar.name}' violates the Unreal naming convention. Suggested: ${suggestedName}`,
              source: "angelscript"
            });
          }
        }
      }
      for (let subscope of scope.scopes)
        AddScopeNamingConventionDiagnostics(subscope, diagnostics);
    }
  }
});

// unreal-angelscript-lsp/language-server/out/assets.js
var require_assets = __commonJS({
  "unreal-angelscript-lsp/language-server/out/assets.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClearDatabase = exports2.GetShortAssetName = exports2.GetAssetsImplementing = exports2.RemoveAsset = exports2.AddAsset = void 0;
    var AssetPathToClass = /* @__PURE__ */ new Map();
    var ClassToReferencingAssets = /* @__PURE__ */ new Map();
    function AddAsset(assetPath, className) {
      let prevClass = AssetPathToClass.get(assetPath);
      if (prevClass == className)
        return;
      AssetPathToClass.set(assetPath, className);
      let list = ClassToReferencingAssets.get(className);
      if (!list) {
        list = new Array();
        ClassToReferencingAssets.set(className, list);
      }
      list.push(assetPath);
    }
    exports2.AddAsset = AddAsset;
    function RemoveAsset(assetPath) {
      let prevClass = AssetPathToClass.get(assetPath);
      if (!prevClass)
        return;
      AssetPathToClass.delete(assetPath);
      let list = ClassToReferencingAssets.get(prevClass);
      if (list) {
        let index = list.indexOf(assetPath);
        if (index != -1)
          list.splice(index, 1);
      }
    }
    exports2.RemoveAsset = RemoveAsset;
    function GetAssetsImplementing(className) {
      let references = ClassToReferencingAssets.get(className);
      if (!references && (className[0] == "U" || className[0] == "A"))
        references = ClassToReferencingAssets.get(className.substring(1));
      return references;
    }
    exports2.GetAssetsImplementing = GetAssetsImplementing;
    function GetShortAssetName(assetPath) {
      let index = assetPath.lastIndexOf("/");
      if (index == -1)
        return assetPath;
      return assetPath.substr(index + 1);
    }
    exports2.GetShortAssetName = GetShortAssetName;
    function ClearDatabase() {
      AssetPathToClass.clear();
      ClassToReferencingAssets.clear();
    }
    exports2.ClearDatabase = ClearDatabase;
  }
});

// unreal-angelscript-lsp/language-server/out/code_lenses.js
var require_code_lenses = __commonJS({
  "unreal-angelscript-lsp/language-server/out/code_lenses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AllowCreateBlueprintForClass = exports2.ComputeCodeLenses = exports2.LoadFileTemplates = exports2.GetCodeLensSettings = void 0;
    var scriptfiles2 = require_as_parser();
    var typedb2 = require_database();
    var assets2 = require_assets();
    var fs = require("fs");
    var path = require("path");
    var vscode_languageserver_1 = require_main4();
    var ASFileTemplate = class {
      constructor() {
        this.order = 0;
      }
    };
    var FileTemplates = new Array();
    var FileTemplateNames = /* @__PURE__ */ new Set();
    var CodeLensSettings = {
      engineSupportsCreateBlueprint: false,
      showCreateBlueprintClasses: []
    };
    function GetCodeLensSettings() {
      return CodeLensSettings;
    }
    exports2.GetCodeLensSettings = GetCodeLensSettings;
    function LoadFileTemplates(filenames) {
      for (let file of filenames) {
        try {
          let content = fs.readFileSync(file, "utf8");
          let basename = path.basename(file, ".as.template");
          let template = new ASFileTemplate();
          template.content = content;
          template.name = basename.replace("_", " ");
          let match = template.name.match(/^([0-9]+)\.(.*)/);
          if (match) {
            template.name = match[2];
            template.order = parseInt(match[1]);
          }
          if (!FileTemplateNames.has(template.name.toLowerCase())) {
            FileTemplateNames.add(template.name.toLowerCase());
            FileTemplates.push(template);
          }
        } catch (readError) {
          continue;
        }
      }
      if (!FileTemplateNames.has("actor")) {
        let template = new ASFileTemplate();
        template.content = `class A\${TM_FILENAME_BASE} : AActor
{
	UPROPERTY(DefaultComponent, RootComponent)
	USceneComponent Root;$0

	UFUNCTION(BlueprintOverride)
	void BeginPlay()
	{
	}
};`;
        template.name = "Actor";
        FileTemplates.push(template);
        FileTemplateNames.add("actor");
      }
      if (!FileTemplateNames.has("component")) {
        let template = new ASFileTemplate();
        template.content = `class U\${TM_FILENAME_BASE} : UActorComponent
{$0
	UFUNCTION(BlueprintOverride)
	void BeginPlay()
	{
	}
};`;
        template.name = "Component";
        FileTemplates.push(template);
        FileTemplateNames.add("component");
      }
      FileTemplates.sort(function(a, b) {
        if (a.order < b.order)
          return -1;
        else if (a.order > b.order)
          return 1;
        else
          return 0;
      });
    }
    exports2.LoadFileTemplates = LoadFileTemplates;
    function ComputeCodeLenses(asmodule) {
      let lenses = new Array();
      AddScopeLenses(asmodule.rootscope, lenses);
      if (asmodule.rootscope.next == null && FileTemplates.length != 0 && asmodule.content.match(/^[\s\r\n]*$/)) {
        for (let template of FileTemplates) {
          if (template.content.length == 0)
            continue;
          lenses.push({
            range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(0, 0), vscode_languageserver_1.Position.create(0, 1e4)),
            command: {
              title: "Create " + template.name,
              command: "editor.action.insertSnippet",
              arguments: [{
                "snippet": template.content
              }]
            }
          });
        }
      }
      for (let asset of asmodule.literalAssets) {
        let dbtype = typedb2.GetTypeByName(asset.type);
        if (!dbtype)
          continue;
        let canEdit = false;
        if (dbtype.inheritsFrom("UCurveFloat"))
          canEdit = true;
        if (canEdit) {
          let startPos = asmodule.getPosition(asset.statement.end_offset);
          let lensLine = Math.max(startPos.line - 1, 0);
          lenses.push({
            range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lensLine, 0), vscode_languageserver_1.Position.create(lensLine, 1e4)),
            command: {
              title: "Edit " + asset.name + " in Unreal",
              command: "angelscript.saveAndEditAsset",
              arguments: [asmodule.uri, "/Script/AngelscriptAssets." + asset.name]
            }
          });
        }
      }
      return lenses;
    }
    exports2.ComputeCodeLenses = ComputeCodeLenses;
    function AddScopeLenses(scope, lenses) {
      if (scope.scopetype == scriptfiles2.ASScopeType.Class) {
        if (scope.dbtype && !scope.dbtype.isStruct)
          AddAssetImplementationsLense(scope, scope.dbtype, lenses);
      }
      for (let subscope of scope.scopes)
        AddScopeLenses(subscope, lenses);
    }
    function AllowCreateBlueprintForClass(dbtype) {
      if (!CodeLensSettings.engineSupportsCreateBlueprint)
        return false;
      if (dbtype.macroSpecifiers && dbtype.macroSpecifiers.has("NotBlueprintable"))
        return false;
      return true;
    }
    exports2.AllowCreateBlueprintForClass = AllowCreateBlueprintForClass;
    function ShowCreateBlueprintForClass(dbtype) {
      if (!AllowCreateBlueprintForClass(dbtype))
        return false;
      if (dbtype.inheritsFrom("UDataAsset"))
        return true;
      for (let showClass of CodeLensSettings.showCreateBlueprintClasses) {
        if (dbtype.inheritsFrom(showClass))
          return true;
      }
      return false;
    }
    function AddAssetImplementationsLense(scope, dbtype, lenses) {
      let references = assets2.GetAssetsImplementing(dbtype.name);
      if (references && references.length != 0) {
        let message = null;
        let isDataAsset = dbtype.inheritsFrom("UDataAsset");
        if (references.length == 1 && !isDataAsset) {
          message = "Implemented by " + assets2.GetShortAssetName(references[0]);
        } else if (references.length <= 3) {
          if (isDataAsset)
            message = "Used by data assets: ";
          else
            message = "Implemented by ";
          for (let i = 0; i < references.length; ++i) {
            if (i != 0)
              message += ", ";
            message += assets2.GetShortAssetName(references[i]);
          }
        } else {
          if (isDataAsset)
            message = "Used by " + references.length + " data assets";
          else
            message = "Implemented by " + references.length + " blueprints";
        }
        let startPos = scope.module.getPosition(dbtype.moduleOffset);
        let lensLine = Math.max(startPos.line, 0);
        lenses.push({
          range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lensLine, 0), vscode_languageserver_1.Position.create(lensLine, 1e4)),
          command: {
            title: message,
            command: "angelscript.openAssets",
            arguments: [dbtype.name]
          }
        });
        if (isDataAsset && AllowCreateBlueprintForClass(dbtype)) {
          lenses.push({
            range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lensLine, 0), vscode_languageserver_1.Position.create(lensLine, 1e4)),
            command: {
              title: "Create Asset",
              command: "angelscript.saveAndCreateBlueprint",
              arguments: [scope.module.uri, dbtype.name]
            }
          });
        }
      } else if (ShowCreateBlueprintForClass(dbtype)) {
        let startPos = scope.module.getPosition(dbtype.moduleOffset);
        let lensLine = Math.max(startPos.line, 0);
        let isDataAsset = dbtype.inheritsFrom("UDataAsset");
        let message = null;
        if (isDataAsset)
          message = "Create Asset";
        else
          message = "Create Blueprint";
        lenses.push({
          range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(lensLine, 0), vscode_languageserver_1.Position.create(lensLine, 1e4)),
          command: {
            title: message,
            command: "angelscript.saveAndCreateBlueprint",
            arguments: [scope.module.uri, dbtype.name]
          }
        });
      }
    }
  }
});

// unreal-angelscript-lsp/language-server/out/code_actions.js
var require_code_actions = __commonJS({
  "unreal-angelscript-lsp/language-server/out/code_actions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtendIndent = exports2.GetIndentForBlock = exports2.GetIndentForStatement = exports2.ResolveCodeAction = exports2.GetCodeActions = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var typedb2 = require_database();
    var scriptfiles2 = require_as_parser();
    var scriptsymbols2 = require_symbols();
    var completion = require_parsed_completion();
    var code_lenses_1 = require_code_lenses();
    var CodeActionContext = class {
      constructor() {
        this.first_symbol = 0;
        this.last_symbol = 0;
      }
    };
    function GetCodeActions(asmodule, range, diagnostics) {
      let context = new CodeActionContext();
      context.module = asmodule;
      context.actions = new Array();
      context.range_start = asmodule.getOffset(vscode_languageserver_types_1.Position.create(range.start.line, 0));
      context.range_end = asmodule.getOffset(vscode_languageserver_types_1.Position.create(range.end.line, 1e4));
      context.scope = asmodule.getScopeAt(context.range_start);
      context.statement = asmodule.getStatementAt(context.range_start);
      context.diagnostics = diagnostics;
      let foundSymbol = false;
      context.last_symbol = context.module.semanticSymbols.length;
      for (let i = 0, count = context.module.semanticSymbols.length; i < count; ++i) {
        let symbol = context.module.semanticSymbols[i];
        if (symbol.end < context.range_start)
          continue;
        if (symbol.start > context.range_end) {
          context.last_symbol = i;
          break;
        }
        if (!foundSymbol) {
          context.first_symbol = i;
          foundSymbol = true;
        }
      }
      if (!foundSymbol) {
        context.first_symbol = 0;
        context.last_symbol = 0;
      }
      if (!scriptfiles2.GetScriptSettings().automaticImports)
        AddImportActions(context);
      AddAutoActions(context);
      AddMacroActions(context);
      AddGenerateDelegateFunctionActions(context);
      AddCreateBlueprintActions(context);
      AddMethodOverrideSnippets(context);
      AddCastHelpers(context);
      AddSuperCallHelper(context);
      AddVariablePromotionHelper(context);
      AddConditionVariablePromotionHelper(context);
      AddSwitchCaseActions(context);
      AddGenerateMethodActions(context);
      if (scriptfiles2.GetScriptSettings().useAngelscriptHaze) {
        AddGenerateParamsStructActions(context);
      }
      return context.actions;
    }
    exports2.GetCodeActions = GetCodeActions;
    function ResolveCodeAction(asmodule, action, data) {
      if (data.type == "import")
        ResolveImportAction(asmodule, action, data);
      else if (data.type == "delegateBind")
        ResolveGenerateDelegateFunctionAction(asmodule, action, data);
      else if (data.type == "methodOverride")
        ResolveMethodOverrideSnippet(asmodule, action, data);
      else if (data.type == "addCast")
        ResolveCastHelper(asmodule, action, data);
      else if (data.type == "superCall")
        ResolveSuperCallHelper(asmodule, action, data);
      else if (data.type == "materializeAuto")
        ResolveAutoAction(asmodule, action, data);
      else if (data.type == "variablePromotion")
        ResolveVariablePromotionHelper(asmodule, action, data);
      else if (data.type == "insertMacro")
        ResolveInsertMacro(asmodule, action, data);
      else if (data.type == "insertCases")
        ResolveInsertCases(asmodule, action, data);
      else if (data.type == "methodFromUsage")
        ResolveGenerateMethod(asmodule, action, data);
      else if (data.type == "createActivationParameters")
        ResolveCreateActivationParameters(asmodule, action, data);
      else if (data.type == "createDeactivationParameters")
        ResolveCreateDeactivationParameters(asmodule, action, data);
      return action;
    }
    exports2.ResolveCodeAction = ResolveCodeAction;
    function AddImportActions(context) {
      for (let symbol of context.module.semanticSymbols) {
        if (!symbol.isUnimported)
          continue;
        if (!symbol.overlapsRange(context.range_start, context.range_end))
          continue;
        let appliedTo = new Array();
        for (let diag of context.diagnostics) {
          if (diag.data) {
            let data = diag.data;
            if (data.type && data.type == "import") {
              if (data.symbol[0] == symbol.type && data.symbol[1] == symbol.container_type && data.symbol[2] == symbol.symbol_name) {
                appliedTo.push(diag);
              }
            }
          }
        }
        let symbolDisplayName = symbol.symbol_name;
        if (symbolDisplayName.startsWith("__"))
          symbolDisplayName = symbolDisplayName.substr(2);
        context.actions.push({
          kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
          title: "Import " + symbolDisplayName,
          source: "angelscript",
          diagnostics: appliedTo,
          isPreferred: true,
          data: {
            "uri": context.module.uri,
            "type": "import",
            "symbol": {
              "type": symbol.type,
              "container_type": symbol.container_type,
              "symbol_name": symbol.symbol_name,
              "start": symbol.start,
              "end": symbol.end,
              "isWriteAccess": symbol.isWriteAccess,
              "isUnimported": symbol.isUnimported,
              "isAuto": symbol.isAuto,
              "noColor": symbol.noColor
            }
          }
        });
      }
    }
    function ResolveImportAction(asmodule, action, data) {
      let definitions = scriptsymbols2.GetSymbolDefinition(asmodule, data.symbol);
      if (!definitions || definitions.length == 0)
        return action;
      let moduleName = definitions[0].module.modulename;
      if (asmodule.isModuleImported(moduleName))
        return action;
      let lastImportLine = 0;
      let lineCount = asmodule.textDocument.lineCount;
      let hasEmptyLine = false;
      let alreadyImported = false;
      let importRegex = /\s*import\s+([A-Za-z0-9_]+(\.[A-Za-z0-9_]+)*);/;
      for (let i = 0; i < lineCount; ++i) {
        let line = asmodule.textDocument.getText(vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(i, 0), vscode_languageserver_types_1.Position.create(i, 1e4)));
        let match = importRegex.exec(line);
        if (match) {
          if (match[1] == moduleName) {
            alreadyImported = true;
            break;
          }
          lastImportLine = i + 1;
          hasEmptyLine = false;
        } else if (line.trim().length != 0) {
          break;
        } else {
          hasEmptyLine = true;
        }
      }
      action.edit = {};
      action.edit.changes = {};
      if (alreadyImported)
        return;
      let insertString = "import " + moduleName + ";\n";
      if (!hasEmptyLine)
        insertString += "\n";
      action.edit.changes[asmodule.displayUri] = [
        vscode_languageserver_types_1.TextEdit.insert(vscode_languageserver_types_1.Position.create(lastImportLine, 0), insertString)
      ];
    }
    function AddGenerateDelegateFunctionActions(context) {
      let generateFromDiagnostics = [];
      for (let diag of context.diagnostics) {
        let data = diag.data;
        if (data && data.type == "delegateBind") {
          context.actions.push({
            kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
            title: "Generate Method: " + data.name + "()",
            source: "angelscript",
            diagnostics: [diag],
            isPreferred: true,
            data: {
              uri: context.module.uri,
              type: "delegateBind",
              delegate: data.delegate,
              name: data.name,
              position: diag.range.start,
              wildcardType: data.wildcardType,
              wildcardName: data.wildcardName
            }
          });
          generateFromDiagnostics.push(data.name);
        }
      }
      for (let delegateBind of context.module.delegateBinds) {
        if (delegateBind.statement == context.statement) {
          if (!delegateBind.node_name)
            continue;
          if (!delegateBind.node_object)
            continue;
          let funcName = delegateBind.node_name.value;
          if (!funcName)
            continue;
          if (delegateBind.node_name.type != scriptfiles2.node_types.ConstName && delegateBind.node_name.type != scriptfiles2.node_types.ConstString)
            continue;
          if (delegateBind.node_name.type == scriptfiles2.node_types.ConstName)
            funcName = funcName.substring(2, funcName.length - 1);
          else
            funcName = funcName.substring(1, funcName.length - 1);
          if (generateFromDiagnostics.includes(funcName))
            continue;
          generateFromDiagnostics.push(funcName);
          let objType = scriptfiles2.ResolveTypeFromExpression(delegateBind.scope, delegateBind.node_object);
          if (!objType)
            continue;
          let foundFunc = objType.findFirstSymbol(funcName, typedb2.DBAllowSymbol.Functions);
          if (!foundFunc)
            foundFunc = objType.findMethodByUnrealName(funcName);
          if (foundFunc && foundFunc instanceof typedb2.DBMethod)
            continue;
          let wildcardType = null;
          let wildcardName = null;
          if (delegateBind.node_wildcard && delegateBind.wildcard_name) {
            let providedWildcardType = scriptfiles2.ResolveTypeFromExpression(delegateBind.scope, delegateBind.node_wildcard);
            if (providedWildcardType) {
              wildcardType = providedWildcardType.name;
              wildcardName = delegateBind.wildcard_name;
            }
          }
          context.actions.push({
            kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
            title: "Generate Method: " + funcName + "()",
            source: "angelscript",
            isPreferred: true,
            data: {
              uri: context.module.uri,
              type: "delegateBind",
              delegate: delegateBind.delegateType,
              name: funcName,
              position: context.module.getPosition(delegateBind.statement.start_offset + delegateBind.node_expression.start),
              wildcardType,
              wildcardName
            }
          });
        }
      }
    }
    function ResolveGenerateDelegateFunctionAction(asmodule, action, data) {
      let delegateType = typedb2.GetTypeByName(data.delegate);
      if (!delegateType)
        return;
      let [insertPosition, indent, prefix, suffix] = FindInsertPositionForGeneratedDelegateBind(asmodule, data.position);
      let snippet = prefix;
      snippet += indent + "UFUNCTION()\n";
      let delegateArgs = delegateType.delegateArgs;
      if (data["wildcardType"] && data["wildcardName"]) {
        for (let i = 0; i < delegateArgs.length; ++i) {
          if (delegateArgs[i].name == data["wildcardName"]) {
            let modifiedArgs = new Array();
            for (let j = 0; j < delegateArgs.length; ++j) {
              if (i == j) {
                let arg = new typedb2.DBArg();
                arg.name = delegateArgs[j].name;
                arg.defaultvalue = delegateArgs[j].defaultvalue;
                arg.typename = typedb2.TransferTypeQualifiers(delegateArgs[j].typename, data["wildcardType"]);
                modifiedArgs.push(arg);
              } else {
                modifiedArgs.push(delegateArgs[j]);
              }
            }
            delegateArgs = modifiedArgs;
            break;
          }
        }
      }
      snippet += GenerateMethodHeaderString("private ", indent, data.name, delegateType.delegateReturn, delegateArgs);
      snippet += "\n";
      snippet += indent + "{\n";
      snippet += indent + "}\n";
      snippet += suffix;
      action.edit = {};
      action.edit.changes = {};
      action.edit.changes[asmodule.displayUri] = [
        vscode_languageserver_types_1.TextEdit.insert(insertPosition, snippet)
      ];
    }
    function GenerateMethodHeaderString(prefix, indent, name, returnType, args) {
      let snippet = indent + prefix;
      let preambleLength = name.length + 2 + prefix.length;
      if (returnType) {
        snippet += returnType;
        preambleLength += returnType.length;
      } else {
        snippet += "void";
        preambleLength += 4;
      }
      snippet += " ";
      snippet += name;
      snippet += "(";
      let lineLength = preambleLength + indent.length;
      if (args) {
        for (let i = 0; i < args.length; ++i) {
          let arg = args[i];
          let argLength = arg.typename.length;
          if (arg.name)
            argLength += arg.name.length + 1;
          if (lineLength + argLength > 100) {
            if (i != 0) {
              snippet += ",";
              lineLength += 1;
            }
            snippet += "\n" + indent + " ".repeat(preambleLength);
            lineLength = indent.length + preambleLength;
          } else if (i != 0) {
            snippet += ", ";
            lineLength += 2;
          }
          snippet += arg.typename;
          if (arg.name) {
            snippet += " ";
            snippet += arg.name;
          }
          lineLength += argLength;
        }
      }
      snippet += ")";
      return snippet;
    }
    function FindInsertPositionForGeneratedDelegateBind(asmodule, bindPosition) {
      let offset = asmodule.getOffset(bindPosition);
      let curScope = asmodule.getScopeAt(offset);
      let curStatement = curScope.getStatementAt(offset);
      let classScope = curScope.getParentTypeScope();
      if (!curStatement || !classScope)
        return FindInsertPositionForGeneratedMethod(asmodule, bindPosition);
      let insertPosition = null;
      let insideType = classScope.getDatabaseType();
      for (let otherBind of asmodule.delegateBinds) {
        if (!otherBind.statement)
          continue;
        if (!otherBind.node_name)
          continue;
        if (!otherBind.node_object)
          continue;
        if (curScope.end_offset < otherBind.statement.start_offset)
          break;
        if (otherBind.scope != curScope)
          continue;
        if (otherBind.statement == curStatement)
          continue;
        let boundFunction = otherBind.resolveBoundFunction();
        if (!boundFunction)
          continue;
        if (boundFunction.containingType != insideType)
          continue;
        if (otherBind.statement.start_offset < curStatement.start_offset) {
          insertPosition = asmodule.getPosition(boundFunction.moduleScopeEnd);
        } else if (otherBind.statement.start_offset > curStatement.end_offset) {
          if (!insertPosition) {
            insertPosition = asmodule.getPosition(boundFunction.moduleOffset);
            if (insertPosition.line > 0)
              insertPosition.line -= 1;
          }
          break;
        }
      }
      if (insertPosition)
        return FindInsertPositionForGeneratedMethod(asmodule, insertPosition);
      else
        return FindInsertPositionForGeneratedMethod(asmodule, bindPosition);
    }
    function FindInsertPositionForGeneratedMethod(asmodule, afterPosition) {
      let offset = asmodule.getOffset(afterPosition);
      let curScope = asmodule.getScopeAt(offset);
      let classScope = curScope.getParentTypeScope();
      let indent = null;
      let prefix = "";
      let suffix = "";
      if (!classScope)
        return [vscode_languageserver_types_1.Position.create(afterPosition.line, 0), "	", prefix, suffix];
      for (let statement of classScope.statements) {
        let lines = statement.content.split("\n");
        for (let line of lines) {
          if (!/^[ \t\r\n]*$/.test(line)) {
            indent = "";
            for (let i = 0; i < line.length; ++i) {
              let curchar = line[i];
              if (curchar == " " || curchar == "	") {
                indent += curchar;
              } else if (curchar == "\n" || curchar == "\r") {
                continue;
              } else if (curchar == "#") {
                indent = null;
                break;
              } else {
                break;
              }
            }
            break;
          }
        }
        if (indent)
          break;
      }
      if (!indent)
        indent = "	";
      let classStartPos = asmodule.getPosition(classScope.start_offset);
      for (let subscope of classScope.scopes) {
        let startOffset = subscope.start_offset;
        while (startOffset < subscope.end_offset) {
          let curchar = asmodule.content[startOffset];
          if (curchar == " " || curchar == "	" || curchar == "\r" || curchar == "\n")
            ++startOffset;
          else
            break;
        }
        let scopeStartPos = asmodule.getPosition(startOffset);
        let checkStartPos = scopeStartPos;
        if (subscope.element_head instanceof scriptfiles2.ASStatement)
          checkStartPos = asmodule.getPosition(subscope.element_head.start_offset);
        else if (!subscope.element_head)
          checkStartPos = asmodule.getPosition(subscope.end_offset);
        if (checkStartPos.line > afterPosition.line) {
          prefix += "\n";
          return [vscode_languageserver_types_1.Position.create(scopeStartPos.line - 1, 1e4), indent, prefix, suffix];
        }
      }
      let endOfClass = asmodule.getPosition(classScope.end_offset);
      if (!asmodule.isLineEmpty(endOfClass.line - 1))
        prefix += "\n";
      return [endOfClass, indent, prefix, suffix];
    }
    function AddMethodOverrideSnippets(context) {
      if (!context.scope)
        return;
      let typeOfScope = context.scope.getParentType();
      if (!typeOfScope || !typeOfScope.supertype)
        return;
      let validScope = false;
      if (context.scope.scopetype == scriptfiles2.ASScopeType.Class) {
        validScope = true;
      } else if (context.scope.scopetype == scriptfiles2.ASScopeType.Function) {
        if (context.statement && context.statement.ast && context.statement.ast.type == scriptfiles2.node_types.FunctionDecl) {
          validScope = true;
        }
      }
      if (!validScope)
        return;
      let foundOverrides = /* @__PURE__ */ new Set();
      typeOfScope.forEachSymbol(function(sym) {
        if (!(sym instanceof typedb2.DBMethod))
          return;
        let method = sym;
        if (method.containingType.isUnrealType() && !method.isBlueprintEvent)
          return;
        if (foundOverrides.has(method.name))
          return;
        if (method.name.startsWith("_"))
          return;
        let existingSymbol = typeOfScope.findFirstSymbol(method.name, typedb2.DBAllowSymbol.Functions);
        if (!existingSymbol || !existingSymbol.containingType)
          return;
        if (existingSymbol.containingType == typeOfScope)
          return;
        if (method.isPrivate)
          return;
        foundOverrides.add(method.name);
        if (method.isFinal)
          return;
        context.actions.push({
          kind: vscode_languageserver_types_1.CodeActionKind.Refactor,
          title: "Override: " + method.name + "()",
          source: "angelscript",
          data: {
            uri: context.module.uri,
            type: "methodOverride",
            inside: method.containingType.name,
            name: method.name,
            position: context.module.getPosition(context.range_start)
          }
        });
      });
    }
    function AddCreateBlueprintActions(context) {
      if (!context.scope)
        return;
      let typeOfScope = context.scope.getParentType();
      if (!typeOfScope || !typeOfScope.supertype)
        return;
      let validScope = false;
      if (context.scope.scopetype == scriptfiles2.ASScopeType.Class) {
        validScope = true;
      } else if (context.scope.scopetype == scriptfiles2.ASScopeType.Function) {
        if (context.statement && context.statement.ast && context.statement.ast.type == scriptfiles2.node_types.FunctionDecl) {
          validScope = true;
        }
      }
      if (!validScope)
        return;
      if ((0, code_lenses_1.AllowCreateBlueprintForClass)(typeOfScope)) {
        let title = "Create Blueprint";
        if (typeOfScope.inheritsFrom("UDataAsset"))
          title = "Create Asset";
        context.actions.push({
          kind: vscode_languageserver_types_1.CodeActionKind.Empty,
          title,
          source: "angelscript",
          command: {
            title,
            command: "angelscript.saveAndCreateBlueprint",
            arguments: [context.module.uri, typeOfScope.name]
          }
        });
      }
    }
    function ResolveMethodOverrideSnippet(asmodule, action, data) {
      let insideType = typedb2.GetTypeByName(data.inside);
      if (!insideType)
        return;
      let method = insideType.getMethod(data.name);
      if (!method)
        return;
      let offset = asmodule.getOffset(data.position);
      let scope = asmodule.getScopeAt(offset);
      let scopeType = scope ? scope.getParentType() : null;
      let [insertPosition, indent, prefix, suffix] = FindInsertPositionForGeneratedMethod(asmodule, data.position);
      let snippet = "";
      snippet += prefix;
      if (method.isBlueprintEvent)
        snippet += indent + "UFUNCTION(BlueprintOverride)\n";
      snippet += GenerateMethodHeaderString("", indent, data.name, method.returnType, method.args);
      if (method.isConst)
        snippet += " const";
      if (!method.isBlueprintEvent)
        snippet += " override";
      if (!method.isBlueprintEvent && method.isProperty && method.declaredModule)
        snippet += " property";
      snippet += "\n";
      snippet += indent + "{\n";
      if (scopeType) {
        let parentType = scopeType.getSuperType();
        if (parentType) {
          let parentMethod = parentType.findFirstSymbol(method.name, typedb2.DBAllowSymbol.Functions);
          if (parentMethod instanceof typedb2.DBMethod && parentMethod.declaredModule && !parentMethod.isEmpty) {
            let hasReturnValue = method.returnType && method.returnType != "void";
            if (!hasReturnValue || parentMethod.hasMetaData("RequireSuperCall")) {
              snippet += indent + indent;
              if (hasReturnValue)
                snippet += "return ";
              snippet += "Super::" + method.name + "(";
              for (let i = 0; i < method.args.length; ++i) {
                if (i != 0)
                  snippet += ", ";
                snippet += method.args[i].name;
              }
              snippet += ");\n";
            }
          }
        }
      }
      snippet += indent + "}\n";
      snippet += suffix;
      action.edit = {};
      action.edit.changes = {};
      action.edit.changes[asmodule.displayUri] = [
        vscode_languageserver_types_1.TextEdit.insert(insertPosition, snippet)
      ];
    }
    function GetTypeFromExpressionIgnoreNullptr(scope, node) {
      if (node && node.type == scriptfiles2.node_types.ConstNullptr)
        return null;
      return scriptfiles2.ResolveTypeFromExpression(scope, node);
    }
    function AddCastHelpers(context) {
      if (!context.scope)
        return;
      if (!context.statement)
        return;
      if (!context.statement.ast)
        return;
      let statement = context.statement;
      let scope = context.scope;
      let leftType = null;
      let rightType = null;
      let codeNode = statement.ast;
      switch (codeNode.type) {
        case scriptfiles2.node_types.IfStatement:
        case scriptfiles2.node_types.ElseStatement:
        case scriptfiles2.node_types.ForLoop:
        case scriptfiles2.node_types.ForEachLoop:
        case scriptfiles2.node_types.WhileLoop:
        case scriptfiles2.node_types.CaseStatement:
        case scriptfiles2.node_types.DefaultCaseStatement:
          if (codeNode.children[codeNode.children.length - 1])
            codeNode = codeNode.children[codeNode.children.length - 1];
          break;
      }
      if (codeNode.type == scriptfiles2.node_types.Assignment) {
        let leftNode = codeNode.children[0];
        let rightNode = codeNode.children[1];
        if (!leftNode || !rightNode)
          return;
        leftType = scriptfiles2.ResolveTypeFromExpression(scope, leftNode);
        rightType = GetTypeFromExpressionIgnoreNullptr(scope, rightNode);
      } else if (codeNode.type == scriptfiles2.node_types.VariableDecl) {
        if (codeNode.typename)
          leftType = typedb2.LookupType(context.scope.getNamespace(), codeNode.typename.value);
        if (codeNode.expression)
          rightType = GetTypeFromExpressionIgnoreNullptr(scope, codeNode.expression);
      } else if (codeNode.type == scriptfiles2.node_types.ReturnStatement) {
        let dbFunc = scope.getDatabaseFunction();
        if (dbFunc && dbFunc.returnType)
          leftType = typedb2.LookupType(context.scope.getNamespace(), dbFunc.returnType);
        if (codeNode.children && codeNode.children[0])
          rightType = GetTypeFromExpressionIgnoreNullptr(scope, codeNode.children[0]);
      }
      if (!leftType || !rightType)
        return;
      if (leftType.isPrimitive || rightType.isPrimitive)
        return;
      if (leftType.isStruct || rightType.isStruct)
        return;
      if (rightType.inheritsFrom(leftType.name))
        return;
      if (!leftType.inheritsFrom(rightType.name))
        return;
      context.actions.push({
        kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
        title: "Cast to " + leftType.name,
        source: "angelscript",
        data: {
          uri: context.module.uri,
          type: "addCast",
          castTo: leftType.name,
          position: context.module.getPosition(context.range_start)
        }
      });
    }
    function ResolveCastHelper(asmodule, action, data) {
      let offset = asmodule.getOffset(data.position);
      let scope = asmodule.getScopeAt(offset);
      if (!scope)
        return;
      let statement = asmodule.getStatementAt(offset);
      if (!statement)
        return;
      if (!statement.ast)
        return;
      let codeNode = statement.ast;
      switch (codeNode.type) {
        case scriptfiles2.node_types.IfStatement:
        case scriptfiles2.node_types.ElseStatement:
        case scriptfiles2.node_types.ForLoop:
        case scriptfiles2.node_types.ForEachLoop:
        case scriptfiles2.node_types.WhileLoop:
        case scriptfiles2.node_types.CaseStatement:
        case scriptfiles2.node_types.DefaultCaseStatement:
          if (codeNode.children[codeNode.children.length - 1])
            codeNode = codeNode.children[codeNode.children.length - 1];
          break;
      }
      let rightNode = null;
      if (codeNode.type == scriptfiles2.node_types.Assignment) {
        rightNode = codeNode.children[1];
      } else if (codeNode.type == scriptfiles2.node_types.VariableDecl) {
        rightNode = codeNode.expression;
      } else if (codeNode.type == scriptfiles2.node_types.ReturnStatement) {
        if (codeNode.children && codeNode.children[0])
          rightNode = codeNode.children[0];
      }
      if (!rightNode)
        return;
      action.edit = {};
      action.edit.changes = {};
      action.edit.changes[asmodule.displayUri] = [
        vscode_languageserver_types_1.TextEdit.insert(asmodule.getPosition(statement.start_offset + rightNode.start), "Cast<" + data.castTo + ">("),
        vscode_languageserver_types_1.TextEdit.insert(asmodule.getPosition(statement.start_offset + rightNode.end), ")")
      ];
    }
    function AddSuperCallHelper(context) {
      for (let diag of context.diagnostics) {
        let data = diag.data;
        if (data && data.type == "superCall") {
          context.actions.push({
            kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
            title: "Add call to Super::" + data.name + "(...)",
            source: "angelscript",
            diagnostics: [diag],
            isPreferred: true,
            data: {
              uri: context.module.uri,
              type: "superCall",
              name: data.name,
              inType: data.inType,
              position: context.module.getPosition(context.range_end)
            }
          });
        }
      }
    }
    function ResolveSuperCallHelper(asmodule, action, data) {
      let offset = asmodule.getOffset(data.position);
      let scope = asmodule.getScopeAt(offset);
      if (!scope)
        return;
      let scopeFunc = scope.getParentFunction();
      if (!scopeFunc)
        return;
      let superType = typedb2.LookupType(scope.getNamespace(), data.inType);
      if (!superType)
        return;
      let superMethod = superType.findFirstSymbol(data.name, typedb2.DBAllowSymbol.Functions);
      if (!superMethod)
        return;
      if (!(superMethod instanceof typedb2.DBMethod))
        return;
      let [insertPosition, indent, prefix, suffix] = FindInsertPositionFunctionStart(scope);
      let callString = prefix + indent;
      if (scopeFunc.returnType && scopeFunc.returnType != "void")
        callString += "return ";
      callString += "Super::" + superMethod.name + "(";
      if (scopeFunc.args) {
        for (let i = 0; i < scopeFunc.args.length; ++i) {
          if (i != 0)
            callString += ", ";
          callString += scopeFunc.args[i].name;
        }
      }
      callString += ");" + suffix;
      action.edit = {};
      action.edit.changes = {};
      action.edit.changes[asmodule.displayUri] = [
        vscode_languageserver_types_1.TextEdit.insert(insertPosition, callString)
      ];
    }
    function FindInsertPositionFunctionStart(scope) {
      let indent = null;
      let prefix = "";
      let suffix = "";
      let endLine = scope.module.getPosition(scope.end_offset).line;
      let curLine = scope.module.getPosition(scope.declaration.end_offset).line + 1;
      while (curLine < endLine) {
        let lineText = scope.module.getLineText(curLine);
        if (!/^[\r\n]*$/.test(lineText)) {
          indent = "";
          for (let i = 0; i < lineText.length; ++i) {
            let curchar = lineText[i];
            if (curchar == " " || curchar == "	") {
              indent += curchar;
            } else if (curchar == "\n" || curchar == "\r") {
              continue;
            } else if (curchar == "#") {
              indent = null;
              break;
            } else {
              break;
            }
          }
          if (indent != null)
            break;
        }
        curLine += 1;
      }
      if (indent == null) {
        let [subPos, subIndent, subPrefix, subSuffix] = FindInsertPositionForGeneratedMethod(scope.module, scope.module.getPosition(scope.declaration.end_offset));
        indent = subIndent + subIndent;
      }
      if (indent == null)
        indent = "		";
      let headPos = scope.module.getPosition(scope.declaration.end_offset);
      prefix += "\n";
      return [vscode_languageserver_types_1.Position.create(headPos.line, 1e5), indent, prefix, suffix];
    }
    function AddAutoActions(context) {
      if (!context.scope)
        return;
      for (let i = context.first_symbol; i < context.last_symbol; ++i) {
        let symbol = context.module.semanticSymbols[i];
        if (!symbol.isAuto)
          continue;
        let dbtype = typedb2.GetTypeByName(symbol.symbol_name);
        if (!dbtype)
          continue;
        if (dbtype.isTemplateInstantiation && (dbtype.name.startsWith("TMapIterator<") || dbtype.name.startsWith("TMapConstIterator<")))
          continue;
        let realTypename = dbtype.getQualifiedTypenameInNamespace(context.scope.getNamespace());
        context.actions.push({
          kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
          title: "Change auto to " + dbtype.getDisplayName(),
          source: "angelscript",
          data: {
            uri: context.module.uri,
            type: "materializeAuto",
            typename: realTypename,
            symbol: {
              "type": symbol.type,
              "container_type": symbol.container_type,
              "symbol_name": symbol.symbol_name,
              "start": symbol.start,
              "end": symbol.end,
              "isWriteAccess": symbol.isWriteAccess,
              "isUnimported": symbol.isUnimported,
              "isAuto": symbol.isAuto,
              "noColor": symbol.noColor
            }
          }
        });
      }
    }
    function ResolveAutoAction(asmodule, action, data) {
      let symbol = data.symbol;
      let typename = data.typename;
      action.edit = {};
      action.edit.changes = {};
      action.edit.changes[asmodule.displayUri] = [
        vscode_languageserver_types_1.TextEdit.replace(asmodule.getRange(symbol.start, symbol.end), typename)
      ];
    }
    function AddVariablePromotionHelper(context) {
      if (!context.scope)
        return;
      if (!context.statement)
        return;
      let codeNode = context.statement.ast;
      if (!codeNode)
        return;
      let innerStatement = null;
      switch (codeNode.type) {
        case scriptfiles2.node_types.Assignment:
          innerStatement = codeNode;
          break;
        case scriptfiles2.node_types.IfStatement:
        case scriptfiles2.node_types.ElseStatement:
        case scriptfiles2.node_types.ForLoop:
        case scriptfiles2.node_types.ForEachLoop:
        case scriptfiles2.node_types.WhileLoop:
        case scriptfiles2.node_types.CaseStatement:
        case scriptfiles2.node_types.DefaultCaseStatement:
          if (codeNode.children[codeNode.children.length - 1])
            innerStatement = codeNode.children[codeNode.children.length - 1];
          break;
      }
      if (innerStatement && innerStatement.type == scriptfiles2.node_types.Assignment) {
        let leftNode = innerStatement.children[0];
        if (!leftNode || leftNode.type != scriptfiles2.node_types.Identifier)
          return;
        let lvalueType = scriptfiles2.ResolveTypeFromExpression(context.scope, leftNode);
        if (lvalueType)
          return;
        let rvalueType = scriptfiles2.ResolveTypeFromExpression(context.scope, innerStatement.children[1]);
        if (!rvalueType)
          return;
        let variableName = leftNode.value;
        context.actions.push({
          kind: vscode_languageserver_types_1.CodeActionKind.RefactorRewrite,
          title: `Promote ${variableName} to member variable`,
          source: "angelscript",
          data: {
            uri: context.module.uri,
            type: "variablePromotion",
            variableName,
            variableType: rvalueType.name,
            position: context.range_start
          }
        });
      }
    }
    function AddConditionVariablePromotionHelper(context) {
      if (!context.scope)
        return;
      if (!context.statement)
        return;
      let codeNode = context.statement.ast;
      if (!codeNode)
        return;
      if (codeNode.type == scriptfiles2.node_types.IfStatement || codeNode.type == scriptfiles2.node_types.WhileLoop) {
        let conditionNode = codeNode.children[0];
        let identifierNode = null;
        if (conditionNode && conditionNode.type == scriptfiles2.node_types.Identifier) {
          identifierNode = conditionNode;
        } else if (conditionNode && conditionNode.type == scriptfiles2.node_types.UnaryOperation) {
          let operandNode = conditionNode.children[0];
          if (operandNode && operandNode.type == scriptfiles2.node_types.Identifier)
            identifierNode = operandNode;
        }
        if (identifierNode) {
          let lvalueType = scriptfiles2.ResolveTypeFromExpression(context.scope, identifierNode);
          if (lvalueType)
            return;
          let isTypingIdentifier = context.scope.module.isEditingInside(context.statement.start_offset + identifierNode.start, context.statement.start_offset + identifierNode.end);
          if (isTypingIdentifier)
            return;
          let variableName = identifierNode.value;
          context.actions.push({
            kind: vscode_languageserver_types_1.CodeActionKind.RefactorRewrite,
            title: `Promote ${variableName} to boolean member variable`,
            source: "angelscript",
            data: {
              uri: context.module.uri,
              type: "variablePromotion",
              variableName,
              variableType: "bool",
              position: context.range_start
            }
          });
        }
      }
    }
    function FindInsertPositionForGeneratedMemberVariable(asmodule, classScope, anchor_offset = -1) {
      let indent = null;
      let prefix = "";
      let suffix = "";
      for (let statement of classScope.statements) {
        let lines = statement.content.split("\n");
        for (let line of lines) {
          if (!/^[ \t\r\n]*$/.test(line)) {
            indent = "";
            for (let i = 0; i < line.length; ++i) {
              let curchar = line[i];
              if (curchar == " " || curchar == "	") {
                indent += curchar;
              } else if (curchar == "\n" || curchar == "\r") {
                continue;
              } else if (curchar == "#") {
                indent = null;
                break;
              } else {
                break;
              }
            }
            break;
          }
        }
        if (indent)
          break;
      }
      if (!indent)
        indent = "	";
      let anchoredVariable = null;
      if (anchor_offset != -1) {
        let subScope = classScope.getScopeAt(anchor_offset);
        if (subScope) {
          for (let statement of subScope.statements) {
            if (!statement)
              continue;
            if (!statement.ast)
              continue;
            if (statement.end_offset >= anchor_offset)
              continue;
            if (statement.ast.type == scriptfiles2.node_types.Assignment) {
              if (statement.ast.children[0] && statement.ast.children[0].type == scriptfiles2.node_types.Identifier) {
                let varName = statement.ast.children[0].value;
                if (classScope.variablesByName.has(varName))
                  anchoredVariable = varName;
              }
            }
          }
        }
      }
      let lastDefaultLineOffset = -1;
      let lastMemberVariableOffset = -1;
      let anchoredMemberVariableOffset = -1;
      for (let statement of classScope.statements) {
        if (!statement.ast)
          continue;
        if (statement.ast.type == scriptfiles2.node_types.VariableDecl) {
          if (anchoredVariable && statement.ast.name && statement.ast.name.value == anchoredVariable)
            anchoredMemberVariableOffset = statement.end_offset;
          if (statement.end_offset > lastMemberVariableOffset)
            lastMemberVariableOffset = statement.end_offset;
        } else if (statement.ast.type == scriptfiles2.node_types.DefaultStatement) {
          if (statement.end_offset > lastDefaultLineOffset)
            lastDefaultLineOffset = statement.end_offset;
        }
      }
      let afterPos = null;
      if (anchoredMemberVariableOffset != -1) {
        afterPos = asmodule.getPosition(anchoredMemberVariableOffset);
      } else if (lastMemberVariableOffset != -1) {
        afterPos = asmodule.getPosition(lastMemberVariableOffset);
      } else if (lastDefaultLineOffset != -1) {
        afterPos = asmodule.getPosition(lastDefaultLineOffset);
      } else {
        afterPos = asmodule.getPosition(classScope.declaration.end_offset);
      }
      afterPos.line += 1;
      afterPos.character = 0;
      return [afterPos, indent];
    }
    function ResolveVariablePromotionHelper(asmodule, action, data) {
      let variableName = data.variableName;
      let variableType = data.variableType;
      let position = data.position;
      let scope = asmodule.getScopeAt(position);
      if (!scope)
        return;
      let classScope = scope.getParentTypeScope();
      if (!classScope)
        return;
      let [insertPosition, indent] = FindInsertPositionForGeneratedMemberVariable(asmodule, classScope, position);
      action.edit = {};
      action.edit.changes = {};
      let declarationString = `${indent}${variableType} ${variableName};
`;
      action.edit.changes[asmodule.displayUri] = [
        vscode_languageserver_types_1.TextEdit.insert(insertPosition, declarationString)
      ];
    }
    function AddMacroActions(context) {
      if (!context.scope)
        return;
      if (!context.statement)
        return;
      if (!context.statement.ast)
        return;
      let dbType = context.scope.getParentType();
      if (context.statement.ast.type == scriptfiles2.node_types.FunctionDecl && context.statement.ast.name && !context.statement.ast.macro) {
        if (!dbType || !dbType.isStruct) {
          let isOverrideEvent = false;
          if (dbType) {
            let superType = dbType.getSuperType();
            if (superType) {
              let superFunc = superType.findFirstSymbol(context.statement.ast.name.value, typedb2.DBAllowSymbol.Functions);
              if (superFunc && superFunc instanceof typedb2.DBMethod) {
                if (superFunc.isBlueprintEvent)
                  isOverrideEvent = true;
              }
            }
          }
          if (isOverrideEvent) {
            context.actions.push({
              kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
              title: `Add UFUNCTION(BlueprintOverride)`,
              source: "angelscript",
              data: {
                uri: context.module.uri,
                type: "insertMacro",
                macro: "UFUNCTION(BlueprintOverride)",
                position: context.range_start
              }
            });
          } else {
            if (dbType) {
              let scopeFunc = dbType.getMethod(context.statement.ast.name.value);
              if (scopeFunc && scopeFunc.isConst && scopeFunc.returnType && scopeFunc.returnType != "void") {
                context.actions.push({
                  kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
                  title: `Add UFUNCTION(BlueprintPure)`,
                  source: "angelscript",
                  data: {
                    uri: context.module.uri,
                    type: "insertMacro",
                    macro: "UFUNCTION(BlueprintPure)",
                    position: context.range_start
                  }
                });
              }
            }
            context.actions.push({
              kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
              title: `Add UFUNCTION()`,
              source: "angelscript",
              data: {
                uri: context.module.uri,
                type: "insertMacro",
                macro: "UFUNCTION()",
                position: context.range_start
              }
            });
          }
        }
      } else if (context.statement.ast.type == scriptfiles2.node_types.VariableDecl && context.statement.ast.name && !context.statement.ast.macro) {
        if (dbType && context.scope.scopetype == scriptfiles2.ASScopeType.Class) {
          let variableName = context.statement.ast.name.value;
          let varType = typedb2.LookupType(context.scope.getNamespace(), context.statement.ast.typename.value);
          let isActorComponent = varType && varType.inheritsFrom("UActorComponent");
          let isInsideWidget = dbType && dbType.inheritsFrom("UWidget");
          let isWidget = varType && varType.inheritsFrom("UWidget");
          let isWidgetAnim = varType && varType.inheritsFrom("UWidgetAnimation");
          if (!dbType.isStruct && isActorComponent && dbType.inheritsFrom("AActor")) {
            context.actions.push({
              kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
              title: `Add UPROPERTY(DefaultComponent)`,
              source: "angelscript",
              data: {
                uri: context.module.uri,
                type: "insertMacro",
                macro: "UPROPERTY(DefaultComponent)",
                position: context.range_start
              }
            });
          }
          if (isInsideWidget) {
            if (isWidget) {
              context.actions.push({
                kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
                title: `Add UPROPERTY(BindWidget)`,
                source: "angelscript",
                data: {
                  uri: context.module.uri,
                  type: "insertMacro",
                  macro: "UPROPERTY(BindWidget)",
                  position: context.range_start
                }
              });
            }
            if (isWidgetAnim) {
              context.actions.push({
                kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
                title: `Add UPROPERTY(BindWidgetAnim)`,
                source: "angelscript",
                data: {
                  uri: context.module.uri,
                  type: "insertMacro",
                  macro: "UPROPERTY(BindWidgetAnim)",
                  position: context.range_start
                }
              });
            }
          }
          context.actions.push({
            kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
            title: `Add UPROPERTY()`,
            source: "angelscript",
            data: {
              uri: context.module.uri,
              type: "insertMacro",
              macro: "UPROPERTY()",
              position: context.range_start
            }
          });
          if (!isActorComponent && !isWidget && !isWidgetAnim) {
            context.actions.push({
              kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
              title: `Add UPROPERTY(EditAnywhere)`,
              source: "angelscript",
              data: {
                uri: context.module.uri,
                type: "insertMacro",
                macro: "UPROPERTY(EditAnywhere)",
                position: context.range_start
              }
            });
          }
        }
      } else if (context.statement.ast.type == scriptfiles2.node_types.ClassDefinition && context.statement.ast.name && !context.statement.ast.macro) {
        context.actions.push({
          kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
          title: `Add UCLASS()`,
          source: "angelscript",
          data: {
            uri: context.module.uri,
            type: "insertMacro",
            macro: "UCLASS()",
            position: context.statement.start_offset + context.statement.ast.name.start
          }
        });
        context.actions.push({
          kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
          title: `Add UCLASS(Abstract)`,
          source: "angelscript",
          data: {
            uri: context.module.uri,
            type: "insertMacro",
            macro: "UCLASS(Abstract)",
            position: context.statement.start_offset + context.statement.ast.name.start
          }
        });
      } else if (context.statement.ast.type == scriptfiles2.node_types.StructDefinition && context.statement.ast.name && !context.statement.ast.macro) {
        context.actions.push({
          kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
          title: `Add USTRUCT()`,
          source: "angelscript",
          data: {
            uri: context.module.uri,
            type: "insertMacro",
            macro: "USTRUCT()",
            position: context.statement.start_offset + context.statement.ast.name.start
          }
        });
      } else if (context.statement.ast.type == scriptfiles2.node_types.EnumDefinition && context.statement.ast.name && !context.statement.ast.macro) {
        context.actions.push({
          kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
          title: `Add UENUM()`,
          source: "angelscript",
          data: {
            uri: context.module.uri,
            type: "insertMacro",
            macro: "UENUM()",
            position: context.statement.start_offset + context.statement.ast.name.start
          }
        });
      }
    }
    function GetIndentFromLineAtOffset(asmodule, position) {
      let indent = "";
      let textpos = asmodule.getPosition(position);
      let line = asmodule.getLineText(textpos.line);
      for (let i = 0; i < line.length; ++i) {
        let chr = line[i];
        if (chr == "	" || chr == " ")
          indent += chr;
        else
          return indent;
      }
      return indent;
    }
    function ResolveInsertMacro(asmodule, action, data) {
      let position = data.position;
      let macro = data.macro;
      let statement = asmodule.getStatementAt(position);
      if (!statement)
        return;
      if (!statement.ast)
        return;
      let scope = asmodule.getScopeAt(position);
      if (!scope)
        return;
      let indent = GetIndentFromLineAtOffset(asmodule, position);
      action.edit = {};
      action.edit.changes = {};
      let macroString = `${indent}${macro}
`;
      let insertPosition = null;
      if (statement.ast.name) {
        insertPosition = asmodule.getPosition(statement.start_offset + statement.ast.name.start);
        insertPosition.character = 0;
      } else {
        insertPosition = asmodule.getPosition(position);
        insertPosition.character = 0;
      }
      action.edit.changes[asmodule.displayUri] = [
        vscode_languageserver_types_1.TextEdit.insert(insertPosition, macroString)
      ];
    }
    function AddSwitchCaseActions(context) {
      if (!context.scope)
        return;
      let switchBlock = null;
      let switchStatement = null;
      if (context.statement && context.statement.ast && context.statement.ast.type == scriptfiles2.node_types.SwitchStatement) {
        if (context.statement.next && context.statement.next instanceof scriptfiles2.ASScope) {
          switchStatement = context.statement;
          switchBlock = context.statement.next;
        }
      } else if (context.scope.previous && context.scope.previous instanceof scriptfiles2.ASStatement) {
        if (context.scope.previous.ast && context.scope.previous.ast.type == scriptfiles2.node_types.SwitchStatement) {
          switchStatement = context.scope.previous;
          switchBlock = context.scope;
        }
      }
      if (!switchBlock)
        return;
      if (!switchBlock.parentscope)
        return;
      let switchOnType = scriptfiles2.ResolveTypeFromExpression(switchBlock.parentscope, switchStatement.ast.children[0]);
      if (!switchOnType)
        return;
      if (!switchOnType.isEnum)
        return;
      let implementedCases = new Array();
      let defaultStatement = null;
      for (let caseStatement of switchBlock.statements) {
        if (!caseStatement || !caseStatement.ast)
          continue;
        if (caseStatement.ast.type == scriptfiles2.node_types.DefaultCaseStatement) {
          defaultStatement = caseStatement;
          continue;
        } else if (caseStatement.ast.type != scriptfiles2.node_types.CaseStatement)
          continue;
        for (let caseNode = caseStatement.ast; caseNode && (caseNode.type == scriptfiles2.node_types.CaseStatement || caseNode.type == scriptfiles2.node_types.DefaultCaseStatement); caseNode = caseNode.children[1]) {
          let labelNode = caseNode.children[0];
          if (!labelNode || labelNode.type != scriptfiles2.node_types.NamespaceAccess)
            continue;
          if (!labelNode.children[0] || !labelNode.children[0].value)
            continue;
          if (!labelNode.children[1] || !labelNode.children[1].value)
            continue;
          let label = labelNode.children[0].value + "::" + labelNode.children[1].value;
          implementedCases.push(label);
        }
      }
      let missingCases = new Array();
      switchOnType.forEachSymbol(function(sym) {
        if (!(sym instanceof typedb2.DBProperty))
          return;
        let prop = sym;
        if (prop.name == "MAX")
          return;
        if (prop.name.endsWith("_MAX"))
          return;
        let label = switchOnType.getQualifiedTypenameInNamespace(context.scope.getNamespace()) + "::" + prop.name;
        if (!implementedCases.includes(label))
          missingCases.push(label);
      });
      if (missingCases.length >= 2) {
        context.actions.push({
          kind: vscode_languageserver_types_1.CodeActionKind.RefactorRewrite,
          title: `Add all missing ${switchOnType.getDisplayName()} cases`,
          source: "angelscript",
          data: {
            uri: context.module.uri,
            type: "insertCases",
            cases: missingCases,
            switchPosition: switchStatement.start_offset,
            position: context.scope.start_offset,
            defaultCasePosition: defaultStatement ? defaultStatement.start_offset : -1
          }
        });
      }
      for (let label of missingCases) {
        context.actions.push({
          kind: vscode_languageserver_types_1.CodeActionKind.RefactorRewrite,
          title: `Add case ${label}`,
          source: "angelscript",
          data: {
            uri: context.module.uri,
            type: "insertCases",
            cases: [label],
            switchPosition: switchStatement.start_offset,
            position: context.scope.start_offset,
            defaultCasePosition: defaultStatement ? defaultStatement.start_offset : -1
          }
        });
      }
    }
    function ResolveInsertCases(asmodule, action, data) {
      let switchStatement = asmodule.getStatementAt(data.switchPosition);
      if (!switchStatement)
        return;
      if (!switchStatement.next)
        return;
      if (!(switchStatement.next instanceof scriptfiles2.ASScope))
        return;
      let switchScope = switchStatement.next;
      if (!switchScope)
        return;
      action.edit = {};
      action.edit.changes = {};
      let switchIndent = GetIndentForStatement(switchStatement);
      let indent = GetIndentForBlock(switchScope);
      if (!indent)
        indent = "";
      let insertString = "";
      let cases = data.cases;
      for (let label of cases)
        insertString += `${indent}case ${label}:
${indent}break;
`;
      let insertPosition = null;
      if (data.defaultCasePosition != -1) {
        insertPosition = asmodule.getPosition(data.defaultCasePosition);
        insertString = "\n" + insertString.substring(0, insertString.length - 1);
      } else {
        let lastElement = switchScope.element_head;
        while (lastElement && lastElement.next)
          lastElement = lastElement.next;
        while (lastElement) {
          if (lastElement instanceof scriptfiles2.ASScope) {
            insertPosition = asmodule.getPosition(lastElement.end_offset);
            insertPosition.line += 1;
            insertPosition.character = 0;
            break;
          } else if (lastElement instanceof scriptfiles2.ASStatement) {
            if (lastElement && lastElement.ast) {
              insertPosition = asmodule.getPosition(lastElement.end_offset);
              insertPosition.line += 1;
              insertPosition.character = 0;
              break;
            }
          }
          lastElement = lastElement.previous;
        }
        if (!insertPosition) {
          let scopeStart = asmodule.getPosition(switchScope.start_offset);
          let scopeEnd = asmodule.getPosition(switchScope.end_offset);
          if (scopeEnd.line == scopeStart.line) {
            insertPosition = asmodule.getPosition(switchScope.start_offset);
            insertString = "\n" + insertString + switchIndent;
          } else if (scopeEnd.line == scopeStart.line + 1) {
            insertPosition = asmodule.getPosition(switchScope.start_offset);
            insertString = "\n" + insertString.trimEnd();
          } else {
            insertPosition = asmodule.getPosition(switchScope.end_offset);
            insertPosition.line -= 1;
            insertPosition.character = 1e4;
            insertString = insertString.substring(0, insertString.length - 1).trimStart();
          }
        }
      }
      action.edit.changes[asmodule.displayUri] = [
        vscode_languageserver_types_1.TextEdit.insert(insertPosition, insertString)
      ];
    }
    function GetIndentForStatement(statement) {
      let indent = null;
      let lines = statement.content.split("\n");
      for (let line of lines) {
        if (!/^[ \t\r\n]*$/.test(line)) {
          indent = "";
          for (let i = 0; i < line.length; ++i) {
            let curchar = line[i];
            if (curchar == " " || curchar == "	") {
              indent += curchar;
            } else if (curchar == "\n" || curchar == "\r") {
              continue;
            } else if (curchar == "#") {
              indent = null;
              break;
            } else {
              break;
            }
          }
          break;
        }
      }
      return indent;
    }
    exports2.GetIndentForStatement = GetIndentForStatement;
    function GetIndentForBlock(scope) {
      if (scope.statements.length != 0 && scope.statements[0]) {
        for (let statement of scope.statements) {
          if (!statement)
            continue;
          let statementIndent = GetIndentForStatement(statement);
          if (statementIndent != null)
            return statementIndent;
        }
      } else {
        if (scope.previous && scope.previous instanceof scriptfiles2.ASStatement) {
          let statementIndent = GetIndentForStatement(scope.previous);
          if (statementIndent != null) {
            return ExtendIndent(statementIndent);
          }
        }
      }
      return null;
    }
    exports2.GetIndentForBlock = GetIndentForBlock;
    function ExtendIndent(indent) {
      if (!indent || indent.length == 0)
        return "	";
      if (indent.includes("	"))
        return indent + "	";
      else
        return indent + "    ";
    }
    exports2.ExtendIndent = ExtendIndent;
    function AddGenerateMethodActions(context) {
      if (!context.statement || !context.scope)
        return;
      let dbtype = context.scope.getParentType();
      if (!dbtype || dbtype.isEnum)
        return;
      let functionCallNodes = [];
      FindMemberFunctionCallNodes(context.statement.ast, context.statement, functionCallNodes);
      let isInConstMethod = false;
      let scopeFunction = context.scope.getParentFunction();
      if (scopeFunction)
        isInConstMethod = scopeFunction.isConst;
      for (let callNode of functionCallNodes) {
        if (!callNode || !callNode.children)
          continue;
        let functionName = callNode.children[0].value;
        if (dbtype.findFirstSymbol(functionName, typedb2.DBAllowSymbol.Functions))
          continue;
        if (typedb2.LookupType(context.scope.getNamespace(), functionName))
          continue;
        let globalSyms = typedb2.LookupGlobalSymbol(context.scope.getNamespace(), functionName, typedb2.DBAllowSymbol.Functions);
        if (globalSyms && globalSyms.length != 0)
          continue;
        let args = "";
        let usedArgNames = [];
        if (callNode.children[1] && callNode.children[1].children) {
          for (let argNode of callNode.children[1].children) {
            if (args.length != 0)
              args += ", ";
            let argTypename = "int";
            let argType = scriptfiles2.ResolveTypeFromExpression(context.scope, argNode);
            if (argType)
              argTypename = argType.getDisplayName();
            if (argTypename == "float32")
              argTypename = "float";
            args += argTypename;
            args += " ";
            let argName = FindUsableIdentifierInExpression(argNode);
            if (argName) {
              if (argName.length >= 4 && argName.startsWith("Get") && argName[3].toUpperCase() == argName[3])
                argName = argName.substring(3);
              if (argTypename == "bool") {
                if (argName.length >= 4 && argName.startsWith("Has") && argName[3].toUpperCase() == argName[3])
                  argName = "b" + argName.substring(3);
                else if (argName.length >= 7 && argName.startsWith("Should") && argName[6].toUpperCase() == argName[6])
                  argName = "b" + argName.substring(6);
                else if (argName.length >= 3 && argName.startsWith("Is") && argName[2].toUpperCase() == argName[2])
                  argName = "b" + argName.substring(2);
                else if (argName.length >= 1 && argName[0] != "b")
                  argName = "b" + argName;
              }
            }
            if (!argName || argName.length == 0) {
              if (argType) {
                if (argType.isPrimitive)
                  argName = argType.name[0].toUpperCase() + argType.name.substring(1);
                else
                  argName = argType.name.substring(1);
              } else {
                argName = "Param";
              }
            }
            let index = 1;
            let baseArgName = argName;
            while (usedArgNames.indexOf(argName) != -1) {
              index += 1;
              argName = baseArgName + index;
            }
            usedArgNames.push(argName);
            args += argName;
          }
        }
        let callOffset = context.statement.start_offset + callNode.children[0].start;
        let callPosition = context.module.getPosition(callOffset);
        let returnType = "void";
        let expectedType = completion.GetExpectedTypeAtOffset(context.module, callOffset);
        if (expectedType)
          returnType = expectedType.getDisplayName();
        if (returnType == "float32")
          returnType = "float";
        if (!isInConstMethod) {
          context.actions.push({
            kind: vscode_languageserver_types_1.CodeActionKind.RefactorExtract,
            title: `Generate method: ${returnType} ${functionName}(${args})`,
            source: "angelscript",
            data: {
              uri: context.module.uri,
              type: "methodFromUsage",
              name: functionName,
              returnType,
              args,
              const: false,
              position: callPosition
            }
          });
        }
        if (expectedType || isInConstMethod) {
          context.actions.push({
            kind: vscode_languageserver_types_1.CodeActionKind.RefactorExtract,
            title: `Generate method: ${returnType} ${functionName}(${args}) const`,
            source: "angelscript",
            data: {
              uri: context.module.uri,
              type: "methodFromUsage",
              name: functionName,
              returnType,
              args,
              const: true,
              position: callPosition
            }
          });
        }
      }
    }
    function FindMemberFunctionCallNodes(node, statement, callNodes) {
      if (!node)
        return;
      if (node.type == scriptfiles2.node_types.FunctionCall) {
        if (node.children && node.children[0] && node.children[0].type == scriptfiles2.node_types.Identifier) {
          callNodes.push(node);
        }
      }
      if (node.children) {
        for (let child of node.children)
          FindMemberFunctionCallNodes(child, statement, callNodes);
      }
      if ("expression" in node) {
        FindMemberFunctionCallNodes(node.expression, statement, callNodes);
      }
    }
    function FindUsableIdentifierInExpression(node) {
      if (!node)
        return null;
      if (node.type == scriptfiles2.node_types.Identifier) {
        return node.value;
      } else if (node.type == scriptfiles2.node_types.FunctionCall) {
        return FindUsableIdentifierInExpression(node.children[0]);
      } else if (node.children) {
        for (let i = node.children.length - 1; i >= 0; --i) {
          let child = node.children[i];
          let nodeIdentifier = FindUsableIdentifierInExpression(child);
          if (nodeIdentifier)
            return nodeIdentifier;
        }
      }
      return null;
    }
    function ResolveGenerateMethod(asmodule, action, data) {
      let [insertPosition, indent, prefix, suffix] = FindInsertPositionForGeneratedMethod(asmodule, data.position);
      let snippet = prefix;
      snippet += `${indent}${data.returnType} ${data.name}(${data.args})`;
      if (data.const)
        snippet += " const";
      snippet += "\n";
      snippet += indent + "{\n";
      snippet += indent + "}\n";
      snippet += suffix;
      action.edit = {};
      action.edit.changes = {};
      action.edit.changes[asmodule.displayUri] = [
        vscode_languageserver_types_1.TextEdit.insert(insertPosition, snippet)
      ];
    }
    function AddGenerateParamsStructActions(context) {
      if (!context.statement || !context.scope)
        return;
      let dbtype = context.scope.getParentType();
      if (!dbtype || !dbtype.inheritsFrom("UHazeCapability"))
        return;
      if (context.scope.scopetype != scriptfiles2.ASScopeType.Function)
        return;
      if (!context.statement.ast || context.statement.ast.type != scriptfiles2.node_types.FunctionDecl)
        return;
      let funcNode = context.statement.ast;
      if (funcNode.parameters && funcNode.parameters.length >= 1)
        return;
      if (funcNode.name.value == "ShouldActivate" || funcNode.name.value == "OnActivated") {
        context.actions.push({
          kind: vscode_languageserver_types_1.CodeActionKind.Refactor,
          title: "Create ActivationParameters for Capability",
          source: "angelscript",
          isPreferred: true,
          data: {
            uri: context.module.uri,
            type: "createActivationParameters",
            inClass: dbtype.name
          }
        });
      } else if (funcNode.name.value == "ShouldDeactivate" || funcNode.name.value == "OnDeactivated") {
        context.actions.push({
          kind: vscode_languageserver_types_1.CodeActionKind.Refactor,
          title: "Create DeactivationParameters for Capability",
          source: "angelscript",
          isPreferred: true,
          data: {
            uri: context.module.uri,
            type: "createDeactivationParameters",
            inClass: dbtype.name
          }
        });
      }
    }
    function GetInsertPositionBeforeScope(scope) {
      let offset = scope.start_offset;
      while (offset < scope.module.content.length) {
        let chr = scope.module.content[offset];
        if (chr != " " && chr != "	" && chr != "\r" && chr != "\n")
          break;
        offset += 1;
      }
      return scope.module.getPosition(offset);
    }
    function ResolveCreateActivationParameters(asmodule, action, data) {
      let className = data.inClass;
      let structName = className;
      if (structName.startsWith("U"))
        structName = structName.substring(1);
      if (structName.endsWith("Capability"))
        structName = structName.substring(0, structName.length - 10);
      structName = `F${structName}ActivationParams`;
      let structDecl = `struct ${structName}
{
}

`;
      let typeScope = asmodule.rootscope.findScopeForType(className);
      if (!typeScope)
        return;
      action.edit = {};
      action.edit.changes = {};
      action.edit.changes[asmodule.displayUri] = [
        vscode_languageserver_types_1.TextEdit.insert(GetInsertPositionBeforeScope(typeScope), structDecl)
      ];
      for (let statement of typeScope.statements) {
        if (!statement.ast)
          continue;
        if (statement.ast.type != scriptfiles2.node_types.FunctionDecl)
          continue;
        let funcNode = statement.ast;
        if (funcNode.name.value == "ShouldActivate") {
          action.edit.changes[asmodule.displayUri].push(vscode_languageserver_types_1.TextEdit.replace(asmodule.getRange(statement.start_offset, statement.end_offset), statement.content.replace("ShouldActivate(", `ShouldActivate(${structName}& ActivationParams`)));
        } else if (funcNode.name.value == "OnActivated") {
          action.edit.changes[asmodule.displayUri].push(vscode_languageserver_types_1.TextEdit.replace(asmodule.getRange(statement.start_offset, statement.end_offset), statement.content.replace("OnActivated(", `OnActivated(${structName} ActivationParams`)));
        }
      }
    }
    function ResolveCreateDeactivationParameters(asmodule, action, data) {
      let className = data.inClass;
      let structName = className;
      if (structName.startsWith("U"))
        structName = structName.substring(1);
      if (structName.endsWith("Capability"))
        structName = structName.substring(0, structName.length - 10);
      structName = `F${structName}DeactivationParams`;
      let structDecl = `struct ${structName}
{
}

`;
      let typeScope = asmodule.rootscope.findScopeForType(className);
      if (!typeScope)
        return;
      action.edit = {};
      action.edit.changes = {};
      action.edit.changes[asmodule.displayUri] = [
        vscode_languageserver_types_1.TextEdit.insert(GetInsertPositionBeforeScope(typeScope), structDecl)
      ];
      for (let statement of typeScope.statements) {
        if (!statement.ast)
          continue;
        if (statement.ast.type != scriptfiles2.node_types.FunctionDecl)
          continue;
        let funcNode = statement.ast;
        if (funcNode.name.value == "ShouldDeactivate") {
          action.edit.changes[asmodule.displayUri].push(vscode_languageserver_types_1.TextEdit.replace(asmodule.getRange(statement.start_offset, statement.end_offset), statement.content.replace("ShouldDeactivate(", `ShouldDeactivate(${structName}& DeactivationParams`)));
        } else if (funcNode.name.value == "OnDeactivated") {
          action.edit.changes[asmodule.displayUri].push(vscode_languageserver_types_1.TextEdit.replace(asmodule.getRange(statement.start_offset, statement.end_offset), statement.content.replace("OnDeactivated(", `OnDeactivated(${structName} DeactivationParams`)));
        }
      }
    }
  }
});

// unreal-angelscript-lsp/language-server/out/inlay_hints.js
var require_inlay_hints = __commonJS({
  "unreal-angelscript-lsp/language-server/out/inlay_hints.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GetInlayHintsForNode = exports2.GetInlayHintsForScope = exports2.GetInlayHintsForRange = exports2.GetInlayHintSettings = void 0;
    var scriptfiles2 = require_as_parser();
    var typedb2 = require_database();
    var as_parser_1 = require_as_parser();
    var vscode_languageserver_1 = require_main4();
    var InlayHintSettings = {
      inlayHintsEnabled: true,
      parameterHintsForConstants: true,
      parameterReferenceHints: true,
      parameterHintsForSingleParameterFunctions: false,
      parameterHintsForComplexExpressions: true,
      typeHintsForAutos: true,
      typeHintsIgnoredTypes: /* @__PURE__ */ new Set(),
      parameterHintsIgnoredParameterNames: /* @__PURE__ */ new Set(),
      parameterHintsIgnoredFunctionNames: /* @__PURE__ */ new Set()
    };
    var HintIgnoredMathFunctions = /* @__PURE__ */ new Set([
      "Math::Clamp",
      "Math::Wrap",
      "Math::IsWithin",
      "Math::Lerp",
      "Math::VLerp",
      "Math::LogX",
      "Math::Pow"
    ]);
    function GetInlayHintSettings() {
      return InlayHintSettings;
    }
    exports2.GetInlayHintSettings = GetInlayHintSettings;
    function GetInlayHintsForRange(asmodule, range) {
      if (!InlayHintSettings.inlayHintsEnabled)
        return [];
      let hints = new Array();
      let start_offset = asmodule.getOffset(range.start);
      let end_offset = asmodule.getOffset(range.end);
      GetInlayHintsForScope(asmodule.rootscope, start_offset, end_offset, hints);
      return hints;
    }
    exports2.GetInlayHintsForRange = GetInlayHintsForRange;
    function GetInlayHintsForScope(scope, start_offset, end_offset, hints) {
      for (let statement of scope.statements) {
        if (!statement)
          continue;
        if (statement.start_offset > end_offset)
          continue;
        if (statement.end_offset < start_offset)
          continue;
        GetInlayHintsForNode(scope, statement, statement.ast, hints);
      }
      if (InlayHintSettings.typeHintsForAutos) {
        for (let scopevar of scope.variables) {
          if (!scopevar.isAuto)
            continue;
          if (!scopevar.node_expression)
            continue;
          let cleanResultType = typedb2.CleanTypeName(scopevar.typename);
          if (cleanResultType == "auto")
            continue;
          if (InlayHintSettings.typeHintsIgnoredTypes.has(cleanResultType))
            continue;
          let showAutoHint = true;
          if (scope.module.isEditingInside(scopevar.end_offset_expression - 1, scopevar.end_offset_expression))
            showAutoHint = false;
          if (scopevar.node_expression.type == as_parser_1.node_types.CastOperation) {
            showAutoHint = false;
          }
          if (scopevar.node_expression.type == as_parser_1.node_types.NamespaceAccess) {
            let nsNode = scopevar.node_expression.children[0];
            if (nsNode && nsNode.type == as_parser_1.node_types.Identifier && nsNode.value == cleanResultType)
              showAutoHint = false;
          }
          if (scopevar.node_expression.type == as_parser_1.node_types.FunctionCall || scopevar.node_expression.type == as_parser_1.node_types.ConstructorCall) {
            let funcNode = scopevar.node_expression.children[0];
            if (funcNode && funcNode.type == as_parser_1.node_types.NamespaceAccess) {
              let nsNode = funcNode.children[0];
              if (nsNode && nsNode.type == as_parser_1.node_types.Identifier && nsNode.value == cleanResultType)
                showAutoHint = false;
            }
            if (funcNode && funcNode.type == as_parser_1.node_types.Identifier) {
              if (funcNode.value == cleanResultType)
                showAutoHint = false;
            }
            if (scopevar.node_expression.children[1] && scopevar.node_expression.children[1].type == as_parser_1.node_types.ArgumentList && scopevar.node_expression.children[1].children) {
              for (let child of scopevar.node_expression.children[1].children) {
                if (child && child.type == as_parser_1.node_types.Identifier) {
                  if (child.value == cleanResultType)
                    showAutoHint = false;
                }
              }
            }
          }
          if (showAutoHint) {
            let label = null;
            label = "[" + scopevar.typename + "]";
            let varType = typedb2.LookupType(scope.getNamespace(), scopevar.typename);
            if (varType && varType.declaredModule) {
              let varModule = scriptfiles2.GetModule(varType.declaredModule);
              if (varModule) {
                label = [
                  {
                    value: "["
                  },
                  {
                    value: scopevar.typename,
                    location: varModule.getLocation(varType.moduleOffset)
                  },
                  {
                    value: "]"
                  }
                ];
              }
            }
            if (varType && scopevar.isIterator && varType.isTemplateInstantiation && (varType.name.startsWith("TMapIterator<") || varType.name.startsWith("TMapConstIterator<")) && varType.templateSubTypes && varType.templateSubTypes.length == 2) {
              label = "[" + varType.templateSubTypes[0] + " \u279C " + varType.templateSubTypes[1] + "]";
            }
            hints.push({
              label,
              position: scope.module.getPosition(scopevar.start_offset_name - 1),
              kind: vscode_languageserver_1.InlayHintKind.Type,
              paddingLeft: true
            });
          }
        }
      }
      for (let subscope of scope.scopes) {
        if (subscope.start_offset > end_offset)
          continue;
        if (subscope.end_offset < start_offset)
          continue;
        GetInlayHintsForScope(subscope, start_offset, end_offset, hints);
      }
    }
    exports2.GetInlayHintsForScope = GetInlayHintsForScope;
    var GlobalConstantNames = /* @__PURE__ */ new Set([
      "MIN_uint8",
      "MIN_uint16",
      "MIN_uint32",
      "MIN_uint64",
      "MIN_int8",
      "MIN_int16",
      "MIN_int32",
      "MIN_int64",
      "MAX_uint8",
      "MAX_uint16",
      "MAX_uint32",
      "MAX_uint64",
      "MAX_int8",
      "MAX_int16",
      "MAX_int32",
      "MAX_int64",
      "MIN_flt",
      "MAX_flt",
      "NAN_flt",
      "MIN_dbl",
      "MAX_dbl",
      "NAN_dbl",
      "EULERS_NUMBER",
      "PI",
      "HALF_PI",
      "TWO_PI",
      "TAU",
      "SMALL_NUMBER",
      "KINDA_SMALL_NUMBER",
      "BIG_NUMBER",
      "NAME_None"
    ]);
    function ShouldLabelConstantNode(node, argName) {
      if (!node)
        return false;
      switch (node.type) {
        case as_parser_1.node_types.This:
        case as_parser_1.node_types.ConstBool:
        case as_parser_1.node_types.ConstDouble:
        case as_parser_1.node_types.ConstInteger:
        case as_parser_1.node_types.ConstHexInteger:
        case as_parser_1.node_types.ConstOctalInteger:
        case as_parser_1.node_types.ConstBinaryInteger:
        case as_parser_1.node_types.ConstFloat:
        case as_parser_1.node_types.ConstNullptr:
          return true;
        case as_parser_1.node_types.UnaryOperation:
          return ShouldLabelConstantNode(node.children[0], argName);
        case as_parser_1.node_types.ConstName:
          if (argName.endsWith("Name"))
            return false;
          return true;
        case as_parser_1.node_types.NamespaceAccess:
          {
            if (node.children[0] && node.children[0].type == as_parser_1.node_types.Identifier) {
              let nsType = typedb2.GetTypeByName(node.children[0].value);
              if (nsType && nsType.isStruct)
                return true;
            }
            return false;
          }
          break;
        case as_parser_1.node_types.Identifier:
          {
            if (GlobalConstantNames.has(node.value))
              return true;
          }
          break;
      }
      return false;
    }
    function ShouldLabelComplexExpressionNode(node, argName) {
      switch (node.type) {
        case as_parser_1.node_types.FunctionCall: {
          if (node.children[0] && node.children[0].type == as_parser_1.node_types.NamespaceAccess) {
            if (node.children[0].children[1] && node.children[0].children[1].type == as_parser_1.node_types.Identifier) {
              if (node.children[0].children[1].value == "StaticClass")
                return false;
            }
          }
          return true;
        }
        case as_parser_1.node_types.ConstructorCall:
          return true;
        case as_parser_1.node_types.BinaryOperation:
        case as_parser_1.node_types.PostfixOperation:
        case as_parser_1.node_types.TernaryOperation:
        case as_parser_1.node_types.Assignment:
        case as_parser_1.node_types.CompoundAssignment:
          return true;
        case as_parser_1.node_types.CastOperation:
          return true;
      }
      return false;
    }
    function GetInlayHintsForNode(scope, statement, node, hints) {
      if (!node)
        return;
      switch (node.type) {
        case as_parser_1.node_types.FunctionCall:
        case as_parser_1.node_types.ConstructorCall:
        case as_parser_1.node_types.VariableDecl:
          {
            let argListNode = null;
            let argCount = 0;
            let overloads = new Array();
            if (node.type == as_parser_1.node_types.VariableDecl) {
              if (node.inline_constructor && node.expression && node.typename) {
                scriptfiles2.ResolveFunctionOverloadsFromIdentifier(scope, node.typename.value, overloads);
                argListNode = node.expression;
                argCount = argListNode.children.length;
              } else {
                if (node.expression)
                  GetInlayHintsForNode(scope, statement, node.expression, hints);
                return;
              }
            } else {
              scriptfiles2.ResolveFunctionOverloadsFromExpression(scope, node.children[0], overloads);
              if (!node.children[1])
                return;
              argListNode = node.children[1];
              argCount = argListNode.children.length;
            }
            let functionIsIgnored = false;
            if (overloads.length != 0 && overloads[0]) {
              let functionName = overloads[0].name;
              let qualifiedFunctionName = null;
              if (overloads[0].containingType)
                qualifiedFunctionName = overloads[0].containingType.getDisplayName() + "::" + functionName;
              if (InlayHintSettings.parameterHintsIgnoredFunctionNames.has(functionName))
                functionIsIgnored = true;
              else if (qualifiedFunctionName && InlayHintSettings.parameterHintsIgnoredFunctionNames.has(qualifiedFunctionName))
                functionIsIgnored = true;
              else if (qualifiedFunctionName && HintIgnoredMathFunctions.has(qualifiedFunctionName))
                functionIsIgnored = true;
            }
            for (let i = 0; i < argCount; ++i) {
              let argNode = argListNode.children[i];
              if (!argNode)
                continue;
              if (scope.module.isEditingInside(statement.start_offset + argNode.end - 1, statement.start_offset + argNode.end) && i == argCount - 1)
                continue;
              if (overloads.length != 0) {
                let dbParam = null;
                let matchFunc = null;
                let paramNameAmbiguous = false;
                let paramIsFallback = false;
                for (let func of overloads) {
                  let paramIndex = i;
                  if (func.isMixin)
                    paramIndex += 1;
                  if (paramIndex >= func.args.length)
                    continue;
                  let isFallback = func.args.length < argCount;
                  if (dbParam && dbParam.name != func.args[paramIndex].name && (!isFallback || paramIsFallback))
                    paramNameAmbiguous = true;
                  if (!dbParam || paramIsFallback && !isFallback) {
                    dbParam = func.args[paramIndex];
                    paramIsFallback = isFallback;
                    if (!isFallback)
                      paramNameAmbiguous = false;
                  }
                }
                if (dbParam) {
                  let shouldShowNameHint = false;
                  if (!paramNameAmbiguous && !functionIsIgnored) {
                    if (InlayHintSettings.parameterHintsForConstants) {
                      if (ShouldLabelConstantNode(argNode, dbParam.name))
                        shouldShowNameHint = true;
                    }
                    if (InlayHintSettings.parameterHintsForComplexExpressions) {
                      if (ShouldLabelComplexExpressionNode(argNode, dbParam.name))
                        shouldShowNameHint = true;
                    }
                    if (!InlayHintSettings.parameterHintsForSingleParameterFunctions) {
                      if (argCount == 1)
                        shouldShowNameHint = false;
                    }
                    if (shouldShowNameHint && argNode.type == as_parser_1.node_types.NamedArgument)
                      shouldShowNameHint = false;
                    if (shouldShowNameHint && dbParam.name.length == 1)
                      shouldShowNameHint = false;
                    if (shouldShowNameHint && InlayHintSettings.parameterHintsIgnoredParameterNames.has(dbParam.name))
                      shouldShowNameHint = false;
                  }
                  let shouldShowRefHint = InlayHintSettings.parameterReferenceHints && dbParam.typename.includes("&") && !dbParam.typename.startsWith("const ");
                  if (shouldShowNameHint || shouldShowRefHint) {
                    let hintStr = "";
                    if (shouldShowNameHint)
                      hintStr += dbParam.name + " =";
                    if (shouldShowRefHint) {
                      if (hintStr.length != 0)
                        hintStr += " [&]";
                      else
                        hintStr += "[&]";
                    }
                    hints.push({
                      label: hintStr,
                      position: scope.module.getPosition(argNode.start + statement.start_offset),
                      kind: vscode_languageserver_1.InlayHintKind.Parameter,
                      paddingRight: true
                    });
                  }
                }
              }
              GetInlayHintsForNode(scope, statement, argNode, hints);
            }
          }
          break;
        case as_parser_1.node_types.MemberAccess:
          {
            GetInlayHintsForNode(scope, statement, node.children[0], hints);
          }
          break;
        case as_parser_1.node_types.ArgumentList:
        case as_parser_1.node_types.VariableDeclMulti:
        case as_parser_1.node_types.IndexOperator:
        case as_parser_1.node_types.BinaryOperation:
        case as_parser_1.node_types.UnaryOperation:
        case as_parser_1.node_types.PostfixOperation:
        case as_parser_1.node_types.TernaryOperation:
        case as_parser_1.node_types.Assignment:
        case as_parser_1.node_types.CompoundAssignment:
        case as_parser_1.node_types.ReturnStatement:
        case as_parser_1.node_types.DefaultStatement:
        case as_parser_1.node_types.SwitchStatement:
          {
            if (node.children) {
              for (let child of node.children)
                GetInlayHintsForNode(scope, statement, child, hints);
            }
          }
          break;
        case as_parser_1.node_types.CastOperation:
        case as_parser_1.node_types.NamedArgument:
          {
            GetInlayHintsForNode(scope, statement, node.children[1], hints);
          }
          break;
        case as_parser_1.node_types.IfStatement:
        case as_parser_1.node_types.ElseStatement:
        case as_parser_1.node_types.ForLoop:
        case as_parser_1.node_types.WhileLoop:
        case as_parser_1.node_types.CaseStatement:
        case as_parser_1.node_types.DefaultCaseStatement:
          {
            for (let i = 0, count = node.children.length - 1; i < count; ++i)
              GetInlayHintsForNode(scope, statement, node.children[i], hints);
          }
          break;
        case as_parser_1.node_types.ForEachLoop:
          {
            GetInlayHintsForNode(scope, statement, node.children[2], hints);
          }
          break;
      }
    }
    exports2.GetInlayHintsForNode = GetInlayHintsForNode;
  }
});

// unreal-angelscript-lsp/language-server/out/inline_values.js
var require_inline_values = __commonJS({
  "unreal-angelscript-lsp/language-server/out/inline_values.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProvideInlineValues = exports2.GetInlineValueSettings = void 0;
    var scriptfiles2 = require_as_parser();
    var typedb2 = require_database();
    var vscode_languageserver_1 = require_main4();
    var InlineValueSettings = {
      showInlineValueForLocalVariables: true,
      showInlineValueForParameters: true,
      showInlineValueForMemberAssignment: true,
      showInlineValueForFunctionThisObject: true
    };
    function GetInlineValueSettings() {
      return InlineValueSettings;
    }
    exports2.GetInlineValueSettings = GetInlineValueSettings;
    function ProvideInlineValues(asmodule, position) {
      let offset = asmodule.getOffset(position);
      let scope = asmodule.getScopeAt(offset);
      if (!scope)
        return null;
      if (scope.scopetype == scriptfiles2.ASScopeType.Class) {
        let funcScope = asmodule.getScopeAt(offset - 1);
        if (funcScope && funcScope.scopetype == scriptfiles2.ASScopeType.Function) {
          scope = funcScope;
          offset -= 1;
        }
      }
      let context = new InlineValueContext();
      context.values = new Array();
      context.offset = offset;
      context.asmodule = asmodule;
      context.inType = scope.getParentType();
      if (InlineValueSettings.showInlineValueForFunctionThisObject)
        AddThisObjectInlineValue(context, scope);
      AddScopeInlineValues(context, scope);
      return context.values;
    }
    exports2.ProvideInlineValues = ProvideInlineValues;
    var InlineValueContext = class {
      constructor() {
        this.shownMembers = /* @__PURE__ */ new Set();
      }
    };
    var WhitelistedInlineStructs = /* @__PURE__ */ new Set([
      "FVector",
      "FVector2D",
      "FVector4",
      "FIntVector",
      "FRotator",
      "FName",
      "FString",
      "FColor",
      "FLinearColor",
      "FText",
      "FGuid"
    ]);
    function CanTypeHaveInlineValue(scope, typename) {
      let dbType = typedb2.LookupType(scope.getNamespace(), typename);
      if (!dbType)
        return false;
      if (dbType.isStruct && !dbType.isTemplateInstantiation) {
        if (!WhitelistedInlineStructs.has(dbType.name))
          return false;
      }
      return true;
    }
    function AddThisObjectInlineValue(context, scope) {
      let inFunction = scope.getParentFunction();
      let functionScope = scope.getParentFunctionScope();
      if (context.inType && inFunction && functionScope) {
        let range = null;
        let declaration = functionScope.declaration;
        if (declaration && declaration.ast) {
          let startOffset = declaration.start_offset;
          let lineOffset = 0;
          if (declaration.ast.macro) {
            startOffset += declaration.ast.macro.start;
            lineOffset = -1;
          } else if (declaration.ast.name) {
            startOffset += declaration.ast.name.start;
            lineOffset = -1;
          }
          let statementStart = context.asmodule.getPosition(declaration.start_offset);
          let startPos = context.asmodule.getPosition(startOffset);
          startPos.line += lineOffset;
          if (startPos.line < statementStart.line + 1)
            startPos.line = statementStart.line + 1;
          startPos.character = 4;
          range = vscode_languageserver_1.Range.create(startPos, startPos);
        } else {
          range = context.asmodule.getRange(inFunction.moduleOffset, inFunction.moduleOffsetEnd);
        }
        if (context.inType.inheritsFrom("AActor")) {
          context.values.push({
            range,
            expression: "this"
          });
        } else if (context.inType.inheritsFrom("UActorComponent")) {
          context.values.push({
            range,
            expression: "Owner"
          });
          context.values.push({
            range,
            expression: "this"
          });
        } else if (context.inType.getProperty("Owner")) {
          context.values.push({
            range,
            expression: "Owner"
          });
          context.values.push({
            range,
            expression: "this"
          });
        } else {
          context.values.push({
            range,
            expression: "this"
          });
        }
      }
    }
    function AddScopeInlineValues(context, scope) {
      if (scope.scopetype != scriptfiles2.ASScopeType.Function && scope.scopetype != scriptfiles2.ASScopeType.Code) {
        return;
      }
      for (let scopeVar of scope.variables) {
        if (scopeVar.start_offset_name >= context.offset)
          continue;
        if (!CanTypeHaveInlineValue(scope, scopeVar.typename))
          continue;
        if (scopeVar.isArgument) {
          if (!InlineValueSettings.showInlineValueForParameters)
            continue;
        } else {
          if (!InlineValueSettings.showInlineValueForLocalVariables)
            continue;
        }
        context.values.push({
          range: context.asmodule.getRange(scopeVar.start_offset_name, scopeVar.end_offset_name),
          variableName: scopeVar.name,
          caseSensitiveLookup: true
        });
      }
      if (context.inType) {
        for (let i = scope.statements.length - 1; i >= 0; --i) {
          let statement = scope.statements[i];
          if (!statement)
            continue;
          if (!statement.ast)
            continue;
          if (statement.start_offset >= context.offset)
            continue;
          let node = statement.ast;
          if (InlineValueSettings.showInlineValueForMemberAssignment) {
            if (node.type == scriptfiles2.node_types.Assignment || node.type == scriptfiles2.node_types.CompoundAssignment) {
              if (node.children[0] && node.children[0].type == scriptfiles2.node_types.Identifier) {
                let identifier = node.children[0].value;
                let memberVar = context.inType.getProperty(identifier);
                if (memberVar && !context.shownMembers.has(memberVar.name) && CanTypeHaveInlineValue(scope, memberVar.typename)) {
                  context.values.push({
                    range: context.asmodule.getRange(statement.start_offset + node.children[0].start, statement.start_offset + node.children[0].end),
                    variableName: memberVar.name,
                    caseSensitiveLookup: true
                  });
                  context.shownMembers.add(memberVar.name);
                }
              }
            }
          }
        }
      }
      if (scope.parentscope)
        AddScopeInlineValues(context, scope.parentscope);
    }
  }
});

// unreal-angelscript-lsp/language-server/out/color_picker.js
var require_color_picker = __commonJS({
  "unreal-angelscript-lsp/language-server/out/color_picker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProvideColorPresentations = exports2.ProvideDocumentColors = void 0;
    var typedb2 = require_database();
    var scriptfiles2 = require_as_parser();
    function ProvideDocumentColors(asmodule) {
      let colors = new Array();
      for (let annot of asmodule.annotatedFunctionCalls) {
        if (annot.method.methodAnnotation == typedb2.DBMethodAnnotation.IsLinearColor) {
          let arglist = annot.node_call.children[1];
          let allConstants = true;
          let values = [];
          if (arglist) {
            if (arglist.children) {
              for (let child of arglist.children) {
                if (!child) {
                  allConstants = false;
                  break;
                }
                let [isNumber, value] = scriptfiles2.GetConstantNumberFromNode(child);
                if (isNumber) {
                  values.push(value);
                } else {
                  allConstants = false;
                  break;
                }
              }
            }
          }
          for (let i = values.length; i < 3; ++i)
            values.push(0);
          if (allConstants) {
            colors.push({
              color: {
                red: values[0],
                green: values[1],
                blue: values[2],
                alpha: values.length > 3 ? values[3] : 1
              },
              range: asmodule.getRange(annot.statement.start_offset + annot.node_call.start, annot.statement.start_offset + annot.node_call.end)
            });
          }
        } else if (annot.method.methodAnnotation == typedb2.DBMethodAnnotation.IsHexColor) {
          let numberValue = 4278190080;
          let arglist = annot.node_call.children[1];
          if (arglist && arglist.children && arglist.children.length == 1) {
            let [isNumber, nodeNumber] = scriptfiles2.GetConstantNumberFromNode(arglist.children[0]);
            if (isNumber)
              numberValue = nodeNumber;
          }
          let range;
          if (arglist) {
            range = asmodule.getRange(annot.statement.start_offset + arglist.start, annot.statement.start_offset + arglist.end);
          } else {
            range = asmodule.getRange(annot.statement.start_offset + annot.node_call.end - 1, annot.statement.start_offset + annot.node_call.end);
          }
          colors.push({
            color: {
              red: ((numberValue & 16711680) >>> 16) / 255,
              green: ((numberValue & 65280) >>> 8) / 255,
              blue: (numberValue & 255) / 255,
              alpha: ((numberValue & 4278190080) >>> 24) / 255
            },
            range
          });
        }
      }
      return colors;
    }
    exports2.ProvideDocumentColors = ProvideDocumentColors;
    function ProvideColorPresentations(asmodule, range, color) {
      let colors = new Array();
      let start_offset = asmodule.getOffset(range.start);
      let end_offset = asmodule.getOffset(range.end);
      for (let annot of asmodule.annotatedFunctionCalls) {
        if (annot.method.methodAnnotation == typedb2.DBMethodAnnotation.IsLinearColor) {
          let annot_start = annot.statement.start_offset + annot.node_call.start;
          if (annot_start < start_offset)
            continue;
          let annot_end = annot.statement.start_offset + annot.node_call.end;
          if (annot_end > end_offset)
            continue;
          let argString = `${color.red.toFixed(2)}, ${color.green.toFixed(2)}, ${color.blue.toFixed(2)}`;
          if (color.alpha != 1)
            argString += `, ${color.alpha.toFixed(2)}`;
          colors.push({
            label: `FLinearColor(${argString})`
          });
        } else if (annot.method.methodAnnotation == typedb2.DBMethodAnnotation.IsHexColor) {
          if (annot.node_call.children && annot.node_call.children[1]) {
            let annot_start = annot.statement.start_offset + annot.node_call.children[1].start;
            if (annot_start < start_offset)
              continue;
            let annot_end = annot.statement.start_offset + annot.node_call.children[1].end;
            if (annot_end > end_offset)
              continue;
          } else {
            let annot_start = annot.statement.start_offset + annot.node_call.end - 1;
            if (annot_start < start_offset)
              continue;
            let annot_end = annot.statement.start_offset + annot.node_call.end;
            if (annot_end > end_offset)
              continue;
          }
          let argString = "0x";
          argString += Math.round(color.alpha * 255).toString(16).padStart(2, "0");
          argString += Math.round(color.red * 255).toString(16).padStart(2, "0");
          argString += Math.round(color.green * 255).toString(16).padStart(2, "0");
          argString += Math.round(color.blue * 255).toString(16).padStart(2, "0");
          if (end_offset == annot.statement.start_offset + annot.node_call.end)
            argString += ")";
          colors.push({
            label: argString
          });
        }
      }
      return colors;
    }
    exports2.ProvideColorPresentations = ProvideColorPresentations;
  }
});

// unreal-angelscript-lsp/language-server/out/type_hierarchy.js
var require_type_hierarchy = __commonJS({
  "unreal-angelscript-lsp/language-server/out/type_hierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GetTypeHierarchySubtypes = exports2.GetTypeHierarchySupertypes = exports2.PrepareTypeHierarchy = void 0;
    var typedb2 = require_database();
    var scriptfiles2 = require_as_parser();
    var node_12 = require_node3();
    function PrepareTypeHierarchy(asmodule, position) {
      let findSymbol = asmodule.getSymbolAtOrBefore(asmodule.getOffset(position));
      if (!findSymbol)
        return null;
      let dbtype = null;
      switch (findSymbol.type) {
        case scriptfiles2.ASSymbolType.Typename:
        case scriptfiles2.ASSymbolType.Namespace: {
          dbtype = typedb2.GetTypeByName(findSymbol.symbol_name);
        }
      }
      if (!dbtype)
        return null;
      return [GetTypeHierarchyItem(dbtype)];
    }
    exports2.PrepareTypeHierarchy = PrepareTypeHierarchy;
    function GetTypeHierarchyItem(dbtype) {
      let symDetail = null;
      let symKind = node_12.SymbolKind.Class;
      if (dbtype.isStruct) {
        symKind = node_12.SymbolKind.Struct;
        symDetail = "struct " + dbtype.getDisplayName();
      } else if (dbtype.isEnum) {
        symKind = node_12.SymbolKind.Enum;
        symDetail = "enum " + dbtype.getDisplayName();
      } else {
        symKind = node_12.SymbolKind.Class;
        if (dbtype.supertype)
          symDetail = "class " + dbtype.getDisplayName() + " : " + dbtype.supertype;
        else
          symDetail = "class " + dbtype.getDisplayName();
      }
      let uri = "";
      let range = node_12.Range.create(0, 0, 0, 0);
      let selectionRange = node_12.Range.create(0, 0, 0, 0);
      if (dbtype.declaredModule) {
        let asmodule = scriptfiles2.GetModule(dbtype.declaredModule);
        if (asmodule) {
          uri = asmodule.displayUri;
          range = asmodule.getRange(dbtype.moduleScopeStart, dbtype.moduleScopeEnd);
          selectionRange = asmodule.getRange(dbtype.moduleOffset, dbtype.moduleOffsetEnd);
        }
      } else {
        symKind = node_12.SymbolKind.Interface;
      }
      return {
        name: dbtype.getDisplayName(),
        kind: symKind,
        detail: symDetail,
        uri,
        range,
        selectionRange,
        data: dbtype.name
      };
    }
    function GetTypeHierarchySupertypes(item) {
      let dbtype = typedb2.GetTypeByName(item.data);
      if (!dbtype || !dbtype.supertype)
        return [];
      let dbsuper = dbtype.getSuperType();
      if (!dbsuper)
        return [];
      return [GetTypeHierarchyItem(dbsuper)];
    }
    exports2.GetTypeHierarchySupertypes = GetTypeHierarchySupertypes;
    function GetTypeHierarchySubtypes(item) {
      let dbtype = typedb2.GetTypeByName(item.data);
      if (!dbtype)
        return [];
      let subTypes = [];
      for (let [_, checkType] of typedb2.GetAllTypesById()) {
        if (checkType.supertype == dbtype.name)
          subTypes.push(GetTypeHierarchyItem(checkType));
      }
      return subTypes;
    }
    exports2.GetTypeHierarchySubtypes = GetTypeHierarchySubtypes;
  }
});

// unreal-angelscript-lsp/language-server/out/api_docs.js
var require_api_docs = __commonJS({
  "unreal-angelscript-lsp/language-server/out/api_docs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GetAPISearch = exports2.GetAPIDetails = exports2.GetAPIList = void 0;
    var typedb2 = require_database();
    var documentation = require_documentation();
    function GetAPIList(root) {
      let list = [];
      root = root.replace(/__(ns|fun|prop)_/, "");
      let addType = function(type) {
        if (type instanceof typedb2.DBNamespace) {
          for (let [_, childNamespace] of type.childNamespaces) {
            if (childNamespace.isShadowingType())
              continue;
            list.push({
              "type": "namespace",
              "id": childNamespace.getQualifiedNamespace(),
              "data": ["namespace", childNamespace.getQualifiedNamespace()],
              "label": childNamespace.getQualifiedNamespace() + "::"
            });
          }
          if (type.isRootNamespace()) {
            list.sort(function(a, b) {
              if (a.label < b.label)
                return -1;
              else if (a.label > b.label)
                return 1;
              else
                return 0;
            });
            return;
          }
        }
        type.forEachSymbol(function(symbol) {
          if (symbol instanceof typedb2.DBMethod) {
            if (symbol.isMixin)
              return;
            list.push({
              "type": "function",
              "label": symbol.name + "()",
              "id": symbol.id.toString(),
              "data": ["function", symbol.namespace.getQualifiedNamespace() + "::" + symbol.name, symbol.id]
            });
          } else if (symbol instanceof typedb2.DBProperty) {
            list.push({
              "type": "property",
              "label": symbol.name,
              "id": symbol.namespace.getQualifiedNamespace() + "::" + symbol.name,
              "data": ["global", symbol.namespace.getQualifiedNamespace() + "::" + symbol.name]
            });
          }
        });
      };
      if (!root) {
        addType(typedb2.GetRootNamespace());
      } else {
        let namespace = typedb2.LookupNamespace(null, root);
        if (namespace) {
          addType(namespace);
        }
      }
      return list;
    }
    exports2.GetAPIList = GetAPIList;
    function GetAPIDetails(data) {
      if (data[0] == "namespace") {
        let namespace = typedb2.LookupNamespace(null, data[1]);
        if (namespace) {
          return namespace.documentation ?? "";
        }
      } else if (data[0] == "function" || data[0] == "method") {
        let method;
        let symbols;
        let method_id = 0;
        if (data[0] == "function") {
          symbols = typedb2.LookupGlobalSymbol(null, data[1]);
          method_id = data[2];
        } else {
          let dbType = typedb2.GetTypeByName(data[1]);
          if (dbType)
            symbols = dbType.findSymbols(data[2]);
          method_id = data[3];
        }
        for (let symbol of symbols) {
          if (symbol instanceof typedb2.DBMethod) {
            if (symbol.id != method_id)
              continue;
            method = symbol;
          }
        }
        if (!method) {
          for (let symbol of symbols) {
            if (symbol instanceof typedb2.DBMethod) {
              method = symbol;
            }
          }
        }
        if (!method)
          return "";
        let details = "```angelscript_snippet\n";
        details += method.returnType;
        details += " ";
        if (method.containingType) {
          details += method.containingType.getQualifiedTypenameInNamespace(null);
          details += ".";
        } else if (method.isMixin) {
          details += method.args[0].typename;
          details += ".";
        } else {
          details += method.namespace.getQualifiedNamespace();
          details += "::";
        }
        details += method.name;
        if (method.args && method.args.length > 0) {
          details += "(";
          for (let i = 0; i < method.args.length; ++i) {
            if (method.isMixin && i == 0)
              continue;
            details += "\n		";
            details += method.args[i].format();
            if (i + 1 < method.args.length)
              details += ",";
          }
          details += "\n)";
        } else {
          details += "()";
        }
        details += "\n```\n";
        let doc = method.findAvailableDocumentation();
        if (doc)
          details += documentation.FormatFunctionDocumentation(doc, method);
        return details;
      } else if (data[0] == "global") {
        let symbols = typedb2.LookupGlobalSymbol(null, data[1]);
        for (let symbol of symbols) {
          if (symbol instanceof typedb2.DBProperty) {
            let details = "```angelscript_snippet\n" + symbol.format(symbol.namespace.getQualifiedNamespace() + "::") + "\n```\n";
            details += documentation.FormatPropertyDocumentation(symbol.documentation);
            return details;
          }
        }
      } else if (data[0] == "property") {
        let dbType = typedb2.GetTypeByName(data[1]);
        if (!dbType)
          return "";
        let symbols = dbType.findSymbols(data[2]);
        for (let symbol of symbols) {
          if (symbol instanceof typedb2.DBProperty) {
            let details = "```angelscript_snippet\n" + symbol.format(symbol.containingType.getQualifiedTypenameInNamespace(null) + ".") + "\n```\n";
            details += documentation.FormatPropertyDocumentation(symbol.documentation);
            return details;
          }
        }
      }
      return "";
    }
    exports2.GetAPIDetails = GetAPIDetails;
    function GetAPISearch(filter) {
      let list = [];
      let phrases = new Array();
      for (let phrase of filter.split(" ")) {
        if (phrase.length > 0)
          phrases.push(phrase.toLowerCase());
      }
      if (phrases.length == 0)
        return [];
      let filter_lower = filter.toLowerCase();
      let canComplete = function(name) {
        let hadLongMatch = false;
        for (let i = 0; i < phrases.length; ++i) {
          let phrase = phrases[i];
          if (phrase.length < 3 && !hadLongMatch) {
            if (!name.toLowerCase().startsWith(phrase))
              return false;
          } else {
            hadLongMatch = true;
            if (!name.toLowerCase().includes(phrase))
              return false;
          }
        }
        return true;
      };
      let searchType = function(type) {
        let typePrefix = "";
        let typeMatches = false;
        if (type instanceof typedb2.DBNamespace) {
          for (let [_, childNamespace] of type.childNamespaces) {
            if (childNamespace.isShadowingType())
              continue;
            searchType(childNamespace);
          }
          if (!type.isRootNamespace()) {
            typePrefix = type.getQualifiedNamespace() + "::";
            typeMatches = canComplete(type.name);
          }
        } else {
          typePrefix = type.getQualifiedTypenameInNamespace(null) + ".";
          typeMatches = canComplete(type.name);
        }
        type.forEachSymbol(function(symbol) {
          if (symbol instanceof typedb2.DBMethod) {
            if (symbol.isConstructor)
              return;
            if (symbol.name.startsWith("op"))
              return;
            if (typeMatches || canComplete(symbol.name)) {
              let symbol_id;
              if (symbol.containingType)
                symbol_id = ["method", symbol.containingType.name, symbol.name, symbol.id];
              else if (symbol.namespace && !symbol.namespace.isRootNamespace())
                symbol_id = ["function", symbol.namespace.getQualifiedNamespace() + "::" + symbol.name];
              else
                symbol_id = ["function", symbol.name];
              let label = typePrefix + symbol.name + "()";
              if (symbol.isMixin)
                label = symbol.args[0].typename + "." + symbol.name + "()";
              list.push({
                "type": "function",
                "label": label,
                "id": symbol.id.toString(),
                "data": symbol_id
              });
            }
          } else if (symbol instanceof typedb2.DBProperty) {
            if (typeMatches || canComplete(symbol.name)) {
              let symbol_id;
              if (symbol.containingType)
                symbol_id = ["property", symbol.containingType.name, symbol.name];
              else if (symbol.namespace && !symbol.namespace.isRootNamespace())
                symbol_id = ["global", symbol.namespace.getQualifiedNamespace() + "::" + symbol.name];
              else
                symbol_id = ["global", symbol.name];
              list.push({
                "type": "property",
                "label": typePrefix + symbol.name,
                "id": typePrefix + symbol.name,
                "data": symbol_id
              });
            }
          } else if (symbol instanceof typedb2.DBType) {
            if (!symbol.declaredModule && !symbol.isEnum && !symbol.isTemplateInstantiation && !symbol.isTemplateType() && !symbol.isDelegate && !symbol.isEvent)
              searchType(symbol);
          }
        }, false);
      };
      searchType(typedb2.GetRootNamespace());
      list.sort(function(a, b) {
        if (a.data[0] == "function" && b.data[0] != "function")
          return -1;
        else if (b.data[0] == "function" && a.data[0] != "function")
          return 1;
        if (a.label < b.label)
          return -1;
        else if (a.label > b.label)
          return 1;
        return 0;
      });
      return list;
    }
    exports2.GetAPISearch = GetAPISearch;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/fs.realpath/old.js"(exports2) {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports2.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs.statSync(base);
            linkTarget = fs.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports2.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// unreal-angelscript-lsp/language-server/node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/fs.realpath/index.js"(exports2, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs = require("fs");
    var origRealpath = fs.realpath;
    var origRealpathSync = fs.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs.realpath = realpath;
      fs.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs.realpath = origRealpath;
      fs.realpathSync = origRealpathSync;
    }
  }
});

// unreal-angelscript-lsp/language-server/node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// unreal-angelscript-lsp/language-server/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// unreal-angelscript-lsp/language-server/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,(?!,).*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// unreal-angelscript-lsp/language-server/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = function() {
      try {
        return require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// unreal-angelscript-lsp/language-server/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// unreal-angelscript-lsp/language-server/node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/path-is-absolute/index.js"(exports2, module2) {
    "use strict";
    function posix(path) {
      return path.charAt(0) === "/";
    }
    function win32(path) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// unreal-angelscript-lsp/language-server/node_modules/glob/common.js
var require_common = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/glob/common.js"(exports2) {
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs = require("fs");
    var path = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self, options) {
      self.ignore = options.ignore || [];
      if (!Array.isArray(self.ignore))
        self.ignore = [self.ignore];
      if (self.ignore.length) {
        self.ignore = self.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self.silent = !!options.silent;
      self.pattern = pattern;
      self.strict = options.strict !== false;
      self.realpath = !!options.realpath;
      self.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self.follow = !!options.follow;
      self.dot = !!options.dot;
      self.mark = !!options.mark;
      self.nodir = !!options.nodir;
      if (self.nodir)
        self.mark = true;
      self.sync = !!options.sync;
      self.nounique = !!options.nounique;
      self.nonull = !!options.nonull;
      self.nosort = !!options.nosort;
      self.nocase = !!options.nocase;
      self.stat = !!options.stat;
      self.noprocess = !!options.noprocess;
      self.absolute = !!options.absolute;
      self.fs = options.fs || fs;
      self.maxLength = options.maxLength || Infinity;
      self.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self, options);
      self.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self.cwd = cwd;
      else {
        self.cwd = path.resolve(options.cwd);
        self.changedCwd = self.cwd !== cwd;
      }
      self.root = options.root || path.resolve(self.cwd, "/");
      self.root = path.resolve(self.root);
      if (process.platform === "win32")
        self.root = self.root.replace(/\\/g, "/");
      self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
      if (process.platform === "win32")
        self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
      self.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      options.allowWindowsEscape = false;
      self.minimatch = new Minimatch(pattern, options);
      self.options = self.minimatch.options;
    }
    function finish(self) {
      var nou = self.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l = self.matches.length; i < l; i++) {
        var matches = self.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self.nonull) {
            var literal = self.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self.nosort)
        all = all.sort(alphasort);
      if (self.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self._mark(all[i]);
        }
        if (self.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self.cache[e] || self.cache[makeAbs(self, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self, m2);
        });
      self.found = all;
    }
    function mark(self, p) {
      var abs = makeAbs(self, p);
      var c = self.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self, m);
          self.statCache[mabs] = self.statCache[abs];
          self.cache[mabs] = self.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path.join(self.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self.changedCwd) {
        abs = path.resolve(self.cwd, f);
      } else {
        abs = path.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self, path2) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self, path2) {
      if (!self.ignore.length)
        return false;
      return self.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// unreal-angelscript-lsp/language-server/node_modules/glob/sync.js
var require_sync = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/glob/sync.js"(exports2, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert.ok(this instanceof GlobSync);
      if (this.realpath) {
        var self = this;
        this.matches.forEach(function(matchset, index) {
          var set = self.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self._makeAbs(p);
              var real = rp.realpathSync(p, self.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert.ok(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// unreal-angelscript-lsp/language-server/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// unreal-angelscript-lsp/language-server/node_modules/once/once.js
var require_once = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// unreal-angelscript-lsp/language-server/node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/inflight/inflight.js"(exports2, module2) {
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// unreal-angelscript-lsp/language-server/node_modules/glob/glob.js
var require_glob = __commonJS({
  "unreal-angelscript-lsp/language-server/node_modules/glob/glob.js"(exports2, module2) {
    module2.exports = glob2;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob2(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob2.sync = globSync;
    var GlobSync = glob2.GlobSync = globSync.GlobSync;
    glob2.glob = glob2;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob2.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob2.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self._processing;
        if (self._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self._finish();
            });
          } else {
            self._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self._makeAbs(p);
        rp.realpath(p, self.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self.emit("error", er);
          if (--n === 0) {
            self.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self.cache[abs] = "FILE";
          cb();
        } else
          self._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self = this;
      self.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self, abs, cb) {
      return function(er, entries) {
        if (er)
          self._readdirError(abs, er, cb);
        else
          self._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self = this;
      this._stat(prefix, function(er, exists) {
        self._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self._stat2(f, abs, null, lstat, cb);
            else
              self._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// unreal-angelscript-lsp/language-server/out/unreal-buffers.js
var require_unreal_buffers = __commonJS({
  "unreal-angelscript-lsp/language-server/out/unreal-buffers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildCreateBlueprint = exports2.buildOpenAssets = exports2.buildDisconnect = exports2.buildGoTo = exports2.readMessages = exports2.Message = exports2.MessageType = void 0;
    var MessageType;
    (function(MessageType2) {
      MessageType2[MessageType2["Diagnostics"] = 0] = "Diagnostics";
      MessageType2[MessageType2["RequestDebugDatabase"] = 1] = "RequestDebugDatabase";
      MessageType2[MessageType2["DebugDatabase"] = 2] = "DebugDatabase";
      MessageType2[MessageType2["StartDebugging"] = 3] = "StartDebugging";
      MessageType2[MessageType2["StopDebugging"] = 4] = "StopDebugging";
      MessageType2[MessageType2["Pause"] = 5] = "Pause";
      MessageType2[MessageType2["Continue"] = 6] = "Continue";
      MessageType2[MessageType2["RequestCallStack"] = 7] = "RequestCallStack";
      MessageType2[MessageType2["CallStack"] = 8] = "CallStack";
      MessageType2[MessageType2["ClearBreakpoints"] = 9] = "ClearBreakpoints";
      MessageType2[MessageType2["SetBreakpoint"] = 10] = "SetBreakpoint";
      MessageType2[MessageType2["HasStopped"] = 11] = "HasStopped";
      MessageType2[MessageType2["HasContinued"] = 12] = "HasContinued";
      MessageType2[MessageType2["StepOver"] = 13] = "StepOver";
      MessageType2[MessageType2["StepIn"] = 14] = "StepIn";
      MessageType2[MessageType2["StepOut"] = 15] = "StepOut";
      MessageType2[MessageType2["EngineBreak"] = 16] = "EngineBreak";
      MessageType2[MessageType2["RequestVariables"] = 17] = "RequestVariables";
      MessageType2[MessageType2["Variables"] = 18] = "Variables";
      MessageType2[MessageType2["RequestEvaluate"] = 19] = "RequestEvaluate";
      MessageType2[MessageType2["Evaluate"] = 20] = "Evaluate";
      MessageType2[MessageType2["GoToDefinition"] = 21] = "GoToDefinition";
      MessageType2[MessageType2["BreakOptions"] = 22] = "BreakOptions";
      MessageType2[MessageType2["RequestBreakFilters"] = 23] = "RequestBreakFilters";
      MessageType2[MessageType2["BreakFilters"] = 24] = "BreakFilters";
      MessageType2[MessageType2["Disconnect"] = 25] = "Disconnect";
      MessageType2[MessageType2["DebugDatabaseFinished"] = 26] = "DebugDatabaseFinished";
      MessageType2[MessageType2["AssetDatabaseInit"] = 27] = "AssetDatabaseInit";
      MessageType2[MessageType2["AssetDatabase"] = 28] = "AssetDatabase";
      MessageType2[MessageType2["AssetDatabaseFinished"] = 29] = "AssetDatabaseFinished";
      MessageType2[MessageType2["FindAssets"] = 30] = "FindAssets";
      MessageType2[MessageType2["DebugDatabaseSettings"] = 31] = "DebugDatabaseSettings";
      MessageType2[MessageType2["PingAlive"] = 32] = "PingAlive";
      MessageType2[MessageType2["DebugServerVersion"] = 33] = "DebugServerVersion";
      MessageType2[MessageType2["CreateBlueprint"] = 34] = "CreateBlueprint";
      MessageType2[MessageType2["ReplaceAssetDefinition"] = 35] = "ReplaceAssetDefinition";
      MessageType2[MessageType2["SetDataBreakpoints"] = 36] = "SetDataBreakpoints";
      MessageType2[MessageType2["ClearDataBreakpoints"] = 37] = "ClearDataBreakpoints";
    })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
    var Message = class {
      constructor(type, offset, size, buffer) {
        this.type = type;
        this.offset = offset;
        this.buffer = buffer;
        this.size = size;
      }
      readInt() {
        let value = this.buffer.readIntLE(this.offset, 4);
        this.offset += 4;
        return value;
      }
      readByte() {
        let value = this.buffer.readInt8(this.offset);
        this.offset += 1;
        return value;
      }
      readBool() {
        return this.readInt() != 0;
      }
      readString() {
        let num = this.readInt();
        let ucs2 = num < 0;
        if (ucs2) {
          num = -num;
        }
        if (ucs2) {
          let str = this.buffer.toString("utf16le", this.offset, this.offset + num * 2);
          this.offset += num * 2;
          if (str[str.length - 1] == "\0")
            str = str.substr(0, str.length - 1);
          return str;
        } else {
          let str = this.buffer.toString("utf8", this.offset, this.offset + num);
          this.offset += num;
          if (str[str.length - 1] == "\0")
            str = str.substr(0, str.length - 1);
          return str;
        }
      }
    };
    exports2.Message = Message;
    var pendingBuffer = Buffer.alloc(0);
    function readMessages(buffer) {
      let list = [];
      let offset = 0;
      pendingBuffer = Buffer.concat([pendingBuffer, buffer]);
      while (pendingBuffer.length >= 5) {
        let offset2 = 0;
        let msglen = pendingBuffer.readUIntLE(offset2, 4);
        offset2 += 4;
        let msgtype = pendingBuffer.readInt8(offset2);
        offset2 += 1;
        if (msglen <= pendingBuffer.length - offset2) {
          list.push(new Message(msgtype, offset2, msglen, pendingBuffer));
          pendingBuffer = pendingBuffer.slice(offset2 + msglen);
        } else {
          return list;
        }
      }
      return list;
    }
    exports2.readMessages = readMessages;
    function writeInt(value) {
      let newBuffer = Buffer.alloc(4);
      newBuffer.writeInt32LE(value, 0);
      return newBuffer;
    }
    function writeString(str) {
      let newBuffer = Buffer.alloc(4);
      newBuffer.writeInt32LE(str.length + 1, 0);
      return Buffer.concat([newBuffer, Buffer.from(str + "\0", "binary")]);
    }
    function buildGoTo(typename, symbolname) {
      let head = Buffer.alloc(5);
      head.writeUInt8(MessageType.GoToDefinition, 4);
      let msg = Buffer.concat([
        head,
        writeString(typename),
        writeString(symbolname)
      ]);
      msg.writeUInt32LE(msg.length - 4, 0);
      return msg;
    }
    exports2.buildGoTo = buildGoTo;
    function buildDisconnect() {
      let msg = Buffer.alloc(5);
      msg.writeUInt32LE(1, 0);
      msg.writeUInt8(MessageType.Disconnect, 4);
      return msg;
    }
    exports2.buildDisconnect = buildDisconnect;
    function buildOpenAssets(assets2, className) {
      let head = Buffer.alloc(5);
      head.writeUInt8(MessageType.FindAssets, 4);
      let parts = [head, writeInt(1), writeInt(assets2.length)];
      for (let asset of assets2)
        parts.push(writeString(asset));
      parts.push(writeString(className));
      let msg = Buffer.concat(parts);
      msg.writeUInt32LE(msg.length - 4, 0);
      return msg;
    }
    exports2.buildOpenAssets = buildOpenAssets;
    function buildCreateBlueprint(className) {
      let head = Buffer.alloc(5);
      head.writeUInt8(MessageType.CreateBlueprint, 4);
      let parts = [head, writeString(className)];
      let msg = Buffer.concat(parts);
      msg.writeUInt32LE(msg.length - 4, 0);
      return msg;
    }
    exports2.buildCreateBlueprint = buildCreateBlueprint;
  }
});

// unreal-angelscript-lsp/language-server/out/server.js
Object.defineProperty(exports, "__esModule", { value: true });
var node_1 = require_node3();
var net_1 = require("net");
var vscode_uri_1 = require_umd();
var scriptfiles = require_as_parser();
var parsedcompletion = require_parsed_completion();
var typedb = require_database();
var scriptreferences = require_references();
var scriptoccurances = require_highlight_occurances();
var scriptsemantics = require_semantic_highlighting();
var scriptsymbols = require_symbols();
var scriptdiagnostics = require_ls_diagnostics();
var scriptlenses = require_code_lenses();
var scriptactions = require_code_actions();
var generatedcode = require_generated_code();
var assets = require_assets();
var inlayhints = require_inlay_hints();
var inlinevalues = require_inline_values();
var colorpicker = require_color_picker();
var typehierarchy = require_type_hierarchy();
var api_docs = require_api_docs();
var glob = require_glob();
var unreal_buffers_1 = require_unreal_buffers();
var connection = (0, node_1.createConnection)(new node_1.StreamMessageReader(process.stdin), new node_1.StreamMessageWriter(process.stdout));
var unreal;
var hostname = "127.0.0.1";
var port = 27099;
var ParseQueue = [];
var ParseQueueIndex = 0;
var LoadQueue = [];
var LoadQueueIndex = 0;
var PostProcessTypesQueue = [];
var PostProcessTypesQueueIndex = 0;
var ResolveQueue = [];
var ResolveQueueIndex = 0;
var IsServicingQueues = false;
var ReceivingTypesTimeout = null;
var UnrealTypesTimedOut = false;
var settings = null;
var reconnectTimeoutId = void 0;
function connect_unreal() {
  if (reconnectTimeoutId) {
    clearTimeout(reconnectTimeoutId);
    reconnectTimeoutId = void 0;
  }
  if (unreal != null) {
    unreal.removeAllListeners();
    unreal.write((0, unreal_buffers_1.buildDisconnect)());
    unreal.destroy();
  }
  unreal = new net_1.Socket();
  unreal.on("data", function(data) {
    let messages = (0, unreal_buffers_1.readMessages)(data);
    for (let msg of messages) {
      if (msg.type == unreal_buffers_1.MessageType.Diagnostics) {
        let diagnostics = [];
        let localpath = msg.readString();
        let filename = localpath[0] == "/" ? "file://" + localpath : "file:///" + localpath;
        let msgCount = msg.readInt();
        for (let i = 0; i < msgCount; ++i) {
          let message = msg.readString();
          let line = msg.readInt();
          let char = msg.readInt();
          let isError = msg.readBool();
          let isInfo = msg.readBool();
          if (isInfo) {
            let hasExisting = false;
            for (let diag of diagnostics) {
              if (diag.range.start.line == line - 1)
                hasExisting = true;
            }
            if (!hasExisting)
              continue;
          }
          if (line <= 0)
            line = 1;
          let diagnosic = {
            severity: isInfo ? node_1.DiagnosticSeverity.Information : isError ? node_1.DiagnosticSeverity.Error : node_1.DiagnosticSeverity.Warning,
            range: {
              start: { line: line - 1, character: 0 },
              end: { line: line - 1, character: 1e4 }
            },
            message,
            source: "as"
          };
          diagnostics.push(diagnosic);
        }
        scriptdiagnostics.UpdateCompileDiagnostics(filename, diagnostics);
      } else if (msg.type == unreal_buffers_1.MessageType.DebugDatabase) {
        let dbStr = msg.readString();
        let dbObj = JSON.parse(dbStr);
        typedb.AddTypesFromUnreal(dbObj);
        UnrealTypesTimedOut = false;
        if (ReceivingTypesTimeout)
          clearTimeout(ReceivingTypesTimeout);
        ReceivingTypesTimeout = setTimeout(DetectUnrealTypeListTimeout, 1e3);
      } else if (msg.type == unreal_buffers_1.MessageType.DebugDatabaseFinished) {
        if (ReceivingTypesTimeout)
          clearTimeout(ReceivingTypesTimeout);
        typedb.FinishTypesFromUnreal();
        let scriptSettings = scriptfiles.GetScriptSettings();
        typedb.AddPrimitiveTypes(scriptSettings.floatIsFloat64);
        ReResolveAllModules();
      } else if (msg.type == unreal_buffers_1.MessageType.AssetDatabase) {
        let version = msg.readInt();
        if (version == 1) {
          let assetCount = msg.readInt();
          for (let i = 0; i < assetCount; i += 2) {
            let assetPath = msg.readString();
            let className = msg.readString();
            if (className.length == 0)
              assets.RemoveAsset(assetPath);
            else
              assets.AddAsset(assetPath, className);
          }
        }
      } else if (msg.type == unreal_buffers_1.MessageType.AssetDatabaseInit) {
        assets.ClearDatabase();
      } else if (msg.type == unreal_buffers_1.MessageType.AssetDatabaseFinished) {
      } else if (msg.type == unreal_buffers_1.MessageType.DebugDatabaseSettings) {
        let version = msg.readInt();
        let scriptSettings = scriptfiles.GetScriptSettings();
        scriptSettings.automaticImports = msg.readBool();
        if (version >= 2)
          scriptSettings.floatIsFloat64 = msg.readBool();
        if (version >= 3)
          scriptSettings.useAngelscriptHaze = msg.readBool();
        scriptlenses.GetCodeLensSettings().engineSupportsCreateBlueprint = version >= 4;
        if (version >= 5) {
          scriptSettings.deprecateStaticClass = msg.readBool();
          scriptSettings.disallowStaticClass = msg.readBool();
        }
        if (version >= 6) {
          scriptSettings.exposeGlobalFunctions = msg.readBool();
        }
        if (version >= 7) {
          scriptSettings.deprecateActorGenerics = msg.readBool();
          scriptSettings.disallowActorGenerics = msg.readBool();
        }
      } else if (msg.type == unreal_buffers_1.MessageType.ReplaceAssetDefinition) {
        let assetName = msg.readString();
        let lineCount = msg.readInt();
        let lines = [];
        for (let i = 0; i < lineCount; i += 1)
          lines.push(msg.readString());
        ReplaceScriptAssetDefinition(assetName, lines);
      }
    }
  });
  unreal.on("error", function() {
    if (unreal != null) {
      unreal.destroy();
      unreal = null;
      if (!reconnectTimeoutId)
        reconnectTimeoutId = setTimeout(connect_unreal, 5e3);
    }
  });
  unreal.on("close", function() {
    if (unreal != null) {
      unreal.destroy();
      unreal = null;
      if (!reconnectTimeoutId)
        reconnectTimeoutId = setTimeout(connect_unreal, 5e3);
    }
  });
  unreal.connect(port, hostname, function() {
    setTimeout(function() {
      if (!unreal)
        return;
      let reqDb = Buffer.alloc(5);
      reqDb.writeUInt32LE(1, 0);
      reqDb.writeUInt8(unreal_buffers_1.MessageType.RequestDebugDatabase, 4);
      unreal.write(reqDb);
    }, 1e3);
  });
}
connect_unreal();
var shouldSendDiagnosticRelatedInformation = false;
var RootUris = [];
connection.onInitialize((_params) => {
  shouldSendDiagnosticRelatedInformation = _params.capabilities && _params.capabilities.textDocument && _params.capabilities.textDocument.publishDiagnostics && _params.capabilities.textDocument.publishDiagnostics.relatedInformation;
  let Roots = [];
  if (_params.workspaceFolders == null) {
    Roots.push(_params.rootPath);
    RootUris.push(decodeURIComponent(_params.rootUri));
  } else {
    for (let Workspace of _params.workspaceFolders) {
      Roots.push(vscode_uri_1.URI.parse(Workspace.uri).fsPath);
      RootUris.push(decodeURIComponent(Workspace.uri));
    }
  }
  connection.console.log("Workspace roots: " + Roots);
  let GlobsRemaining = Roots.length;
  for (let RootPath of Roots) {
    let globOptions = {
      ignore: (settings == null ? void 0 : settings.scriptIgnorePatterns) || []
    };
    glob(RootPath + "/**/*.as", globOptions, function(err, files) {
      for (let file of files) {
        let uri = getFileUri(file);
        let asmodule = scriptfiles.GetOrCreateModule(getModuleName(uri), file, uri);
        LoadQueue.push(asmodule);
      }
      GlobsRemaining -= 1;
      if (GlobsRemaining <= 0)
        TickQueues();
    });
    glob(RootPath + "/.vscode/templates/*.as.template", null, function(err, files) {
      scriptlenses.LoadFileTemplates(files);
    });
  }
  setTimeout(DetectUnrealConnectionTimeout, 2e4);
  return {
    capabilities: {
      // Tell the client that the server works in FULL text document sync mode
      textDocumentSync: {
        openClose: true,
        change: node_1.TextDocumentSyncKind.Incremental
      },
      // Tell the client that the server support code complete
      completionProvider: {
        resolveProvider: true,
        triggerCharacters: [".", ":"]
      },
      signatureHelpProvider: {
        triggerCharacters: ["(", ")", ","],
        retriggerCharacters: ["="]
      },
      hoverProvider: true,
      documentSymbolProvider: true,
      workspaceSymbolProvider: { "resolveProvider": true },
      definitionProvider: true,
      implementationProvider: true,
      referencesProvider: true,
      documentHighlightProvider: true,
      inlayHintProvider: true,
      inlineValueProvider: true,
      renameProvider: {
        prepareProvider: true
      },
      codeLensProvider: {
        resolveProvider: false
      },
      executeCommandProvider: {
        commands: ["angelscript.openAssets", "angelscript.createBlueprint", "angelscript.editAsset"]
      },
      codeActionProvider: {
        resolveProvider: true
      },
      semanticTokensProvider: {
        legend: {
          tokenTypes: scriptsemantics.SemanticTypeList.map((t) => "as_" + t),
          tokenModifiers: []
        },
        range: false,
        full: {
          delta: true
        }
      },
      colorProvider: {
        documentSelector: null
      },
      typeHierarchyProvider: true
    }
  };
});
function DetectUnrealConnectionTimeout() {
  UnrealTypesTimedOut = true;
}
function DetectUnrealTypeListTimeout() {
  typedb.FinishTypesFromUnreal();
  let scriptSettings = scriptfiles.GetScriptSettings();
  typedb.AddPrimitiveTypes(scriptSettings.floatIsFloat64);
  ReResolveAllModules();
}
function TickQueues() {
  IsServicingQueues = true;
  if (LoadQueueIndex < LoadQueue.length) {
    for (let n = 0; n < 200 && LoadQueueIndex < LoadQueue.length; ++n, ++LoadQueueIndex) {
      if (!LoadQueue[LoadQueueIndex].loaded)
        scriptfiles.UpdateModuleFromDisk(LoadQueue[LoadQueueIndex]);
      ParseQueue.push(LoadQueue[LoadQueueIndex]);
    }
  } else if (LoadQueue.length != 0) {
    LoadQueue = [];
    LoadQueueIndex = 0;
  } else if (ParseQueueIndex < ParseQueue.length) {
    for (let n = 0; n < 10 && ParseQueueIndex < ParseQueue.length; ++n, ++ParseQueueIndex) {
      if (!ParseQueue[ParseQueueIndex].parsed)
        scriptfiles.ParseModule(ParseQueue[ParseQueueIndex]);
      PostProcessTypesQueue.push(ParseQueue[ParseQueueIndex]);
    }
  } else if (ParseQueue.length != 0) {
    ParseQueue = [];
    ParseQueueIndex = 0;
    scriptfiles.SetInitialParseDone();
  } else if (PostProcessTypesQueueIndex < PostProcessTypesQueue.length) {
    if (CanResolveModules()) {
      for (let n = 0; n < 50 && PostProcessTypesQueueIndex < PostProcessTypesQueue.length; ++n, ++PostProcessTypesQueueIndex) {
        if (!PostProcessTypesQueue[PostProcessTypesQueueIndex].typesPostProcessed)
          scriptfiles.PostProcessModuleTypes(PostProcessTypesQueue[PostProcessTypesQueueIndex]);
        ResolveQueue.push(PostProcessTypesQueue[PostProcessTypesQueueIndex]);
      }
    }
  } else if (PostProcessTypesQueue.length != 0) {
    PostProcessTypesQueue = [];
    PostProcessTypesQueueIndex = 0;
  } else if (ResolveQueueIndex < ResolveQueue.length) {
    if (CanResolveModules()) {
      for (let n = 0; n < 20 && ResolveQueueIndex < ResolveQueue.length; ++n, ++ResolveQueueIndex) {
        if (!ResolveQueue[ResolveQueueIndex].resolved) {
          scriptfiles.ResolveModule(ResolveQueue[ResolveQueueIndex]);
          scriptdiagnostics.UpdateScriptModuleDiagnostics(ResolveQueue[ResolveQueueIndex], true);
        }
      }
    }
  } else if (ResolveQueue.length != 0) {
    ResolveQueue = [];
    ResolveQueueIndex = 0;
  }
  if (LoadQueue.length != 0 || ParseQueue.length != 0 || PostProcessTypesQueue.length != 0 || ResolveQueue.length != 0) {
    setTimeout(TickQueues, 1);
  } else {
    IsServicingQueues = false;
  }
}
function DirtyAllDiagnostics() {
  if (IsServicingQueues)
    return;
  let moduleIndex = 0;
  let moduleList = scriptfiles.GetAllLoadedModules();
  let timerHandle = setInterval(UpdateDiagnostics, 1);
  function UpdateDiagnostics() {
    for (let i = 0; i < 20; ++i) {
      if (moduleIndex >= moduleList.length) {
        clearInterval(timerHandle);
        return;
      }
      let module2 = moduleList[moduleIndex];
      if (module2 && module2.resolved)
        scriptdiagnostics.UpdateScriptModuleDiagnostics(module2);
      moduleIndex += 1;
    }
  }
}
function ReResolveAllModules() {
  if (IsServicingQueues)
    return;
  scriptfiles.ClearAllResolvedModules();
  let moduleIndex = 0;
  let moduleList = scriptfiles.GetAllLoadedModules();
  let timerHandle = setInterval(ReResolveModules, 1);
  function ReResolveModules() {
    for (let i = 0; i < 20; ++i) {
      if (moduleIndex >= moduleList.length) {
        clearInterval(timerHandle);
        return;
      }
      let module2 = moduleList[moduleIndex];
      if (module2 && !module2.resolved) {
        scriptfiles.ResolveModule(module2);
        scriptdiagnostics.UpdateScriptModuleDiagnostics(module2);
      }
      moduleIndex += 1;
    }
  }
}
function CanResolveModules() {
  return typedb.HasTypesFromUnreal() && LoadQueue.length == 0;
}
scriptdiagnostics.OnDiagnosticsChanged(function(uri, diagnostics) {
  connection.sendDiagnostics({ "uri": uri, "diagnostics": diagnostics });
});
connection.onDidChangeWatchedFiles((_change) => {
  for (let change of _change.changes) {
    let module2 = scriptfiles.GetOrCreateModule(getModuleName(change.uri), getPathName(change.uri), change.uri);
    if (module2) {
      if (!module2.isOpened)
        scriptfiles.UpdateModuleFromDisk(module2);
      scriptfiles.ParseModule(module2);
      if (CanResolveModules() && ParseQueue.length == 0 && LoadQueue.length == 0) {
        scriptfiles.PostProcessModuleTypes(module2);
        scriptfiles.ResolveModule(module2);
        let alwaysSendDiagnostics = false;
        if (change.type == node_1.FileChangeType.Deleted)
          alwaysSendDiagnostics = true;
        if (change.type == node_1.FileChangeType.Created)
          alwaysSendDiagnostics = true;
        scriptdiagnostics.UpdateScriptModuleDiagnostics(module2, false, alwaysSendDiagnostics);
      }
    }
  }
});
function GetAndParseModule(uri) {
  let asmodule = scriptfiles.GetModuleByUri(uri);
  if (!asmodule)
    return null;
  scriptfiles.ParseModuleAndDependencies(asmodule);
  if (CanResolveModules()) {
    scriptfiles.PostProcessModuleTypesAndDependencies(asmodule);
    scriptfiles.ResolveModule(asmodule);
  }
  return asmodule;
}
connection.onCompletion((_textDocumentPosition) => {
  let asmodule = GetAndParseModule(_textDocumentPosition.textDocument.uri);
  if (!asmodule)
    return null;
  let completions = parsedcompletion.Complete(asmodule, _textDocumentPosition.position);
  return completions;
});
connection.onCompletionResolve((item) => {
  let resolvedItem = parsedcompletion.Resolve(item);
  if (resolvedItem)
    return resolvedItem;
  else
    return item;
});
connection.onSignatureHelp((_textDocumentPosition) => {
  let asmodule = GetAndParseModule(_textDocumentPosition.textDocument.uri);
  if (!asmodule)
    return null;
  let help = parsedcompletion.Signature(asmodule, _textDocumentPosition.position);
  return help;
});
connection.onDefinition((_textDocumentPosition) => {
  let asmodule = GetAndParseModule(_textDocumentPosition.textDocument.uri);
  if (!asmodule)
    return null;
  if (!asmodule.resolved)
    return null;
  let definitions = scriptsymbols.GetDefinition(asmodule, _textDocumentPosition.position);
  if (definitions && definitions.length == 1)
    return definitions[0];
  return definitions;
});
connection.onImplementation((_textDocumentPosition) => {
  let asmodule = GetAndParseModule(_textDocumentPosition.textDocument.uri);
  if (!asmodule)
    return null;
  if (!asmodule.resolved)
    return null;
  let definitions = scriptsymbols.GetDefinition(asmodule, _textDocumentPosition.position);
  if (definitions && definitions.length != 0) {
    if (definitions.length == 1)
      return definitions[0];
    return definitions;
  }
  let cppSymbol = scriptsymbols.GetCppSymbol(asmodule, _textDocumentPosition.position);
  if (cppSymbol) {
    if (unreal)
      unreal.write((0, unreal_buffers_1.buildGoTo)(cppSymbol[0], cppSymbol[1]));
  }
  return null;
});
connection.onHover((_textDocumentPosition) => {
  let asmodule = GetAndParseModule(_textDocumentPosition.textDocument.uri);
  if (!asmodule)
    return null;
  if (!asmodule.resolved)
    return null;
  return scriptsymbols.GetHover(asmodule, _textDocumentPosition.position);
});
connection.onDocumentSymbol((_params) => {
  let asmodule = GetAndParseModule(_params.textDocument.uri);
  if (!asmodule)
    return null;
  return scriptsymbols.DocumentSymbols(asmodule);
});
connection.onWorkspaceSymbol((_params) => {
  return scriptsymbols.WorkspaceSymbols(_params.query);
});
connection.onWorkspaceSymbolResolve((symbol) => {
  return scriptsymbols.ResolveWorkspaceSymbol(symbol);
});
connection.onReferences(function(params) {
  if (!CanResolveModules())
    return null;
  if (LoadQueue.length != 0)
    return null;
  let generator = scriptreferences.FindReferences(params.textDocument.uri, params.position);
  let result = generator.next();
  if (result && result.value)
    return result.value;
  return new Promise((resolve, reject) => {
    let timerHandle = setInterval(MakeProgress, 1);
    function MakeProgress() {
      let result2 = generator.next();
      if (result2 && result2.value) {
        clearInterval(timerHandle);
        resolve(result2.value);
      }
    }
  });
});
connection.onPrepareRename(function(params) {
  if (!CanResolveModules())
    return null;
  if (LoadQueue.length != 0)
    return null;
  let result = null;
  if (!CanResolveModules())
    result = new node_1.ResponseError(0, "Please wait for all script parsing to finish...");
  else
    result = scriptreferences.PrepareRename(params.textDocument.uri, params.position);
  return result;
});
connection.onRenameRequest(function(params) {
  if (!CanResolveModules())
    return null;
  if (LoadQueue.length != 0)
    return null;
  let generator = scriptreferences.PerformRename(params.textDocument.uri, params.position, params.newName);
  return new Promise((resolve, reject) => {
    let timerHandle = setInterval(MakeProgress, 1);
    function MakeProgress() {
      let result = generator.next();
      if (result && result.value) {
        clearInterval(timerHandle);
        let workspaceEdit = {};
        workspaceEdit.changes = {};
        for (let [uri, edits] of result.value)
          workspaceEdit.changes[uri] = edits;
        resolve(workspaceEdit);
      }
    }
  });
});
connection.onDocumentHighlight(function(params) {
  if (!CanResolveModules())
    return null;
  return scriptoccurances.HighlightOccurances(params.textDocument.uri, params.position);
});
connection.onCodeLens(function(params) {
  if (!CanResolveModules())
    return null;
  let asmodule = scriptfiles.GetModuleByUri(params.textDocument.uri);
  if (!asmodule)
    return null;
  scriptfiles.ParseModuleAndDependencies(asmodule);
  scriptfiles.PostProcessModuleTypesAndDependencies(asmodule);
  scriptfiles.ResolveModule(asmodule);
  return scriptlenses.ComputeCodeLenses(asmodule);
});
connection.onCodeLensResolve(function(lens) {
  return lens;
});
connection.onExecuteCommand(function(params) {
  if (params.command == "angelscript.openAssets") {
    if (params.arguments && params.arguments[0]) {
      let argList = params.arguments;
      let className = argList[0];
      let references = assets.GetAssetsImplementing(argList[0]);
      if (!references || references.length == 0)
        return;
      if (unreal)
        unreal.write((0, unreal_buffers_1.buildOpenAssets)(references, className));
      else
        connection.window.showErrorMessage("Cannot open asset: not connected to unreal editor.");
    }
  } else if (params.command == "angelscript.editAsset") {
    if (params.arguments && params.arguments[0]) {
      let assetPath = params.arguments[0];
      if (unreal)
        unreal.write((0, unreal_buffers_1.buildOpenAssets)([assetPath], ""));
      else
        connection.window.showErrorMessage("Cannot edit asset: not connected to unreal editor.");
    }
  } else if (params.command == "angelscript.createBlueprint") {
    if (params.arguments && params.arguments[0]) {
      let className = params.arguments[0];
      if (unreal)
        unreal.write((0, unreal_buffers_1.buildCreateBlueprint)(className));
      else
        connection.window.showErrorMessage("Cannot create blueprint: not connected to unreal editor.");
    }
  }
});
connection.onCodeAction(function(params) {
  let asmodule = GetAndParseModule(params.textDocument.uri);
  if (!asmodule)
    return null;
  if (!asmodule.resolved)
    return null;
  return scriptactions.GetCodeActions(asmodule, params.range, params.context.diagnostics);
});
connection.onCodeActionResolve(function(action) {
  let data = action.data;
  if (!data || !data.uri)
    return action;
  let asmodule = GetAndParseModule(data.uri);
  if (!asmodule)
    return action;
  if (!asmodule.resolved)
    return action;
  return scriptactions.ResolveCodeAction(asmodule, action, data);
});
function ReplaceScriptAssetDefinition(assetName, assetContent) {
  let asset = scriptfiles.ScriptLiteralAssetsByName.get(assetName);
  if (!asset)
    return;
  let outerIndent = scriptactions.GetIndentForStatement(asset.statement);
  let indent = scriptactions.GetIndentForBlock(asset.content_scope);
  let newContent = "\n";
  for (let line of assetContent) {
    newContent += indent + line;
    newContent += "\n";
  }
  newContent += outerIndent;
  let edit = {};
  edit.changes = {};
  edit.changes[asset.module.displayUri] = [
    node_1.TextEdit.replace(asset.module.getRange(asset.content_scope.start_offset, asset.content_scope.end_offset), newContent)
  ];
  connection.workspace.applyEdit(edit);
  connection.sendNotification("angelscript/wantSave", [asset.module.displayUri]);
}
function TryResolveSymbols(asmodule) {
  if (CanResolveModules()) {
    if (!asmodule)
      return null;
    scriptfiles.ParseModuleAndDependencies(asmodule);
    scriptfiles.PostProcessModuleTypesAndDependencies(asmodule);
    scriptfiles.ResolveModule(asmodule);
    return scriptsemantics.HighlightSymbols(asmodule);
  } else {
    return null;
  }
}
function WaitForResolveSymbols(params) {
  let asmodule = scriptfiles.GetModuleByUri(params.textDocument.uri);
  let result = TryResolveSymbols(asmodule);
  if (result)
    return result;
  function timerFunc(resolve, reject, triesLeft) {
    let result2 = TryResolveSymbols(asmodule);
    if (result2)
      return resolve(result2);
    setTimeout(function() {
      timerFunc(resolve, reject, triesLeft - 1);
    }, 100);
  }
  let promise = new Promise(function(resolve, reject) {
    timerFunc(resolve, reject, 50);
  });
  return promise;
}
connection.languages.semanticTokens.onDelta(function(params) {
  if (!CanResolveModules())
    return WaitForResolveSymbols(params);
  let asmodule = scriptfiles.GetModuleByUri(params.textDocument.uri);
  scriptfiles.ParseModuleAndDependencies(asmodule);
  scriptfiles.PostProcessModuleTypesAndDependencies(asmodule);
  scriptfiles.ResolveModule(asmodule);
  let delta = scriptsemantics.HighlightSymbolsDelta(asmodule, params.previousResultId);
  return delta;
});
connection.languages.semanticTokens.on(function(params) {
  return WaitForResolveSymbols(params);
});
function getPathName(uri) {
  let pathname = decodeURIComponent(uri.replace("file://", "")).replace(/\//g, "\\");
  if (pathname.startsWith("\\"))
    pathname = pathname.substr(1);
  return pathname;
}
function getFileUri(pathname) {
  let uri = pathname.replace(/\\/g, "/");
  if (!uri.startsWith("/"))
    uri = "/" + uri;
  return "file://" + uri;
}
function getModuleName(uri) {
  let modulename = decodeURIComponent(uri);
  for (let rootUri of RootUris) {
    if (modulename.startsWith(rootUri)) {
      modulename = modulename.replace(rootUri, "");
      break;
    }
  }
  modulename = modulename.replace(".as", "");
  modulename = modulename.replace(/\//g, ".");
  if (modulename[0] == ".")
    modulename = modulename.substr(1);
  return modulename;
}
connection.onRequest("angelscript/getModuleForSymbol", (...params) => {
  let pos = params[0];
  let asmodule = GetAndParseModule(pos.textDocument.uri);
  if (!asmodule)
    return null;
  if (!asmodule.resolved)
    return null;
  if (scriptfiles.GetScriptSettings().automaticImports)
    return "-";
  let unimportedSymbol = scriptsymbols.FindUnimportedSymbolOnLine(asmodule, pos.position);
  if (unimportedSymbol) {
    let symbolDefs = scriptsymbols.GetSymbolDefinition(asmodule, unimportedSymbol);
    if (symbolDefs) {
      for (let def of symbolDefs) {
        if (def.module.modulename == asmodule.modulename)
          continue;
        return def.module.modulename;
      }
    }
  }
  let definitions = scriptsymbols.GetDefinition(asmodule, pos.position);
  if (definitions == null) {
    connection.console.log(`Definition not found`);
    return "";
  }
  {
    let defArray = definitions;
    let moduleName = getModuleName(defArray[0].uri);
    if (moduleName == asmodule.modulename)
      return "-";
    return moduleName;
  }
});
connection.onRequest("angelscript/getAPI", (root) => {
  if (typedb.HasTypesFromUnreal())
    return api_docs.GetAPIList(root);
  function timerFunc(resolve, reject, triesLeft) {
    if (typedb.HasTypesFromUnreal())
      return resolve(api_docs.GetAPIList(root));
    setTimeout(function() {
      timerFunc(resolve, reject, triesLeft - 1);
    }, 100);
  }
  let promise = new Promise(function(resolve, reject) {
    timerFunc(resolve, reject, 50);
  });
  return promise;
});
connection.onRequest("angelscript/getAPISearch", (filter) => {
  if (typedb.HasTypesFromUnreal())
    return api_docs.GetAPISearch(filter);
  function timerFunc(resolve, reject, triesLeft) {
    if (typedb.HasTypesFromUnreal())
      return resolve(api_docs.GetAPISearch(filter));
    setTimeout(function() {
      timerFunc(resolve, reject, triesLeft - 1);
    }, 100);
  }
  let promise = new Promise(function(resolve, reject) {
    timerFunc(resolve, reject, 50);
  });
  return promise;
});
connection.onRequest("angelscript/getAPIDetails", (root) => {
  if (typedb.HasTypesFromUnreal())
    return api_docs.GetAPIDetails(root);
  function timerFunc(resolve, reject, triesLeft) {
    if (typedb.HasTypesFromUnreal())
      return resolve(api_docs.GetAPIDetails(root));
    setTimeout(function() {
      timerFunc(resolve, reject, triesLeft - 1);
    }, 100);
  }
  let promise = new Promise(function(resolve, reject) {
    timerFunc(resolve, reject, 50);
  });
  return promise;
});
connection.languages.inlineValue.on(function(params) {
  let asmodule = GetAndParseModule(params.textDocument.uri);
  if (!asmodule)
    return null;
  if (!asmodule.resolved)
    return null;
  return inlinevalues.ProvideInlineValues(asmodule, params.context.stoppedLocation.start);
});
connection.onDidChangeTextDocument((params) => {
  if (params.contentChanges.length == 0)
    return;
  let uri = params.textDocument.uri;
  let modulename = getModuleName(uri);
  let asmodule = scriptfiles.GetOrCreateModule(modulename, getPathName(uri), uri);
  if (!asmodule.loaded)
    scriptfiles.UpdateModuleFromDisk(asmodule);
  scriptfiles.UpdateModuleFromContentChanges(asmodule, params.contentChanges);
  if (!asmodule.queuedParse) {
    asmodule.queuedParse = setTimeout(function() {
      asmodule.queuedParse = null;
      scriptfiles.ParseModuleAndDependencies(asmodule);
      if (CanResolveModules() && ParseQueue.length == 0 && LoadQueue.length == 0) {
        scriptfiles.PostProcessModuleTypesAndDependencies(asmodule);
        scriptfiles.ResolveModule(asmodule);
        scriptdiagnostics.UpdateScriptModuleDiagnostics(asmodule);
      }
    }, 100);
  }
  if (asmodule.lastEditStart != -1 && parsedcompletion.GetCompletionSettings().correctFloatLiteralsWhenExpectingDoublePrecision) {
    let floatPromise = parsedcompletion.HandleFloatLiteralHelper(asmodule);
    if (floatPromise) {
      floatPromise.then(function(edit) {
        if (edit)
          connection.workspace.applyEdit(edit);
      });
    }
  }
});
connection.onDidOpenTextDocument(function(params) {
  let uri = params.textDocument.uri;
  let modulename = getModuleName(uri);
  let asmodule = scriptfiles.GetOrCreateModule(modulename, getPathName(uri), uri);
  asmodule.isOpened = true;
  scriptfiles.UpdateModuleFromContent(asmodule, params.textDocument.text);
  scriptfiles.ParseModuleAndDependencies(asmodule);
  if (CanResolveModules() && ParseQueue.length == 0 && LoadQueue.length == 0) {
    scriptfiles.PostProcessModuleTypesAndDependencies(asmodule);
    scriptfiles.ResolveModule(asmodule);
    scriptdiagnostics.UpdateScriptModuleDiagnostics(asmodule);
  }
});
connection.onDidCloseTextDocument(function(params) {
  let asmodule = scriptfiles.GetModuleByUri(params.textDocument.uri);
  if (asmodule)
    asmodule.isOpened = false;
});
connection.onDidChangeConfiguration(function(change) {
  let settingsObject = change.settings;
  settings = settingsObject.UnrealAngelscript;
  if (!settings)
    return;
  let diagnosticSettings = scriptdiagnostics.GetDiagnosticSettings();
  let dirtyDiagnostics = false;
  if (diagnosticSettings.namingConventionDiagnostics != settings.diagnosticsForUnrealNamingConvention) {
    diagnosticSettings.namingConventionDiagnostics = settings.diagnosticsForUnrealNamingConvention;
    dirtyDiagnostics = true;
  }
  if (diagnosticSettings.markUnreadVariablesAsUnused != settings.markUnreadVariablesAsUnused) {
    diagnosticSettings.markUnreadVariablesAsUnused = settings.markUnreadVariablesAsUnused;
    dirtyDiagnostics = true;
  }
  if (dirtyDiagnostics)
    DirtyAllDiagnostics();
  if (port != settings.unrealConnectionPort) {
    port = settings.unrealConnectionPort;
    connect_unreal();
  }
  let completionSettings = parsedcompletion.GetCompletionSettings();
  completionSettings.mathCompletionShortcuts = settings.mathCompletionShortcuts;
  completionSettings.dependencyRestrictions = settings.completion.dependencyRestrictions;
  completionSettings.correctFloatLiteralsWhenExpectingDoublePrecision = settings.correctFloatLiteralsWhenExpectingDoublePrecision;
  parsedcompletion.RefreshDependencyRestrictions();
  let inlayHintSettings = inlayhints.GetInlayHintSettings();
  inlayHintSettings.inlayHintsEnabled = settings.inlayHints.inlayHintsEnabled;
  inlayHintSettings.parameterHintsForConstants = settings.inlayHints.parameterHintsForConstants;
  inlayHintSettings.parameterHintsForComplexExpressions = settings.inlayHints.parameterHintsForComplexExpressions;
  inlayHintSettings.parameterReferenceHints = settings.inlayHints.parameterReferenceHints;
  inlayHintSettings.parameterHintsForSingleParameterFunctions = settings.inlayHints.parameterHintsForSingleParameterFunctions;
  inlayHintSettings.typeHintsForAutos = settings.inlayHints.typeHintsForAutos;
  inlayHintSettings.typeHintsIgnoredTypes = new Set(settings.inlayHints.typeHintsForAutoIgnoredTypes);
  inlayHintSettings.parameterHintsIgnoredParameterNames = new Set(settings.inlayHints.parameterHintsIgnoredParameterNames);
  inlayHintSettings.parameterHintsIgnoredFunctionNames = new Set(settings.inlayHints.parameterHintsIgnoredFunctionNames);
  let inlineValueSettings = inlinevalues.GetInlineValueSettings();
  inlineValueSettings.showInlineValueForFunctionThisObject = settings.inlineValues.showInlineValueForFunctionThisObject;
  inlineValueSettings.showInlineValueForLocalVariables = settings.inlineValues.showInlineValueForLocalVariables;
  inlineValueSettings.showInlineValueForParameters = settings.inlineValues.showInlineValueForParameters;
  inlineValueSettings.showInlineValueForMemberAssignment = settings.inlineValues.showInlineValueForMemberAssignment;
  let codeLensSettings = scriptlenses.GetCodeLensSettings();
  codeLensSettings.showCreateBlueprintClasses = settings.codeLenses.showCreateBlueprintClasses;
  let projectCodeGenerationSettings = generatedcode.GetProjectCodeGenerationSettings();
  projectCodeGenerationSettings.enable = settings.projectCodeGeneration.enable;
  projectCodeGenerationSettings.generators = settings.projectCodeGeneration.generators;
});
function TryResolveInlayHints(asmodule, range) {
  if (CanResolveModules()) {
    if (!asmodule)
      return null;
    scriptfiles.ParseModuleAndDependencies(asmodule);
    scriptfiles.PostProcessModuleTypesAndDependencies(asmodule);
    scriptfiles.ResolveModule(asmodule);
    return inlayhints.GetInlayHintsForRange(asmodule, range);
  } else {
    return null;
  }
}
function WaitForInlayHints(uri, range) {
  let asmodule = scriptfiles.GetModuleByUri(uri);
  let result = TryResolveInlayHints(asmodule, range);
  if (result)
    return result;
  function timerFunc(resolve, reject, triesLeft) {
    let result2 = TryResolveInlayHints(asmodule, range);
    if (result2)
      return resolve(result2);
    setTimeout(function() {
      timerFunc(resolve, reject, triesLeft - 1);
    }, 100);
  }
  let promise = new Promise(function(resolve, reject) {
    timerFunc(resolve, reject, 50);
  });
  return promise;
}
connection.languages.inlayHint.on(function(params) {
  let uri = params.textDocument.uri;
  return WaitForInlayHints(uri, params.range);
});
connection.onDocumentColor(function(params) {
  let asmodule = GetAndParseModule(params.textDocument.uri);
  if (!asmodule)
    return null;
  if (!asmodule.resolved)
    return null;
  return colorpicker.ProvideDocumentColors(asmodule);
});
connection.onColorPresentation(function(params) {
  let asmodule = GetAndParseModule(params.textDocument.uri);
  if (!asmodule)
    return null;
  if (!asmodule.resolved)
    return null;
  return colorpicker.ProvideColorPresentations(asmodule, params.range, params.color);
});
connection.languages.typeHierarchy.onPrepare(function(params) {
  let asmodule = GetAndParseModule(params.textDocument.uri);
  if (!asmodule)
    return null;
  if (!asmodule.resolved)
    return null;
  return typehierarchy.PrepareTypeHierarchy(asmodule, params.position);
});
connection.languages.typeHierarchy.onSupertypes(function(params) {
  return typehierarchy.GetTypeHierarchySupertypes(params.item);
});
connection.languages.typeHierarchy.onSubtypes(function(params) {
  return typehierarchy.GetTypeHierarchySubtypes(params.item);
});
connection.listen();
